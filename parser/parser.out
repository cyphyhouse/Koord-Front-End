Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Unused terminals:

    WS

Grammar

Rule 0     S' -> program
Rule 1     program -> agent modules awdecls ardecls locdecls init events
Rule 2     agent -> AGENT CID NL
Rule 3     modules -> module modules
Rule 4     modules -> empty
Rule 5     module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT
Rule 6     actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT
Rule 7     actuatordecls -> ACTUATORS COLON NL INDENT pass DEDENT
Rule 8     sensordecls -> SENSORS COLON NL INDENT decls DEDENT
Rule 9     sensordecls -> SENSORS COLON NL INDENT pass DEDENT
Rule 10    awdecls -> ALLWRITE COLON NL INDENT decls DEDENT
Rule 11    awdecls -> ALLWRITE COLON NL INDENT pass DEDENT
Rule 12    ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT
Rule 13    ardecls -> ALLREAD COLON NL INDENT pass DEDENT
Rule 14    locdecls -> LOCAL COLON NL INDENT decls DEDENT
Rule 15    decls -> decl decls
Rule 16    decls -> empty
Rule 17    decl -> type varnames NL
Rule 18    decl -> type varname ASGN exp NL
Rule 19    decl -> mapdecl NL
Rule 20    mapdecl -> MAP LT type COMMA type GT varname
Rule 21    rvdecls -> rvdecl rvdecls
Rule 22    rvdecls -> empty
Rule 23    rvdecl -> type varname LBRACE owner RBRACE NL
Rule 24    rvdecl -> type varname LBRACE owner RBRACE ASGN num NL
Rule 25    owner -> TIMES
Rule 26    owner -> INUM
Rule 27    funccall -> varname LPAR args RPAR
Rule 28    args -> neargs
Rule 29    args -> noargs
Rule 30    noargs -> empty
Rule 31    neargs -> exp
Rule 32    neargs -> exp COMMA neargs
Rule 33    varnames -> varname
Rule 34    varnames -> varname COMMA varnames
Rule 35    type -> INT
Rule 36    type -> STRING
Rule 37    type -> FLOAT
Rule 38    type -> IPOS
Rule 39    type -> BOOLEAN
Rule 40    init -> INIT COLON NL INDENT stmts DEDENT
Rule 41    init -> empty
Rule 42    events -> event events
Rule 43    events -> empty
Rule 44    event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT
Rule 45    effblock -> EFF COLON NL INDENT stmts DEDENT
Rule 46    effblock -> EFF COLON stmt
Rule 47    cond -> LPAR cond AND cond RPAR
Rule 48    cond -> LPAR cond OR cond RPAR
Rule 49    cond -> LPAR exp op exp RPAR
Rule 50    cond -> LPAR NOT cond RPAR
Rule 51    cond -> exp
Rule 52    stmts -> stmt stmts
Rule 53    stmts -> empty
Rule 54    stmt -> asgn
Rule 55    stmt -> funccall NL
Rule 56    stmt -> modulefunccall NL
Rule 57    stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock
Rule 58    stmt -> pass
Rule 59    modulefunccall -> CID LPAR args RPAR
Rule 60    elseblock -> ELSE COLON NL INDENT stmts DEDENT
Rule 61    pass -> PASS NL
Rule 62    asgn -> varname ASGN exp NL
Rule 63    exp -> exp PLUS exp
Rule 64    exp -> exp TIMES exp
Rule 65    exp -> exp MINUS exp
Rule 66    exp -> exp BY exp
Rule 67    exp -> varname
Rule 68    exp -> TRUE
Rule 69    exp -> FALSE
Rule 70    exp -> num
Rule 71    exp -> funccall
Rule 72    num -> INUM
Rule 73    num -> FNUM
Rule 74    varname -> LID
Rule 75    op -> EQ
Rule 76    op -> NEQ
Rule 77    op -> GEQ
Rule 78    op -> LEQ
Rule 79    op -> GT
Rule 80    op -> LT
Rule 81    empty -> <empty>

Terminals, with rules where they appear

ACTUATORS            : 6 7
AGENT                : 2
ALLREAD              : 12 13
ALLWRITE             : 10 11
AND                  : 47
ASGN                 : 18 24 62
BOOLEAN              : 39
BY                   : 66
CID                  : 2 5 59
COLON                : 5 6 7 8 9 10 11 12 13 14 40 44 44 45 46 57 60
COMMA                : 20 32 34
DEDENT               : 5 6 7 8 9 10 11 12 13 14 40 44 45 57 60
EFF                  : 45 46
ELSE                 : 60
EQ                   : 75
FALSE                : 69
FLOAT                : 37
FNUM                 : 73
GEQ                  : 77
GT                   : 20 79
IF                   : 57
INDENT               : 5 6 7 8 9 10 11 12 13 14 40 44 45 57 60
INIT                 : 40
INT                  : 35
INUM                 : 26 72
IPOS                 : 38
LBRACE               : 23 24
LEQ                  : 78
LID                  : 44 74
LOCAL                : 14
LPAR                 : 27 47 48 49 50 59
LT                   : 20 80
MAP                  : 20
MINUS                : 65
MODULE               : 5
NEQ                  : 76
NL                   : 2 5 6 7 8 9 10 11 12 13 14 17 18 19 23 24 40 44 44 45 55 56 57 60 61 62
NOT                  : 50
OR                   : 48
PASS                 : 61
PLUS                 : 63
PRE                  : 44
RBRACE               : 23 24
RPAR                 : 27 47 48 49 50 59
SENSORS              : 8 9
STRING               : 36
TIMES                : 25 64
TRUE                 : 68
USING                : 5
WS                   : 
error                : 

Nonterminals, with rules where they appear

actuatordecls        : 5
agent                : 1
ardecls              : 1
args                 : 27 59
asgn                 : 54
awdecls              : 1
cond                 : 44 47 47 48 48 50 57
decl                 : 15
decls                : 6 8 10 14 15
effblock             : 44
elseblock            : 57
empty                : 4 16 22 30 41 43 53
event                : 42
events               : 1 42
exp                  : 18 31 32 49 49 51 62 63 63 64 64 65 65 66 66
funccall             : 55 71
init                 : 1
locdecls             : 1
mapdecl              : 19
module               : 3
modulefunccall       : 56
modules              : 1 3
neargs               : 28 32
noargs               : 29
num                  : 24 70
op                   : 49
owner                : 23 24
pass                 : 7 9 11 13 58
program              : 0
rvdecl               : 21
rvdecls              : 12 21
sensordecls          : 5
stmt                 : 46 52
stmts                : 40 45 52 57 60
type                 : 17 18 20 20 23 24
varname              : 18 20 23 24 27 33 34 62 67
varnames             : 17 34

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . agent modules awdecls ardecls locdecls init events
    (2) agent -> . AGENT CID NL

    AGENT           shift and go to state 3

    agent                          shift and go to state 1
    program                        shift and go to state 2

state 1

    (1) program -> agent . modules awdecls ardecls locdecls init events
    (3) modules -> . module modules
    (4) modules -> . empty
    (5) module -> . USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT
    (81) empty -> .

    USING           shift and go to state 6
    ALLWRITE        reduce using rule 81 (empty -> .)

    modules                        shift and go to state 4
    module                         shift and go to state 5
    empty                          shift and go to state 7

state 2

    (0) S' -> program .



state 3

    (2) agent -> AGENT . CID NL

    CID             shift and go to state 8


state 4

    (1) program -> agent modules . awdecls ardecls locdecls init events
    (10) awdecls -> . ALLWRITE COLON NL INDENT decls DEDENT
    (11) awdecls -> . ALLWRITE COLON NL INDENT pass DEDENT

    ALLWRITE        shift and go to state 10

    awdecls                        shift and go to state 9

state 5

    (3) modules -> module . modules
    (3) modules -> . module modules
    (4) modules -> . empty
    (5) module -> . USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT
    (81) empty -> .

    USING           shift and go to state 6
    ALLWRITE        reduce using rule 81 (empty -> .)

    modules                        shift and go to state 11
    empty                          shift and go to state 7
    module                         shift and go to state 5

state 6

    (5) module -> USING . MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT

    MODULE          shift and go to state 12


state 7

    (4) modules -> empty .

    ALLWRITE        reduce using rule 4 (modules -> empty .)


state 8

    (2) agent -> AGENT CID . NL

    NL              shift and go to state 13


state 9

    (1) program -> agent modules awdecls . ardecls locdecls init events
    (12) ardecls -> . ALLREAD COLON NL INDENT rvdecls DEDENT
    (13) ardecls -> . ALLREAD COLON NL INDENT pass DEDENT

    ALLREAD         shift and go to state 14

    ardecls                        shift and go to state 15

state 10

    (10) awdecls -> ALLWRITE . COLON NL INDENT decls DEDENT
    (11) awdecls -> ALLWRITE . COLON NL INDENT pass DEDENT

    COLON           shift and go to state 16


state 11

    (3) modules -> module modules .

    ALLWRITE        reduce using rule 3 (modules -> module modules .)


state 12

    (5) module -> USING MODULE . CID COLON NL INDENT actuatordecls sensordecls DEDENT

    CID             shift and go to state 17


state 13

    (2) agent -> AGENT CID NL .

    USING           reduce using rule 2 (agent -> AGENT CID NL .)
    ALLWRITE        reduce using rule 2 (agent -> AGENT CID NL .)


state 14

    (12) ardecls -> ALLREAD . COLON NL INDENT rvdecls DEDENT
    (13) ardecls -> ALLREAD . COLON NL INDENT pass DEDENT

    COLON           shift and go to state 18


state 15

    (1) program -> agent modules awdecls ardecls . locdecls init events
    (14) locdecls -> . LOCAL COLON NL INDENT decls DEDENT

    LOCAL           shift and go to state 20

    locdecls                       shift and go to state 19

state 16

    (10) awdecls -> ALLWRITE COLON . NL INDENT decls DEDENT
    (11) awdecls -> ALLWRITE COLON . NL INDENT pass DEDENT

    NL              shift and go to state 21


state 17

    (5) module -> USING MODULE CID . COLON NL INDENT actuatordecls sensordecls DEDENT

    COLON           shift and go to state 22


state 18

    (12) ardecls -> ALLREAD COLON . NL INDENT rvdecls DEDENT
    (13) ardecls -> ALLREAD COLON . NL INDENT pass DEDENT

    NL              shift and go to state 23


state 19

    (1) program -> agent modules awdecls ardecls locdecls . init events
    (40) init -> . INIT COLON NL INDENT stmts DEDENT
    (41) init -> . empty
    (81) empty -> .

    INIT            shift and go to state 24
    LID             reduce using rule 81 (empty -> .)
    $end            reduce using rule 81 (empty -> .)

    init                           shift and go to state 25
    empty                          shift and go to state 26

state 20

    (14) locdecls -> LOCAL . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 27


state 21

    (10) awdecls -> ALLWRITE COLON NL . INDENT decls DEDENT
    (11) awdecls -> ALLWRITE COLON NL . INDENT pass DEDENT

    INDENT          shift and go to state 28


state 22

    (5) module -> USING MODULE CID COLON . NL INDENT actuatordecls sensordecls DEDENT

    NL              shift and go to state 29


state 23

    (12) ardecls -> ALLREAD COLON NL . INDENT rvdecls DEDENT
    (13) ardecls -> ALLREAD COLON NL . INDENT pass DEDENT

    INDENT          shift and go to state 30


state 24

    (40) init -> INIT . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 31


state 25

    (1) program -> agent modules awdecls ardecls locdecls init . events
    (42) events -> . event events
    (43) events -> . empty
    (44) event -> . LID COLON NL INDENT PRE COLON cond NL effblock DEDENT
    (81) empty -> .

    LID             shift and go to state 32
    $end            reduce using rule 81 (empty -> .)

    event                          shift and go to state 33
    events                         shift and go to state 34
    empty                          shift and go to state 35

state 26

    (41) init -> empty .

    LID             reduce using rule 41 (init -> empty .)
    $end            reduce using rule 41 (init -> empty .)


state 27

    (14) locdecls -> LOCAL COLON . NL INDENT decls DEDENT

    NL              shift and go to state 36


state 28

    (10) awdecls -> ALLWRITE COLON NL INDENT . decls DEDENT
    (11) awdecls -> ALLWRITE COLON NL INDENT . pass DEDENT
    (15) decls -> . decl decls
    (16) decls -> . empty
    (61) pass -> . PASS NL
    (17) decl -> . type varnames NL
    (18) decl -> . type varname ASGN exp NL
    (19) decl -> . mapdecl NL
    (81) empty -> .
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN
    (20) mapdecl -> . MAP LT type COMMA type GT varname

    PASS            shift and go to state 44
    DEDENT          reduce using rule 81 (empty -> .)
    INT             shift and go to state 47
    STRING          shift and go to state 43
    FLOAT           shift and go to state 48
    IPOS            shift and go to state 40
    BOOLEAN         shift and go to state 49
    MAP             shift and go to state 46

    decl                           shift and go to state 37
    mapdecl                        shift and go to state 38
    pass                           shift and go to state 39
    decls                          shift and go to state 45
    type                           shift and go to state 41
    empty                          shift and go to state 42

state 29

    (5) module -> USING MODULE CID COLON NL . INDENT actuatordecls sensordecls DEDENT

    INDENT          shift and go to state 50


state 30

    (12) ardecls -> ALLREAD COLON NL INDENT . rvdecls DEDENT
    (13) ardecls -> ALLREAD COLON NL INDENT . pass DEDENT
    (21) rvdecls -> . rvdecl rvdecls
    (22) rvdecls -> . empty
    (61) pass -> . PASS NL
    (23) rvdecl -> . type varname LBRACE owner RBRACE NL
    (24) rvdecl -> . type varname LBRACE owner RBRACE ASGN num NL
    (81) empty -> .
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN

    PASS            shift and go to state 44
    DEDENT          reduce using rule 81 (empty -> .)
    INT             shift and go to state 47
    STRING          shift and go to state 43
    FLOAT           shift and go to state 48
    IPOS            shift and go to state 40
    BOOLEAN         shift and go to state 49

    rvdecl                         shift and go to state 53
    pass                           shift and go to state 52
    rvdecls                        shift and go to state 51
    type                           shift and go to state 54
    empty                          shift and go to state 55

state 31

    (40) init -> INIT COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 56


state 32

    (44) event -> LID . COLON NL INDENT PRE COLON cond NL effblock DEDENT

    COLON           shift and go to state 57


state 33

    (42) events -> event . events
    (42) events -> . event events
    (43) events -> . empty
    (44) event -> . LID COLON NL INDENT PRE COLON cond NL effblock DEDENT
    (81) empty -> .

    LID             shift and go to state 32
    $end            reduce using rule 81 (empty -> .)

    event                          shift and go to state 33
    empty                          shift and go to state 35
    events                         shift and go to state 58

state 34

    (1) program -> agent modules awdecls ardecls locdecls init events .

    $end            reduce using rule 1 (program -> agent modules awdecls ardecls locdecls init events .)


state 35

    (43) events -> empty .

    $end            reduce using rule 43 (events -> empty .)


state 36

    (14) locdecls -> LOCAL COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 59


state 37

    (15) decls -> decl . decls
    (15) decls -> . decl decls
    (16) decls -> . empty
    (17) decl -> . type varnames NL
    (18) decl -> . type varname ASGN exp NL
    (19) decl -> . mapdecl NL
    (81) empty -> .
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN
    (20) mapdecl -> . MAP LT type COMMA type GT varname

    DEDENT          reduce using rule 81 (empty -> .)
    INT             shift and go to state 47
    STRING          shift and go to state 43
    FLOAT           shift and go to state 48
    IPOS            shift and go to state 40
    BOOLEAN         shift and go to state 49
    MAP             shift and go to state 46

    decl                           shift and go to state 37
    mapdecl                        shift and go to state 38
    decls                          shift and go to state 60
    type                           shift and go to state 41
    empty                          shift and go to state 42

state 38

    (19) decl -> mapdecl . NL

    NL              shift and go to state 61


state 39

    (11) awdecls -> ALLWRITE COLON NL INDENT pass . DEDENT

    DEDENT          shift and go to state 62


state 40

    (38) type -> IPOS .

    COMMA           reduce using rule 38 (type -> IPOS .)
    LID             reduce using rule 38 (type -> IPOS .)
    GT              reduce using rule 38 (type -> IPOS .)


state 41

    (17) decl -> type . varnames NL
    (18) decl -> type . varname ASGN exp NL
    (33) varnames -> . varname
    (34) varnames -> . varname COMMA varnames
    (74) varname -> . LID

    LID             shift and go to state 63

    varnames                       shift and go to state 65
    varname                        shift and go to state 64

state 42

    (16) decls -> empty .

    DEDENT          reduce using rule 16 (decls -> empty .)


state 43

    (36) type -> STRING .

    COMMA           reduce using rule 36 (type -> STRING .)
    LID             reduce using rule 36 (type -> STRING .)
    GT              reduce using rule 36 (type -> STRING .)


state 44

    (61) pass -> PASS . NL

    NL              shift and go to state 66


state 45

    (10) awdecls -> ALLWRITE COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 67


state 46

    (20) mapdecl -> MAP . LT type COMMA type GT varname

    LT              shift and go to state 68


state 47

    (35) type -> INT .

    COMMA           reduce using rule 35 (type -> INT .)
    LID             reduce using rule 35 (type -> INT .)
    GT              reduce using rule 35 (type -> INT .)


state 48

    (37) type -> FLOAT .

    COMMA           reduce using rule 37 (type -> FLOAT .)
    LID             reduce using rule 37 (type -> FLOAT .)
    GT              reduce using rule 37 (type -> FLOAT .)


state 49

    (39) type -> BOOLEAN .

    COMMA           reduce using rule 39 (type -> BOOLEAN .)
    LID             reduce using rule 39 (type -> BOOLEAN .)
    GT              reduce using rule 39 (type -> BOOLEAN .)


state 50

    (5) module -> USING MODULE CID COLON NL INDENT . actuatordecls sensordecls DEDENT
    (6) actuatordecls -> . ACTUATORS COLON NL INDENT decls DEDENT
    (7) actuatordecls -> . ACTUATORS COLON NL INDENT pass DEDENT

    ACTUATORS       shift and go to state 69

    actuatordecls                  shift and go to state 70

state 51

    (12) ardecls -> ALLREAD COLON NL INDENT rvdecls . DEDENT

    DEDENT          shift and go to state 71


state 52

    (13) ardecls -> ALLREAD COLON NL INDENT pass . DEDENT

    DEDENT          shift and go to state 72


state 53

    (21) rvdecls -> rvdecl . rvdecls
    (21) rvdecls -> . rvdecl rvdecls
    (22) rvdecls -> . empty
    (23) rvdecl -> . type varname LBRACE owner RBRACE NL
    (24) rvdecl -> . type varname LBRACE owner RBRACE ASGN num NL
    (81) empty -> .
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN

    DEDENT          reduce using rule 81 (empty -> .)
    INT             shift and go to state 47
    STRING          shift and go to state 43
    FLOAT           shift and go to state 48
    IPOS            shift and go to state 40
    BOOLEAN         shift and go to state 49

    rvdecl                         shift and go to state 53
    rvdecls                        shift and go to state 73
    type                           shift and go to state 54
    empty                          shift and go to state 55

state 54

    (23) rvdecl -> type . varname LBRACE owner RBRACE NL
    (24) rvdecl -> type . varname LBRACE owner RBRACE ASGN num NL
    (74) varname -> . LID

    LID             shift and go to state 63

    varname                        shift and go to state 74

state 55

    (22) rvdecls -> empty .

    DEDENT          reduce using rule 22 (rvdecls -> empty .)


state 56

    (40) init -> INIT COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 75


state 57

    (44) event -> LID COLON . NL INDENT PRE COLON cond NL effblock DEDENT

    NL              shift and go to state 76


state 58

    (42) events -> event events .

    $end            reduce using rule 42 (events -> event events .)


state 59

    (14) locdecls -> LOCAL COLON NL INDENT . decls DEDENT
    (15) decls -> . decl decls
    (16) decls -> . empty
    (17) decl -> . type varnames NL
    (18) decl -> . type varname ASGN exp NL
    (19) decl -> . mapdecl NL
    (81) empty -> .
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN
    (20) mapdecl -> . MAP LT type COMMA type GT varname

    DEDENT          reduce using rule 81 (empty -> .)
    INT             shift and go to state 47
    STRING          shift and go to state 43
    FLOAT           shift and go to state 48
    IPOS            shift and go to state 40
    BOOLEAN         shift and go to state 49
    MAP             shift and go to state 46

    decl                           shift and go to state 37
    mapdecl                        shift and go to state 38
    decls                          shift and go to state 77
    type                           shift and go to state 41
    empty                          shift and go to state 42

state 60

    (15) decls -> decl decls .

    DEDENT          reduce using rule 15 (decls -> decl decls .)


state 61

    (19) decl -> mapdecl NL .

    INT             reduce using rule 19 (decl -> mapdecl NL .)
    STRING          reduce using rule 19 (decl -> mapdecl NL .)
    FLOAT           reduce using rule 19 (decl -> mapdecl NL .)
    IPOS            reduce using rule 19 (decl -> mapdecl NL .)
    BOOLEAN         reduce using rule 19 (decl -> mapdecl NL .)
    MAP             reduce using rule 19 (decl -> mapdecl NL .)
    DEDENT          reduce using rule 19 (decl -> mapdecl NL .)


state 62

    (11) awdecls -> ALLWRITE COLON NL INDENT pass DEDENT .

    ALLREAD         reduce using rule 11 (awdecls -> ALLWRITE COLON NL INDENT pass DEDENT .)


state 63

    (74) varname -> LID .

    LPAR            reduce using rule 74 (varname -> LID .)
    PLUS            reduce using rule 74 (varname -> LID .)
    TIMES           reduce using rule 74 (varname -> LID .)
    MINUS           reduce using rule 74 (varname -> LID .)
    BY              reduce using rule 74 (varname -> LID .)
    RPAR            reduce using rule 74 (varname -> LID .)
    NL              reduce using rule 74 (varname -> LID .)
    ASGN            reduce using rule 74 (varname -> LID .)
    COMMA           reduce using rule 74 (varname -> LID .)
    COLON           reduce using rule 74 (varname -> LID .)
    EQ              reduce using rule 74 (varname -> LID .)
    NEQ             reduce using rule 74 (varname -> LID .)
    GEQ             reduce using rule 74 (varname -> LID .)
    LEQ             reduce using rule 74 (varname -> LID .)
    GT              reduce using rule 74 (varname -> LID .)
    LT              reduce using rule 74 (varname -> LID .)
    AND             reduce using rule 74 (varname -> LID .)
    OR              reduce using rule 74 (varname -> LID .)
    LBRACE          reduce using rule 74 (varname -> LID .)


state 64

    (18) decl -> type varname . ASGN exp NL
    (33) varnames -> varname .
    (34) varnames -> varname . COMMA varnames

    ASGN            shift and go to state 78
    NL              reduce using rule 33 (varnames -> varname .)
    COMMA           shift and go to state 79


state 65

    (17) decl -> type varnames . NL

    NL              shift and go to state 80


state 66

    (61) pass -> PASS NL .

    IF              reduce using rule 61 (pass -> PASS NL .)
    CID             reduce using rule 61 (pass -> PASS NL .)
    PASS            reduce using rule 61 (pass -> PASS NL .)
    LID             reduce using rule 61 (pass -> PASS NL .)
    DEDENT          reduce using rule 61 (pass -> PASS NL .)


state 67

    (10) awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .

    ALLREAD         reduce using rule 10 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)


state 68

    (20) mapdecl -> MAP LT . type COMMA type GT varname
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN

    INT             shift and go to state 47
    STRING          shift and go to state 43
    FLOAT           shift and go to state 48
    IPOS            shift and go to state 40
    BOOLEAN         shift and go to state 49

    type                           shift and go to state 81

state 69

    (6) actuatordecls -> ACTUATORS . COLON NL INDENT decls DEDENT
    (7) actuatordecls -> ACTUATORS . COLON NL INDENT pass DEDENT

    COLON           shift and go to state 82


state 70

    (5) module -> USING MODULE CID COLON NL INDENT actuatordecls . sensordecls DEDENT
    (8) sensordecls -> . SENSORS COLON NL INDENT decls DEDENT
    (9) sensordecls -> . SENSORS COLON NL INDENT pass DEDENT

    SENSORS         shift and go to state 84

    sensordecls                    shift and go to state 83

state 71

    (12) ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .

    LOCAL           reduce using rule 12 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)


state 72

    (13) ardecls -> ALLREAD COLON NL INDENT pass DEDENT .

    LOCAL           reduce using rule 13 (ardecls -> ALLREAD COLON NL INDENT pass DEDENT .)


state 73

    (21) rvdecls -> rvdecl rvdecls .

    DEDENT          reduce using rule 21 (rvdecls -> rvdecl rvdecls .)


state 74

    (23) rvdecl -> type varname . LBRACE owner RBRACE NL
    (24) rvdecl -> type varname . LBRACE owner RBRACE ASGN num NL

    LBRACE          shift and go to state 85


state 75

    (40) init -> INIT COLON NL INDENT . stmts DEDENT
    (52) stmts -> . stmt stmts
    (53) stmts -> . empty
    (54) stmt -> . asgn
    (55) stmt -> . funccall NL
    (56) stmt -> . modulefunccall NL
    (57) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (58) stmt -> . pass
    (81) empty -> .
    (62) asgn -> . varname ASGN exp NL
    (27) funccall -> . varname LPAR args RPAR
    (59) modulefunccall -> . CID LPAR args RPAR
    (61) pass -> . PASS NL
    (74) varname -> . LID

    IF              shift and go to state 94
    DEDENT          reduce using rule 81 (empty -> .)
    CID             shift and go to state 86
    PASS            shift and go to state 44
    LID             shift and go to state 63

    funccall                       shift and go to state 91
    stmts                          shift and go to state 88
    varname                        shift and go to state 95
    stmt                           shift and go to state 93
    asgn                           shift and go to state 89
    modulefunccall                 shift and go to state 92
    pass                           shift and go to state 87
    empty                          shift and go to state 90

state 76

    (44) event -> LID COLON NL . INDENT PRE COLON cond NL effblock DEDENT

    INDENT          shift and go to state 96


state 77

    (14) locdecls -> LOCAL COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 97


state 78

    (18) decl -> type varname ASGN . exp NL
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    funccall                       shift and go to state 98
    varname                        shift and go to state 99
    num                            shift and go to state 101
    exp                            shift and go to state 102

state 79

    (34) varnames -> varname COMMA . varnames
    (33) varnames -> . varname
    (34) varnames -> . varname COMMA varnames
    (74) varname -> . LID

    LID             shift and go to state 63

    varname                        shift and go to state 106
    varnames                       shift and go to state 107

state 80

    (17) decl -> type varnames NL .

    INT             reduce using rule 17 (decl -> type varnames NL .)
    STRING          reduce using rule 17 (decl -> type varnames NL .)
    FLOAT           reduce using rule 17 (decl -> type varnames NL .)
    IPOS            reduce using rule 17 (decl -> type varnames NL .)
    BOOLEAN         reduce using rule 17 (decl -> type varnames NL .)
    MAP             reduce using rule 17 (decl -> type varnames NL .)
    DEDENT          reduce using rule 17 (decl -> type varnames NL .)


state 81

    (20) mapdecl -> MAP LT type . COMMA type GT varname

    COMMA           shift and go to state 108


state 82

    (6) actuatordecls -> ACTUATORS COLON . NL INDENT decls DEDENT
    (7) actuatordecls -> ACTUATORS COLON . NL INDENT pass DEDENT

    NL              shift and go to state 109


state 83

    (5) module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls . DEDENT

    DEDENT          shift and go to state 110


state 84

    (8) sensordecls -> SENSORS . COLON NL INDENT decls DEDENT
    (9) sensordecls -> SENSORS . COLON NL INDENT pass DEDENT

    COLON           shift and go to state 111


state 85

    (23) rvdecl -> type varname LBRACE . owner RBRACE NL
    (24) rvdecl -> type varname LBRACE . owner RBRACE ASGN num NL
    (25) owner -> . TIMES
    (26) owner -> . INUM

    TIMES           shift and go to state 114
    INUM            shift and go to state 112

    owner                          shift and go to state 113

state 86

    (59) modulefunccall -> CID . LPAR args RPAR

    LPAR            shift and go to state 115


state 87

    (58) stmt -> pass .

    IF              reduce using rule 58 (stmt -> pass .)
    CID             reduce using rule 58 (stmt -> pass .)
    PASS            reduce using rule 58 (stmt -> pass .)
    LID             reduce using rule 58 (stmt -> pass .)
    DEDENT          reduce using rule 58 (stmt -> pass .)


state 88

    (40) init -> INIT COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 116


state 89

    (54) stmt -> asgn .

    IF              reduce using rule 54 (stmt -> asgn .)
    CID             reduce using rule 54 (stmt -> asgn .)
    PASS            reduce using rule 54 (stmt -> asgn .)
    LID             reduce using rule 54 (stmt -> asgn .)
    DEDENT          reduce using rule 54 (stmt -> asgn .)


state 90

    (53) stmts -> empty .

    DEDENT          reduce using rule 53 (stmts -> empty .)


state 91

    (55) stmt -> funccall . NL

    NL              shift and go to state 117


state 92

    (56) stmt -> modulefunccall . NL

    NL              shift and go to state 118


state 93

    (52) stmts -> stmt . stmts
    (52) stmts -> . stmt stmts
    (53) stmts -> . empty
    (54) stmt -> . asgn
    (55) stmt -> . funccall NL
    (56) stmt -> . modulefunccall NL
    (57) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (58) stmt -> . pass
    (81) empty -> .
    (62) asgn -> . varname ASGN exp NL
    (27) funccall -> . varname LPAR args RPAR
    (59) modulefunccall -> . CID LPAR args RPAR
    (61) pass -> . PASS NL
    (74) varname -> . LID

    IF              shift and go to state 94
    DEDENT          reduce using rule 81 (empty -> .)
    CID             shift and go to state 86
    PASS            shift and go to state 44
    LID             shift and go to state 63

    funccall                       shift and go to state 91
    stmts                          shift and go to state 119
    varname                        shift and go to state 95
    stmt                           shift and go to state 93
    asgn                           shift and go to state 89
    modulefunccall                 shift and go to state 92
    pass                           shift and go to state 87
    empty                          shift and go to state 90

state 94

    (57) stmt -> IF . cond COLON NL INDENT stmts DEDENT elseblock
    (47) cond -> . LPAR cond AND cond RPAR
    (48) cond -> . LPAR cond OR cond RPAR
    (49) cond -> . LPAR exp op exp RPAR
    (50) cond -> . LPAR NOT cond RPAR
    (51) cond -> . exp
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 120
    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    funccall                       shift and go to state 98
    varname                        shift and go to state 99
    num                            shift and go to state 101
    cond                           shift and go to state 121
    exp                            shift and go to state 122

state 95

    (62) asgn -> varname . ASGN exp NL
    (27) funccall -> varname . LPAR args RPAR

    ASGN            shift and go to state 124
    LPAR            shift and go to state 123


state 96

    (44) event -> LID COLON NL INDENT . PRE COLON cond NL effblock DEDENT

    PRE             shift and go to state 125


state 97

    (14) locdecls -> LOCAL COLON NL INDENT decls DEDENT .

    INIT            reduce using rule 14 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)
    LID             reduce using rule 14 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)
    $end            reduce using rule 14 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)


state 98

    (71) exp -> funccall .

    COMMA           reduce using rule 71 (exp -> funccall .)
    PLUS            reduce using rule 71 (exp -> funccall .)
    TIMES           reduce using rule 71 (exp -> funccall .)
    MINUS           reduce using rule 71 (exp -> funccall .)
    BY              reduce using rule 71 (exp -> funccall .)
    RPAR            reduce using rule 71 (exp -> funccall .)
    NL              reduce using rule 71 (exp -> funccall .)
    COLON           reduce using rule 71 (exp -> funccall .)
    EQ              reduce using rule 71 (exp -> funccall .)
    NEQ             reduce using rule 71 (exp -> funccall .)
    GEQ             reduce using rule 71 (exp -> funccall .)
    LEQ             reduce using rule 71 (exp -> funccall .)
    GT              reduce using rule 71 (exp -> funccall .)
    LT              reduce using rule 71 (exp -> funccall .)
    AND             reduce using rule 71 (exp -> funccall .)
    OR              reduce using rule 71 (exp -> funccall .)


state 99

    (67) exp -> varname .
    (27) funccall -> varname . LPAR args RPAR

    COMMA           reduce using rule 67 (exp -> varname .)
    PLUS            reduce using rule 67 (exp -> varname .)
    TIMES           reduce using rule 67 (exp -> varname .)
    MINUS           reduce using rule 67 (exp -> varname .)
    BY              reduce using rule 67 (exp -> varname .)
    RPAR            reduce using rule 67 (exp -> varname .)
    NL              reduce using rule 67 (exp -> varname .)
    COLON           reduce using rule 67 (exp -> varname .)
    EQ              reduce using rule 67 (exp -> varname .)
    NEQ             reduce using rule 67 (exp -> varname .)
    GEQ             reduce using rule 67 (exp -> varname .)
    LEQ             reduce using rule 67 (exp -> varname .)
    GT              reduce using rule 67 (exp -> varname .)
    LT              reduce using rule 67 (exp -> varname .)
    AND             reduce using rule 67 (exp -> varname .)
    OR              reduce using rule 67 (exp -> varname .)
    LPAR            shift and go to state 123


state 100

    (73) num -> FNUM .

    PLUS            reduce using rule 73 (num -> FNUM .)
    TIMES           reduce using rule 73 (num -> FNUM .)
    MINUS           reduce using rule 73 (num -> FNUM .)
    BY              reduce using rule 73 (num -> FNUM .)
    NL              reduce using rule 73 (num -> FNUM .)
    COMMA           reduce using rule 73 (num -> FNUM .)
    RPAR            reduce using rule 73 (num -> FNUM .)
    COLON           reduce using rule 73 (num -> FNUM .)
    EQ              reduce using rule 73 (num -> FNUM .)
    NEQ             reduce using rule 73 (num -> FNUM .)
    GEQ             reduce using rule 73 (num -> FNUM .)
    LEQ             reduce using rule 73 (num -> FNUM .)
    GT              reduce using rule 73 (num -> FNUM .)
    LT              reduce using rule 73 (num -> FNUM .)
    AND             reduce using rule 73 (num -> FNUM .)
    OR              reduce using rule 73 (num -> FNUM .)


state 101

    (70) exp -> num .

    COMMA           reduce using rule 70 (exp -> num .)
    PLUS            reduce using rule 70 (exp -> num .)
    TIMES           reduce using rule 70 (exp -> num .)
    MINUS           reduce using rule 70 (exp -> num .)
    BY              reduce using rule 70 (exp -> num .)
    RPAR            reduce using rule 70 (exp -> num .)
    NL              reduce using rule 70 (exp -> num .)
    COLON           reduce using rule 70 (exp -> num .)
    EQ              reduce using rule 70 (exp -> num .)
    NEQ             reduce using rule 70 (exp -> num .)
    GEQ             reduce using rule 70 (exp -> num .)
    LEQ             reduce using rule 70 (exp -> num .)
    GT              reduce using rule 70 (exp -> num .)
    LT              reduce using rule 70 (exp -> num .)
    AND             reduce using rule 70 (exp -> num .)
    OR              reduce using rule 70 (exp -> num .)


state 102

    (18) decl -> type varname ASGN exp . NL
    (63) exp -> exp . PLUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . MINUS exp
    (66) exp -> exp . BY exp

    NL              shift and go to state 126
    PLUS            shift and go to state 128
    TIMES           shift and go to state 129
    MINUS           shift and go to state 130
    BY              shift and go to state 127


state 103

    (72) num -> INUM .

    PLUS            reduce using rule 72 (num -> INUM .)
    TIMES           reduce using rule 72 (num -> INUM .)
    MINUS           reduce using rule 72 (num -> INUM .)
    BY              reduce using rule 72 (num -> INUM .)
    NL              reduce using rule 72 (num -> INUM .)
    COMMA           reduce using rule 72 (num -> INUM .)
    RPAR            reduce using rule 72 (num -> INUM .)
    COLON           reduce using rule 72 (num -> INUM .)
    EQ              reduce using rule 72 (num -> INUM .)
    NEQ             reduce using rule 72 (num -> INUM .)
    GEQ             reduce using rule 72 (num -> INUM .)
    LEQ             reduce using rule 72 (num -> INUM .)
    GT              reduce using rule 72 (num -> INUM .)
    LT              reduce using rule 72 (num -> INUM .)
    AND             reduce using rule 72 (num -> INUM .)
    OR              reduce using rule 72 (num -> INUM .)


state 104

    (69) exp -> FALSE .

    COMMA           reduce using rule 69 (exp -> FALSE .)
    PLUS            reduce using rule 69 (exp -> FALSE .)
    TIMES           reduce using rule 69 (exp -> FALSE .)
    MINUS           reduce using rule 69 (exp -> FALSE .)
    BY              reduce using rule 69 (exp -> FALSE .)
    RPAR            reduce using rule 69 (exp -> FALSE .)
    NL              reduce using rule 69 (exp -> FALSE .)
    COLON           reduce using rule 69 (exp -> FALSE .)
    EQ              reduce using rule 69 (exp -> FALSE .)
    NEQ             reduce using rule 69 (exp -> FALSE .)
    GEQ             reduce using rule 69 (exp -> FALSE .)
    LEQ             reduce using rule 69 (exp -> FALSE .)
    GT              reduce using rule 69 (exp -> FALSE .)
    LT              reduce using rule 69 (exp -> FALSE .)
    AND             reduce using rule 69 (exp -> FALSE .)
    OR              reduce using rule 69 (exp -> FALSE .)


state 105

    (68) exp -> TRUE .

    COMMA           reduce using rule 68 (exp -> TRUE .)
    PLUS            reduce using rule 68 (exp -> TRUE .)
    TIMES           reduce using rule 68 (exp -> TRUE .)
    MINUS           reduce using rule 68 (exp -> TRUE .)
    BY              reduce using rule 68 (exp -> TRUE .)
    RPAR            reduce using rule 68 (exp -> TRUE .)
    NL              reduce using rule 68 (exp -> TRUE .)
    COLON           reduce using rule 68 (exp -> TRUE .)
    EQ              reduce using rule 68 (exp -> TRUE .)
    NEQ             reduce using rule 68 (exp -> TRUE .)
    GEQ             reduce using rule 68 (exp -> TRUE .)
    LEQ             reduce using rule 68 (exp -> TRUE .)
    GT              reduce using rule 68 (exp -> TRUE .)
    LT              reduce using rule 68 (exp -> TRUE .)
    AND             reduce using rule 68 (exp -> TRUE .)
    OR              reduce using rule 68 (exp -> TRUE .)


state 106

    (33) varnames -> varname .
    (34) varnames -> varname . COMMA varnames

    NL              reduce using rule 33 (varnames -> varname .)
    COMMA           shift and go to state 79


state 107

    (34) varnames -> varname COMMA varnames .

    NL              reduce using rule 34 (varnames -> varname COMMA varnames .)


state 108

    (20) mapdecl -> MAP LT type COMMA . type GT varname
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN

    INT             shift and go to state 47
    STRING          shift and go to state 43
    FLOAT           shift and go to state 48
    IPOS            shift and go to state 40
    BOOLEAN         shift and go to state 49

    type                           shift and go to state 131

state 109

    (6) actuatordecls -> ACTUATORS COLON NL . INDENT decls DEDENT
    (7) actuatordecls -> ACTUATORS COLON NL . INDENT pass DEDENT

    INDENT          shift and go to state 132


state 110

    (5) module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .

    USING           reduce using rule 5 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    ALLWRITE        reduce using rule 5 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)


state 111

    (8) sensordecls -> SENSORS COLON . NL INDENT decls DEDENT
    (9) sensordecls -> SENSORS COLON . NL INDENT pass DEDENT

    NL              shift and go to state 133


state 112

    (26) owner -> INUM .

    RBRACE          reduce using rule 26 (owner -> INUM .)


state 113

    (23) rvdecl -> type varname LBRACE owner . RBRACE NL
    (24) rvdecl -> type varname LBRACE owner . RBRACE ASGN num NL

    RBRACE          shift and go to state 134


state 114

    (25) owner -> TIMES .

    RBRACE          reduce using rule 25 (owner -> TIMES .)


state 115

    (59) modulefunccall -> CID LPAR . args RPAR
    (28) args -> . neargs
    (29) args -> . noargs
    (31) neargs -> . exp
    (32) neargs -> . exp COMMA neargs
    (30) noargs -> . empty
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (81) empty -> .
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    RPAR            reduce using rule 81 (empty -> .)
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    funccall                       shift and go to state 98
    varname                        shift and go to state 99
    args                           shift and go to state 135
    num                            shift and go to state 101
    exp                            shift and go to state 136
    noargs                         shift and go to state 137
    neargs                         shift and go to state 138
    empty                          shift and go to state 139

state 116

    (40) init -> INIT COLON NL INDENT stmts DEDENT .

    LID             reduce using rule 40 (init -> INIT COLON NL INDENT stmts DEDENT .)
    $end            reduce using rule 40 (init -> INIT COLON NL INDENT stmts DEDENT .)


state 117

    (55) stmt -> funccall NL .

    IF              reduce using rule 55 (stmt -> funccall NL .)
    CID             reduce using rule 55 (stmt -> funccall NL .)
    PASS            reduce using rule 55 (stmt -> funccall NL .)
    LID             reduce using rule 55 (stmt -> funccall NL .)
    DEDENT          reduce using rule 55 (stmt -> funccall NL .)


state 118

    (56) stmt -> modulefunccall NL .

    IF              reduce using rule 56 (stmt -> modulefunccall NL .)
    CID             reduce using rule 56 (stmt -> modulefunccall NL .)
    PASS            reduce using rule 56 (stmt -> modulefunccall NL .)
    LID             reduce using rule 56 (stmt -> modulefunccall NL .)
    DEDENT          reduce using rule 56 (stmt -> modulefunccall NL .)


state 119

    (52) stmts -> stmt stmts .

    DEDENT          reduce using rule 52 (stmts -> stmt stmts .)


state 120

    (47) cond -> LPAR . cond AND cond RPAR
    (48) cond -> LPAR . cond OR cond RPAR
    (49) cond -> LPAR . exp op exp RPAR
    (50) cond -> LPAR . NOT cond RPAR
    (47) cond -> . LPAR cond AND cond RPAR
    (48) cond -> . LPAR cond OR cond RPAR
    (49) cond -> . LPAR exp op exp RPAR
    (50) cond -> . LPAR NOT cond RPAR
    (51) cond -> . exp
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    NOT             shift and go to state 142
    LPAR            shift and go to state 120
    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    funccall                       shift and go to state 98
    varname                        shift and go to state 99
    num                            shift and go to state 101
    cond                           shift and go to state 140
    exp                            shift and go to state 141

state 121

    (57) stmt -> IF cond . COLON NL INDENT stmts DEDENT elseblock

    COLON           shift and go to state 143


state 122

    (51) cond -> exp .
    (63) exp -> exp . PLUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . MINUS exp
    (66) exp -> exp . BY exp

    NL              reduce using rule 51 (cond -> exp .)
    RPAR            reduce using rule 51 (cond -> exp .)
    COLON           reduce using rule 51 (cond -> exp .)
    PLUS            shift and go to state 128
    TIMES           shift and go to state 129
    MINUS           shift and go to state 130
    BY              shift and go to state 127


state 123

    (27) funccall -> varname LPAR . args RPAR
    (28) args -> . neargs
    (29) args -> . noargs
    (31) neargs -> . exp
    (32) neargs -> . exp COMMA neargs
    (30) noargs -> . empty
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (81) empty -> .
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    RPAR            reduce using rule 81 (empty -> .)
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    funccall                       shift and go to state 98
    varname                        shift and go to state 99
    args                           shift and go to state 144
    num                            shift and go to state 101
    exp                            shift and go to state 136
    noargs                         shift and go to state 137
    neargs                         shift and go to state 138
    empty                          shift and go to state 139

state 124

    (62) asgn -> varname ASGN . exp NL
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    varname                        shift and go to state 99
    num                            shift and go to state 101
    funccall                       shift and go to state 98
    exp                            shift and go to state 145

state 125

    (44) event -> LID COLON NL INDENT PRE . COLON cond NL effblock DEDENT

    COLON           shift and go to state 146


state 126

    (18) decl -> type varname ASGN exp NL .

    INT             reduce using rule 18 (decl -> type varname ASGN exp NL .)
    STRING          reduce using rule 18 (decl -> type varname ASGN exp NL .)
    FLOAT           reduce using rule 18 (decl -> type varname ASGN exp NL .)
    IPOS            reduce using rule 18 (decl -> type varname ASGN exp NL .)
    BOOLEAN         reduce using rule 18 (decl -> type varname ASGN exp NL .)
    MAP             reduce using rule 18 (decl -> type varname ASGN exp NL .)
    DEDENT          reduce using rule 18 (decl -> type varname ASGN exp NL .)


state 127

    (66) exp -> exp BY . exp
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    varname                        shift and go to state 99
    num                            shift and go to state 101
    funccall                       shift and go to state 98
    exp                            shift and go to state 147

state 128

    (63) exp -> exp PLUS . exp
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    varname                        shift and go to state 99
    num                            shift and go to state 101
    funccall                       shift and go to state 98
    exp                            shift and go to state 148

state 129

    (64) exp -> exp TIMES . exp
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    varname                        shift and go to state 99
    num                            shift and go to state 101
    funccall                       shift and go to state 98
    exp                            shift and go to state 149

state 130

    (65) exp -> exp MINUS . exp
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    varname                        shift and go to state 99
    num                            shift and go to state 101
    funccall                       shift and go to state 98
    exp                            shift and go to state 150

state 131

    (20) mapdecl -> MAP LT type COMMA type . GT varname

    GT              shift and go to state 151


state 132

    (6) actuatordecls -> ACTUATORS COLON NL INDENT . decls DEDENT
    (7) actuatordecls -> ACTUATORS COLON NL INDENT . pass DEDENT
    (15) decls -> . decl decls
    (16) decls -> . empty
    (61) pass -> . PASS NL
    (17) decl -> . type varnames NL
    (18) decl -> . type varname ASGN exp NL
    (19) decl -> . mapdecl NL
    (81) empty -> .
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN
    (20) mapdecl -> . MAP LT type COMMA type GT varname

    PASS            shift and go to state 44
    DEDENT          reduce using rule 81 (empty -> .)
    INT             shift and go to state 47
    STRING          shift and go to state 43
    FLOAT           shift and go to state 48
    IPOS            shift and go to state 40
    BOOLEAN         shift and go to state 49
    MAP             shift and go to state 46

    decl                           shift and go to state 37
    mapdecl                        shift and go to state 38
    pass                           shift and go to state 152
    decls                          shift and go to state 153
    type                           shift and go to state 41
    empty                          shift and go to state 42

state 133

    (8) sensordecls -> SENSORS COLON NL . INDENT decls DEDENT
    (9) sensordecls -> SENSORS COLON NL . INDENT pass DEDENT

    INDENT          shift and go to state 154


state 134

    (23) rvdecl -> type varname LBRACE owner RBRACE . NL
    (24) rvdecl -> type varname LBRACE owner RBRACE . ASGN num NL

    NL              shift and go to state 155
    ASGN            shift and go to state 156


state 135

    (59) modulefunccall -> CID LPAR args . RPAR

    RPAR            shift and go to state 157


state 136

    (31) neargs -> exp .
    (32) neargs -> exp . COMMA neargs
    (63) exp -> exp . PLUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . MINUS exp
    (66) exp -> exp . BY exp

    RPAR            reduce using rule 31 (neargs -> exp .)
    COMMA           shift and go to state 158
    PLUS            shift and go to state 128
    TIMES           shift and go to state 129
    MINUS           shift and go to state 130
    BY              shift and go to state 127


state 137

    (29) args -> noargs .

    RPAR            reduce using rule 29 (args -> noargs .)


state 138

    (28) args -> neargs .

    RPAR            reduce using rule 28 (args -> neargs .)


state 139

    (30) noargs -> empty .

    RPAR            reduce using rule 30 (noargs -> empty .)


state 140

    (47) cond -> LPAR cond . AND cond RPAR
    (48) cond -> LPAR cond . OR cond RPAR

    AND             shift and go to state 159
    OR              shift and go to state 160


state 141

    (49) cond -> LPAR exp . op exp RPAR
    (51) cond -> exp .
    (63) exp -> exp . PLUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . MINUS exp
    (66) exp -> exp . BY exp
    (75) op -> . EQ
    (76) op -> . NEQ
    (77) op -> . GEQ
    (78) op -> . LEQ
    (79) op -> . GT
    (80) op -> . LT

    AND             reduce using rule 51 (cond -> exp .)
    OR              reduce using rule 51 (cond -> exp .)
    PLUS            shift and go to state 128
    TIMES           shift and go to state 129
    MINUS           shift and go to state 130
    BY              shift and go to state 127
    EQ              shift and go to state 164
    NEQ             shift and go to state 161
    GEQ             shift and go to state 162
    LEQ             shift and go to state 165
    GT              shift and go to state 163
    LT              shift and go to state 166

    op                             shift and go to state 167

state 142

    (50) cond -> LPAR NOT . cond RPAR
    (47) cond -> . LPAR cond AND cond RPAR
    (48) cond -> . LPAR cond OR cond RPAR
    (49) cond -> . LPAR exp op exp RPAR
    (50) cond -> . LPAR NOT cond RPAR
    (51) cond -> . exp
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 120
    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    funccall                       shift and go to state 98
    varname                        shift and go to state 99
    num                            shift and go to state 101
    cond                           shift and go to state 168
    exp                            shift and go to state 122

state 143

    (57) stmt -> IF cond COLON . NL INDENT stmts DEDENT elseblock

    NL              shift and go to state 169


state 144

    (27) funccall -> varname LPAR args . RPAR

    RPAR            shift and go to state 170


state 145

    (62) asgn -> varname ASGN exp . NL
    (63) exp -> exp . PLUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . MINUS exp
    (66) exp -> exp . BY exp

    NL              shift and go to state 171
    PLUS            shift and go to state 128
    TIMES           shift and go to state 129
    MINUS           shift and go to state 130
    BY              shift and go to state 127


state 146

    (44) event -> LID COLON NL INDENT PRE COLON . cond NL effblock DEDENT
    (47) cond -> . LPAR cond AND cond RPAR
    (48) cond -> . LPAR cond OR cond RPAR
    (49) cond -> . LPAR exp op exp RPAR
    (50) cond -> . LPAR NOT cond RPAR
    (51) cond -> . exp
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 120
    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    funccall                       shift and go to state 98
    varname                        shift and go to state 99
    num                            shift and go to state 101
    cond                           shift and go to state 172
    exp                            shift and go to state 122

state 147

    (66) exp -> exp BY exp .
    (63) exp -> exp . PLUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . MINUS exp
    (66) exp -> exp . BY exp

    COMMA           reduce using rule 66 (exp -> exp BY exp .)
    PLUS            reduce using rule 66 (exp -> exp BY exp .)
    TIMES           reduce using rule 66 (exp -> exp BY exp .)
    MINUS           reduce using rule 66 (exp -> exp BY exp .)
    BY              reduce using rule 66 (exp -> exp BY exp .)
    RPAR            reduce using rule 66 (exp -> exp BY exp .)
    NL              reduce using rule 66 (exp -> exp BY exp .)
    COLON           reduce using rule 66 (exp -> exp BY exp .)
    EQ              reduce using rule 66 (exp -> exp BY exp .)
    NEQ             reduce using rule 66 (exp -> exp BY exp .)
    GEQ             reduce using rule 66 (exp -> exp BY exp .)
    LEQ             reduce using rule 66 (exp -> exp BY exp .)
    GT              reduce using rule 66 (exp -> exp BY exp .)
    LT              reduce using rule 66 (exp -> exp BY exp .)
    AND             reduce using rule 66 (exp -> exp BY exp .)
    OR              reduce using rule 66 (exp -> exp BY exp .)

  ! PLUS            [ shift and go to state 128 ]
  ! TIMES           [ shift and go to state 129 ]
  ! MINUS           [ shift and go to state 130 ]
  ! BY              [ shift and go to state 127 ]


state 148

    (63) exp -> exp PLUS exp .
    (63) exp -> exp . PLUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . MINUS exp
    (66) exp -> exp . BY exp

    COMMA           reduce using rule 63 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 63 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 63 (exp -> exp PLUS exp .)
    RPAR            reduce using rule 63 (exp -> exp PLUS exp .)
    NL              reduce using rule 63 (exp -> exp PLUS exp .)
    COLON           reduce using rule 63 (exp -> exp PLUS exp .)
    EQ              reduce using rule 63 (exp -> exp PLUS exp .)
    NEQ             reduce using rule 63 (exp -> exp PLUS exp .)
    GEQ             reduce using rule 63 (exp -> exp PLUS exp .)
    LEQ             reduce using rule 63 (exp -> exp PLUS exp .)
    GT              reduce using rule 63 (exp -> exp PLUS exp .)
    LT              reduce using rule 63 (exp -> exp PLUS exp .)
    AND             reduce using rule 63 (exp -> exp PLUS exp .)
    OR              reduce using rule 63 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 129
    BY              shift and go to state 127

  ! TIMES           [ reduce using rule 63 (exp -> exp PLUS exp .) ]
  ! BY              [ reduce using rule 63 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 128 ]
  ! MINUS           [ shift and go to state 130 ]


state 149

    (64) exp -> exp TIMES exp .
    (63) exp -> exp . PLUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . MINUS exp
    (66) exp -> exp . BY exp

    COMMA           reduce using rule 64 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 64 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 64 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 64 (exp -> exp TIMES exp .)
    BY              reduce using rule 64 (exp -> exp TIMES exp .)
    RPAR            reduce using rule 64 (exp -> exp TIMES exp .)
    NL              reduce using rule 64 (exp -> exp TIMES exp .)
    COLON           reduce using rule 64 (exp -> exp TIMES exp .)
    EQ              reduce using rule 64 (exp -> exp TIMES exp .)
    NEQ             reduce using rule 64 (exp -> exp TIMES exp .)
    GEQ             reduce using rule 64 (exp -> exp TIMES exp .)
    LEQ             reduce using rule 64 (exp -> exp TIMES exp .)
    GT              reduce using rule 64 (exp -> exp TIMES exp .)
    LT              reduce using rule 64 (exp -> exp TIMES exp .)
    AND             reduce using rule 64 (exp -> exp TIMES exp .)
    OR              reduce using rule 64 (exp -> exp TIMES exp .)

  ! PLUS            [ shift and go to state 128 ]
  ! TIMES           [ shift and go to state 129 ]
  ! MINUS           [ shift and go to state 130 ]
  ! BY              [ shift and go to state 127 ]


state 150

    (65) exp -> exp MINUS exp .
    (63) exp -> exp . PLUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . MINUS exp
    (66) exp -> exp . BY exp

    COMMA           reduce using rule 65 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 65 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 65 (exp -> exp MINUS exp .)
    RPAR            reduce using rule 65 (exp -> exp MINUS exp .)
    NL              reduce using rule 65 (exp -> exp MINUS exp .)
    COLON           reduce using rule 65 (exp -> exp MINUS exp .)
    EQ              reduce using rule 65 (exp -> exp MINUS exp .)
    NEQ             reduce using rule 65 (exp -> exp MINUS exp .)
    GEQ             reduce using rule 65 (exp -> exp MINUS exp .)
    LEQ             reduce using rule 65 (exp -> exp MINUS exp .)
    GT              reduce using rule 65 (exp -> exp MINUS exp .)
    LT              reduce using rule 65 (exp -> exp MINUS exp .)
    AND             reduce using rule 65 (exp -> exp MINUS exp .)
    OR              reduce using rule 65 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 129
    BY              shift and go to state 127

  ! TIMES           [ reduce using rule 65 (exp -> exp MINUS exp .) ]
  ! BY              [ reduce using rule 65 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 128 ]
  ! MINUS           [ shift and go to state 130 ]


state 151

    (20) mapdecl -> MAP LT type COMMA type GT . varname
    (74) varname -> . LID

    LID             shift and go to state 63

    varname                        shift and go to state 173

state 152

    (7) actuatordecls -> ACTUATORS COLON NL INDENT pass . DEDENT

    DEDENT          shift and go to state 174


state 153

    (6) actuatordecls -> ACTUATORS COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 175


state 154

    (8) sensordecls -> SENSORS COLON NL INDENT . decls DEDENT
    (9) sensordecls -> SENSORS COLON NL INDENT . pass DEDENT
    (15) decls -> . decl decls
    (16) decls -> . empty
    (61) pass -> . PASS NL
    (17) decl -> . type varnames NL
    (18) decl -> . type varname ASGN exp NL
    (19) decl -> . mapdecl NL
    (81) empty -> .
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN
    (20) mapdecl -> . MAP LT type COMMA type GT varname

    PASS            shift and go to state 44
    DEDENT          reduce using rule 81 (empty -> .)
    INT             shift and go to state 47
    STRING          shift and go to state 43
    FLOAT           shift and go to state 48
    IPOS            shift and go to state 40
    BOOLEAN         shift and go to state 49
    MAP             shift and go to state 46

    decl                           shift and go to state 37
    mapdecl                        shift and go to state 38
    pass                           shift and go to state 176
    decls                          shift and go to state 177
    type                           shift and go to state 41
    empty                          shift and go to state 42

state 155

    (23) rvdecl -> type varname LBRACE owner RBRACE NL .

    INT             reduce using rule 23 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    STRING          reduce using rule 23 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    FLOAT           reduce using rule 23 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    IPOS            reduce using rule 23 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    BOOLEAN         reduce using rule 23 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    DEDENT          reduce using rule 23 (rvdecl -> type varname LBRACE owner RBRACE NL .)


state 156

    (24) rvdecl -> type varname LBRACE owner RBRACE ASGN . num NL
    (72) num -> . INUM
    (73) num -> . FNUM

    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    num                            shift and go to state 178

state 157

    (59) modulefunccall -> CID LPAR args RPAR .

    NL              reduce using rule 59 (modulefunccall -> CID LPAR args RPAR .)


state 158

    (32) neargs -> exp COMMA . neargs
    (31) neargs -> . exp
    (32) neargs -> . exp COMMA neargs
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    funccall                       shift and go to state 98
    varname                        shift and go to state 99
    num                            shift and go to state 101
    exp                            shift and go to state 136
    neargs                         shift and go to state 179

state 159

    (47) cond -> LPAR cond AND . cond RPAR
    (47) cond -> . LPAR cond AND cond RPAR
    (48) cond -> . LPAR cond OR cond RPAR
    (49) cond -> . LPAR exp op exp RPAR
    (50) cond -> . LPAR NOT cond RPAR
    (51) cond -> . exp
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 120
    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    funccall                       shift and go to state 98
    varname                        shift and go to state 99
    num                            shift and go to state 101
    cond                           shift and go to state 180
    exp                            shift and go to state 122

state 160

    (48) cond -> LPAR cond OR . cond RPAR
    (47) cond -> . LPAR cond AND cond RPAR
    (48) cond -> . LPAR cond OR cond RPAR
    (49) cond -> . LPAR exp op exp RPAR
    (50) cond -> . LPAR NOT cond RPAR
    (51) cond -> . exp
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 120
    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    funccall                       shift and go to state 98
    varname                        shift and go to state 99
    num                            shift and go to state 101
    cond                           shift and go to state 181
    exp                            shift and go to state 122

state 161

    (76) op -> NEQ .

    TRUE            reduce using rule 76 (op -> NEQ .)
    FALSE           reduce using rule 76 (op -> NEQ .)
    LID             reduce using rule 76 (op -> NEQ .)
    INUM            reduce using rule 76 (op -> NEQ .)
    FNUM            reduce using rule 76 (op -> NEQ .)


state 162

    (77) op -> GEQ .

    TRUE            reduce using rule 77 (op -> GEQ .)
    FALSE           reduce using rule 77 (op -> GEQ .)
    LID             reduce using rule 77 (op -> GEQ .)
    INUM            reduce using rule 77 (op -> GEQ .)
    FNUM            reduce using rule 77 (op -> GEQ .)


state 163

    (79) op -> GT .

    TRUE            reduce using rule 79 (op -> GT .)
    FALSE           reduce using rule 79 (op -> GT .)
    LID             reduce using rule 79 (op -> GT .)
    INUM            reduce using rule 79 (op -> GT .)
    FNUM            reduce using rule 79 (op -> GT .)


state 164

    (75) op -> EQ .

    TRUE            reduce using rule 75 (op -> EQ .)
    FALSE           reduce using rule 75 (op -> EQ .)
    LID             reduce using rule 75 (op -> EQ .)
    INUM            reduce using rule 75 (op -> EQ .)
    FNUM            reduce using rule 75 (op -> EQ .)


state 165

    (78) op -> LEQ .

    TRUE            reduce using rule 78 (op -> LEQ .)
    FALSE           reduce using rule 78 (op -> LEQ .)
    LID             reduce using rule 78 (op -> LEQ .)
    INUM            reduce using rule 78 (op -> LEQ .)
    FNUM            reduce using rule 78 (op -> LEQ .)


state 166

    (80) op -> LT .

    TRUE            reduce using rule 80 (op -> LT .)
    FALSE           reduce using rule 80 (op -> LT .)
    LID             reduce using rule 80 (op -> LT .)
    INUM            reduce using rule 80 (op -> LT .)
    FNUM            reduce using rule 80 (op -> LT .)


state 167

    (49) cond -> LPAR exp op . exp RPAR
    (63) exp -> . exp PLUS exp
    (64) exp -> . exp TIMES exp
    (65) exp -> . exp MINUS exp
    (66) exp -> . exp BY exp
    (67) exp -> . varname
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . num
    (71) exp -> . funccall
    (74) varname -> . LID
    (72) num -> . INUM
    (73) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    TRUE            shift and go to state 105
    FALSE           shift and go to state 104
    LID             shift and go to state 63
    INUM            shift and go to state 103
    FNUM            shift and go to state 100

    funccall                       shift and go to state 98
    varname                        shift and go to state 99
    num                            shift and go to state 101
    exp                            shift and go to state 182

state 168

    (50) cond -> LPAR NOT cond . RPAR

    RPAR            shift and go to state 183


state 169

    (57) stmt -> IF cond COLON NL . INDENT stmts DEDENT elseblock

    INDENT          shift and go to state 184


state 170

    (27) funccall -> varname LPAR args RPAR .

    PLUS            reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    TIMES           reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    MINUS           reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    BY              reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    NL              reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    COLON           reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    COMMA           reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    RPAR            reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    EQ              reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    NEQ             reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    GEQ             reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    LEQ             reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    GT              reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    LT              reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    AND             reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    OR              reduce using rule 27 (funccall -> varname LPAR args RPAR .)


state 171

    (62) asgn -> varname ASGN exp NL .

    IF              reduce using rule 62 (asgn -> varname ASGN exp NL .)
    CID             reduce using rule 62 (asgn -> varname ASGN exp NL .)
    PASS            reduce using rule 62 (asgn -> varname ASGN exp NL .)
    LID             reduce using rule 62 (asgn -> varname ASGN exp NL .)
    DEDENT          reduce using rule 62 (asgn -> varname ASGN exp NL .)


state 172

    (44) event -> LID COLON NL INDENT PRE COLON cond . NL effblock DEDENT

    NL              shift and go to state 185


state 173

    (20) mapdecl -> MAP LT type COMMA type GT varname .

    NL              reduce using rule 20 (mapdecl -> MAP LT type COMMA type GT varname .)


state 174

    (7) actuatordecls -> ACTUATORS COLON NL INDENT pass DEDENT .

    SENSORS         reduce using rule 7 (actuatordecls -> ACTUATORS COLON NL INDENT pass DEDENT .)


state 175

    (6) actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT .

    SENSORS         reduce using rule 6 (actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT .)


state 176

    (9) sensordecls -> SENSORS COLON NL INDENT pass . DEDENT

    DEDENT          shift and go to state 186


state 177

    (8) sensordecls -> SENSORS COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 187


state 178

    (24) rvdecl -> type varname LBRACE owner RBRACE ASGN num . NL

    NL              shift and go to state 188


state 179

    (32) neargs -> exp COMMA neargs .

    RPAR            reduce using rule 32 (neargs -> exp COMMA neargs .)


state 180

    (47) cond -> LPAR cond AND cond . RPAR

    RPAR            shift and go to state 189


state 181

    (48) cond -> LPAR cond OR cond . RPAR

    RPAR            shift and go to state 190


state 182

    (49) cond -> LPAR exp op exp . RPAR
    (63) exp -> exp . PLUS exp
    (64) exp -> exp . TIMES exp
    (65) exp -> exp . MINUS exp
    (66) exp -> exp . BY exp

    RPAR            shift and go to state 191
    PLUS            shift and go to state 128
    TIMES           shift and go to state 129
    MINUS           shift and go to state 130
    BY              shift and go to state 127


state 183

    (50) cond -> LPAR NOT cond RPAR .

    NL              reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    AND             reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    OR              reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    RPAR            reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    COLON           reduce using rule 50 (cond -> LPAR NOT cond RPAR .)


state 184

    (57) stmt -> IF cond COLON NL INDENT . stmts DEDENT elseblock
    (52) stmts -> . stmt stmts
    (53) stmts -> . empty
    (54) stmt -> . asgn
    (55) stmt -> . funccall NL
    (56) stmt -> . modulefunccall NL
    (57) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (58) stmt -> . pass
    (81) empty -> .
    (62) asgn -> . varname ASGN exp NL
    (27) funccall -> . varname LPAR args RPAR
    (59) modulefunccall -> . CID LPAR args RPAR
    (61) pass -> . PASS NL
    (74) varname -> . LID

    IF              shift and go to state 94
    DEDENT          reduce using rule 81 (empty -> .)
    CID             shift and go to state 86
    PASS            shift and go to state 44
    LID             shift and go to state 63

    funccall                       shift and go to state 91
    stmts                          shift and go to state 192
    varname                        shift and go to state 95
    stmt                           shift and go to state 93
    asgn                           shift and go to state 89
    modulefunccall                 shift and go to state 92
    pass                           shift and go to state 87
    empty                          shift and go to state 90

state 185

    (44) event -> LID COLON NL INDENT PRE COLON cond NL . effblock DEDENT
    (45) effblock -> . EFF COLON NL INDENT stmts DEDENT
    (46) effblock -> . EFF COLON stmt

    EFF             shift and go to state 194

    effblock                       shift and go to state 193

state 186

    (9) sensordecls -> SENSORS COLON NL INDENT pass DEDENT .

    DEDENT          reduce using rule 9 (sensordecls -> SENSORS COLON NL INDENT pass DEDENT .)


state 187

    (8) sensordecls -> SENSORS COLON NL INDENT decls DEDENT .

    DEDENT          reduce using rule 8 (sensordecls -> SENSORS COLON NL INDENT decls DEDENT .)


state 188

    (24) rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .

    INT             reduce using rule 24 (rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .)
    STRING          reduce using rule 24 (rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .)
    FLOAT           reduce using rule 24 (rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .)
    IPOS            reduce using rule 24 (rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .)
    BOOLEAN         reduce using rule 24 (rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .)
    DEDENT          reduce using rule 24 (rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .)


state 189

    (47) cond -> LPAR cond AND cond RPAR .

    NL              reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    AND             reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    OR              reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    RPAR            reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    COLON           reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)


state 190

    (48) cond -> LPAR cond OR cond RPAR .

    NL              reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    AND             reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    OR              reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    RPAR            reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    COLON           reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)


state 191

    (49) cond -> LPAR exp op exp RPAR .

    NL              reduce using rule 49 (cond -> LPAR exp op exp RPAR .)
    AND             reduce using rule 49 (cond -> LPAR exp op exp RPAR .)
    OR              reduce using rule 49 (cond -> LPAR exp op exp RPAR .)
    RPAR            reduce using rule 49 (cond -> LPAR exp op exp RPAR .)
    COLON           reduce using rule 49 (cond -> LPAR exp op exp RPAR .)


state 192

    (57) stmt -> IF cond COLON NL INDENT stmts . DEDENT elseblock

    DEDENT          shift and go to state 195


state 193

    (44) event -> LID COLON NL INDENT PRE COLON cond NL effblock . DEDENT

    DEDENT          shift and go to state 196


state 194

    (45) effblock -> EFF . COLON NL INDENT stmts DEDENT
    (46) effblock -> EFF . COLON stmt

    COLON           shift and go to state 197


state 195

    (57) stmt -> IF cond COLON NL INDENT stmts DEDENT . elseblock
    (60) elseblock -> . ELSE COLON NL INDENT stmts DEDENT

    ELSE            shift and go to state 199

    elseblock                      shift and go to state 198

state 196

    (44) event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .

    LID             reduce using rule 44 (event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .)
    $end            reduce using rule 44 (event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .)


state 197

    (45) effblock -> EFF COLON . NL INDENT stmts DEDENT
    (46) effblock -> EFF COLON . stmt
    (54) stmt -> . asgn
    (55) stmt -> . funccall NL
    (56) stmt -> . modulefunccall NL
    (57) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (58) stmt -> . pass
    (62) asgn -> . varname ASGN exp NL
    (27) funccall -> . varname LPAR args RPAR
    (59) modulefunccall -> . CID LPAR args RPAR
    (61) pass -> . PASS NL
    (74) varname -> . LID

    NL              shift and go to state 200
    IF              shift and go to state 94
    CID             shift and go to state 86
    PASS            shift and go to state 44
    LID             shift and go to state 63

    funccall                       shift and go to state 91
    varname                        shift and go to state 95
    stmt                           shift and go to state 201
    asgn                           shift and go to state 89
    modulefunccall                 shift and go to state 92
    pass                           shift and go to state 87

state 198

    (57) stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .

    IF              reduce using rule 57 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    CID             reduce using rule 57 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    PASS            reduce using rule 57 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    LID             reduce using rule 57 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    DEDENT          reduce using rule 57 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)


state 199

    (60) elseblock -> ELSE . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 202


state 200

    (45) effblock -> EFF COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 203


state 201

    (46) effblock -> EFF COLON stmt .

    DEDENT          reduce using rule 46 (effblock -> EFF COLON stmt .)


state 202

    (60) elseblock -> ELSE COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 204


state 203

    (45) effblock -> EFF COLON NL INDENT . stmts DEDENT
    (52) stmts -> . stmt stmts
    (53) stmts -> . empty
    (54) stmt -> . asgn
    (55) stmt -> . funccall NL
    (56) stmt -> . modulefunccall NL
    (57) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (58) stmt -> . pass
    (81) empty -> .
    (62) asgn -> . varname ASGN exp NL
    (27) funccall -> . varname LPAR args RPAR
    (59) modulefunccall -> . CID LPAR args RPAR
    (61) pass -> . PASS NL
    (74) varname -> . LID

    IF              shift and go to state 94
    DEDENT          reduce using rule 81 (empty -> .)
    CID             shift and go to state 86
    PASS            shift and go to state 44
    LID             shift and go to state 63

    funccall                       shift and go to state 91
    stmts                          shift and go to state 205
    varname                        shift and go to state 95
    stmt                           shift and go to state 93
    asgn                           shift and go to state 89
    modulefunccall                 shift and go to state 92
    pass                           shift and go to state 87
    empty                          shift and go to state 90

state 204

    (60) elseblock -> ELSE COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 206


state 205

    (45) effblock -> EFF COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 207


state 206

    (60) elseblock -> ELSE COLON NL INDENT . stmts DEDENT
    (52) stmts -> . stmt stmts
    (53) stmts -> . empty
    (54) stmt -> . asgn
    (55) stmt -> . funccall NL
    (56) stmt -> . modulefunccall NL
    (57) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (58) stmt -> . pass
    (81) empty -> .
    (62) asgn -> . varname ASGN exp NL
    (27) funccall -> . varname LPAR args RPAR
    (59) modulefunccall -> . CID LPAR args RPAR
    (61) pass -> . PASS NL
    (74) varname -> . LID

    IF              shift and go to state 94
    DEDENT          reduce using rule 81 (empty -> .)
    CID             shift and go to state 86
    PASS            shift and go to state 44
    LID             shift and go to state 63

    funccall                       shift and go to state 91
    stmts                          shift and go to state 208
    varname                        shift and go to state 95
    stmt                           shift and go to state 93
    asgn                           shift and go to state 89
    modulefunccall                 shift and go to state 92
    pass                           shift and go to state 87
    empty                          shift and go to state 90

state 207

    (45) effblock -> EFF COLON NL INDENT stmts DEDENT .

    DEDENT          reduce using rule 45 (effblock -> EFF COLON NL INDENT stmts DEDENT .)


state 208

    (60) elseblock -> ELSE COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 209


state 209

    (60) elseblock -> ELSE COLON NL INDENT stmts DEDENT .

    IF              reduce using rule 60 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    CID             reduce using rule 60 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    PASS            reduce using rule 60 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    LID             reduce using rule 60 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    DEDENT          reduce using rule 60 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)

