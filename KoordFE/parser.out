Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Unused terminals:

    WS
    PASS
    MAP

Grammar

Rule 0     S' -> program
Rule 1     program -> agent modules awdecls ardecls locdecls stagedecl init events Numdecl
Rule 2     Numdecl -> NUM INUM NL
Rule 3     stagedecl -> DEF STAGE LCURLY stagelist RCURLY NL
Rule 4     stagedecl -> empty
Rule 5     stagelist -> LID COMMA stagelist
Rule 6     stagelist -> LID
Rule 7     agent -> AGENT CID NL
Rule 8     modules -> module modules
Rule 9     modules -> empty
Rule 10    module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT
Rule 11    actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT
Rule 12    actuatordecls -> empty
Rule 13    sensordecls -> SENSORS COLON NL INDENT decls DEDENT
Rule 14    sensordecls -> empty
Rule 15    awdecls -> ALLWRITE COLON NL INDENT decls DEDENT
Rule 16    awdecls -> empty
Rule 17    ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT
Rule 18    ardecls -> empty
Rule 19    locdecls -> LOCAL COLON NL INDENT decls DEDENT
Rule 20    locdecls -> empty
Rule 21    decls -> decl decls
Rule 22    decls -> empty
Rule 23    decl -> type varname ASGN exp NL
Rule 24    decl -> type varname NL
Rule 25    rvdecls -> rvdecl rvdecls
Rule 26    rvdecls -> empty
Rule 27    rvdecl -> type varname LBRACE owner RBRACE NL
Rule 28    owner -> TIMES
Rule 29    owner -> INUM
Rule 30    funccall -> varname LPAR args RPAR
Rule 31    args -> neargs
Rule 32    args -> noargs
Rule 33    noargs -> empty
Rule 34    neargs -> exp
Rule 35    neargs -> exp COMMA neargs
Rule 36    type -> INT
Rule 37    type -> STRING
Rule 38    type -> FLOAT
Rule 39    type -> IPOS
Rule 40    type -> BOOLEAN
Rule 41    type -> INPUTMAP
Rule 42    init -> INIT COLON NL INDENT stmts DEDENT
Rule 43    init -> empty
Rule 44    events -> event events
Rule 45    events -> event
Rule 46    event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT
Rule 47    effblock -> EFF COLON NL INDENT stmts DEDENT
Rule 48    effblock -> EFF COLON stmt
Rule 49    cond -> LPAR cond AND cond RPAR
Rule 50    cond -> LPAR cond OR cond RPAR
Rule 51    cond -> LPAR cond op cond RPAR
Rule 52    cond -> LPAR NOT cond RPAR
Rule 53    cond -> exp
Rule 54    stmts -> stmt stmts
Rule 55    stmts -> stmt
Rule 56    stmt -> asgn
Rule 57    stmt -> wptstmt
Rule 58    stmt -> exit
Rule 59    stmt -> funccall NL
Rule 60    stmt -> modulefunccall NL
Rule 61    stmt -> ATOMIC COLON NL INDENT stmts DEDENT
Rule 62    stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock
Rule 63    exit -> EXIT NL
Rule 64    modulefunccall -> CID LPAR args RPAR
Rule 65    elseblock -> ELSE COLON NL INDENT stmts DEDENT
Rule 66    elseblock -> empty
Rule 67    asgn -> varname ASGN exp NL
Rule 68    asgn -> stagechange
Rule 69    moduleflag -> CID
Rule 70    stagechange -> STAGE ASGN varname NL
Rule 71    wptstmt -> varname ASGN GETINPUT LPAR RPAR NL
Rule 72    exp -> bracketexp
Rule 73    exp -> exp PLUS exp
Rule 74    exp -> exp TIMES exp
Rule 75    exp -> exp MINUS exp
Rule 76    exp -> exp BY exp
Rule 77    exp -> varname
Rule 78    exp -> STAGE
Rule 79    exp -> bval
Rule 80    exp -> pid
Rule 81    exp -> LID LBRACE exp RBRACE
Rule 82    exp -> num
Rule 83    exp -> null
Rule 84    exp -> funccall
Rule 85    exp -> modulefunccall
Rule 86    bracketexp -> LPAR exp RPAR
Rule 87    bval -> TRUE
Rule 88    bval -> FALSE
Rule 89    num -> INUM
Rule 90    num -> FNUM
Rule 91    pid -> PID
Rule 92    varname -> LID
Rule 93    null -> NULL
Rule 94    op -> EQ
Rule 95    op -> NEQ
Rule 96    op -> GEQ
Rule 97    op -> LEQ
Rule 98    op -> GT
Rule 99    op -> LT
Rule 100   empty -> <empty>

Terminals, with rules where they appear

ACTUATORS            : 11
AGENT                : 7
ALLREAD              : 17
ALLWRITE             : 15
AND                  : 49
ASGN                 : 23 67 70 71
ATOMIC               : 61
BOOLEAN              : 40
BY                   : 76
CID                  : 7 10 64 69
COLON                : 10 11 13 15 17 19 42 46 46 47 48 61 62 65
COMMA                : 5 35
DEDENT               : 10 11 13 15 17 19 42 46 47 61 62 65
DEF                  : 3
EFF                  : 47 48
ELSE                 : 65
EQ                   : 94
EXIT                 : 63
FALSE                : 88
FLOAT                : 38
FNUM                 : 90
GEQ                  : 96
GETINPUT             : 71
GT                   : 98
IF                   : 62
INDENT               : 10 11 13 15 17 19 42 46 47 61 62 65
INIT                 : 42
INPUTMAP             : 41
INT                  : 36
INUM                 : 2 29 89
IPOS                 : 39
LBRACE               : 27 81
LCURLY               : 3
LEQ                  : 97
LID                  : 5 6 46 81 92
LOCAL                : 19
LPAR                 : 30 49 50 51 52 64 71 86
LT                   : 99
MAP                  : 
MINUS                : 75
MODULE               : 10
NEQ                  : 95
NL                   : 2 3 7 10 11 13 15 17 19 23 24 27 42 46 46 47 59 60 61 62 63 65 67 70 71
NOT                  : 52
NULL                 : 93
NUM                  : 2
OR                   : 50
PASS                 : 
PID                  : 91
PLUS                 : 73
PRE                  : 46
RBRACE               : 27 81
RCURLY               : 3
RPAR                 : 30 49 50 51 52 64 71 86
SENSORS              : 13
STAGE                : 3 70 78
STRING               : 37
TIMES                : 28 74
TRUE                 : 87
USING                : 10
WS                   : 
error                : 

Nonterminals, with rules where they appear

Numdecl              : 1
actuatordecls        : 10
agent                : 1
ardecls              : 1
args                 : 30 64
asgn                 : 56
awdecls              : 1
bracketexp           : 72
bval                 : 79
cond                 : 46 49 49 50 50 51 51 52 62
decl                 : 21
decls                : 11 13 15 19 21
effblock             : 46
elseblock            : 62
empty                : 4 9 12 14 16 18 20 22 26 33 43 66
event                : 44 45
events               : 1 44
exit                 : 58
exp                  : 23 34 35 53 67 73 73 74 74 75 75 76 76 81 86
funccall             : 59 84
init                 : 1
locdecls             : 1
module               : 8
moduleflag           : 
modulefunccall       : 60 85
modules              : 1 8
neargs               : 31 35
noargs               : 32
null                 : 83
num                  : 82
op                   : 51
owner                : 27
pid                  : 80
program              : 0
rvdecl               : 25
rvdecls              : 17 25
sensordecls          : 10
stagechange          : 68
stagedecl            : 1
stagelist            : 3 5
stmt                 : 48 54 55
stmts                : 42 47 54 61 62 65
type                 : 23 24 27
varname              : 23 24 27 30 67 70 71 77
wptstmt              : 57

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . agent modules awdecls ardecls locdecls stagedecl init events Numdecl
    (7) agent -> . AGENT CID NL

    AGENT           shift and go to state 1

    agent                          shift and go to state 2
    program                        shift and go to state 3

state 1

    (7) agent -> AGENT . CID NL

    CID             shift and go to state 4


state 2

    (1) program -> agent . modules awdecls ardecls locdecls stagedecl init events Numdecl
    (8) modules -> . module modules
    (9) modules -> . empty
    (10) module -> . USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT
    (100) empty -> .

    USING           shift and go to state 7
    ALLWRITE        reduce using rule 100 (empty -> .)
    ALLREAD         reduce using rule 100 (empty -> .)
    LOCAL           reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    INIT            reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)

    module                         shift and go to state 5
    modules                        shift and go to state 6
    empty                          shift and go to state 8

state 3

    (0) S' -> program .



state 4

    (7) agent -> AGENT CID . NL

    NL              shift and go to state 9


state 5

    (8) modules -> module . modules
    (8) modules -> . module modules
    (9) modules -> . empty
    (10) module -> . USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT
    (100) empty -> .

    USING           shift and go to state 7
    ALLWRITE        reduce using rule 100 (empty -> .)
    ALLREAD         reduce using rule 100 (empty -> .)
    LOCAL           reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    INIT            reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)

    modules                        shift and go to state 10
    empty                          shift and go to state 8
    module                         shift and go to state 5

state 6

    (1) program -> agent modules . awdecls ardecls locdecls stagedecl init events Numdecl
    (15) awdecls -> . ALLWRITE COLON NL INDENT decls DEDENT
    (16) awdecls -> . empty
    (100) empty -> .

    ALLWRITE        shift and go to state 12
    ALLREAD         reduce using rule 100 (empty -> .)
    LOCAL           reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    INIT            reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)

    awdecls                        shift and go to state 11
    empty                          shift and go to state 13

state 7

    (10) module -> USING . MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT

    MODULE          shift and go to state 14


state 8

    (9) modules -> empty .

    ALLWRITE        reduce using rule 9 (modules -> empty .)
    ALLREAD         reduce using rule 9 (modules -> empty .)
    LOCAL           reduce using rule 9 (modules -> empty .)
    DEF             reduce using rule 9 (modules -> empty .)
    INIT            reduce using rule 9 (modules -> empty .)
    LID             reduce using rule 9 (modules -> empty .)


state 9

    (7) agent -> AGENT CID NL .

    USING           reduce using rule 7 (agent -> AGENT CID NL .)
    ALLWRITE        reduce using rule 7 (agent -> AGENT CID NL .)
    ALLREAD         reduce using rule 7 (agent -> AGENT CID NL .)
    LOCAL           reduce using rule 7 (agent -> AGENT CID NL .)
    DEF             reduce using rule 7 (agent -> AGENT CID NL .)
    INIT            reduce using rule 7 (agent -> AGENT CID NL .)
    LID             reduce using rule 7 (agent -> AGENT CID NL .)


state 10

    (8) modules -> module modules .

    ALLWRITE        reduce using rule 8 (modules -> module modules .)
    ALLREAD         reduce using rule 8 (modules -> module modules .)
    LOCAL           reduce using rule 8 (modules -> module modules .)
    DEF             reduce using rule 8 (modules -> module modules .)
    INIT            reduce using rule 8 (modules -> module modules .)
    LID             reduce using rule 8 (modules -> module modules .)


state 11

    (1) program -> agent modules awdecls . ardecls locdecls stagedecl init events Numdecl
    (17) ardecls -> . ALLREAD COLON NL INDENT rvdecls DEDENT
    (18) ardecls -> . empty
    (100) empty -> .

    ALLREAD         shift and go to state 15
    LOCAL           reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    INIT            reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)

    ardecls                        shift and go to state 16
    empty                          shift and go to state 17

state 12

    (15) awdecls -> ALLWRITE . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 18


state 13

    (16) awdecls -> empty .

    ALLREAD         reduce using rule 16 (awdecls -> empty .)
    LOCAL           reduce using rule 16 (awdecls -> empty .)
    DEF             reduce using rule 16 (awdecls -> empty .)
    INIT            reduce using rule 16 (awdecls -> empty .)
    LID             reduce using rule 16 (awdecls -> empty .)


state 14

    (10) module -> USING MODULE . CID COLON NL INDENT actuatordecls sensordecls DEDENT

    CID             shift and go to state 19


state 15

    (17) ardecls -> ALLREAD . COLON NL INDENT rvdecls DEDENT

    COLON           shift and go to state 20


state 16

    (1) program -> agent modules awdecls ardecls . locdecls stagedecl init events Numdecl
    (19) locdecls -> . LOCAL COLON NL INDENT decls DEDENT
    (20) locdecls -> . empty
    (100) empty -> .

    LOCAL           shift and go to state 22
    DEF             reduce using rule 100 (empty -> .)
    INIT            reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)

    locdecls                       shift and go to state 21
    empty                          shift and go to state 23

state 17

    (18) ardecls -> empty .

    LOCAL           reduce using rule 18 (ardecls -> empty .)
    DEF             reduce using rule 18 (ardecls -> empty .)
    INIT            reduce using rule 18 (ardecls -> empty .)
    LID             reduce using rule 18 (ardecls -> empty .)


state 18

    (15) awdecls -> ALLWRITE COLON . NL INDENT decls DEDENT

    NL              shift and go to state 24


state 19

    (10) module -> USING MODULE CID . COLON NL INDENT actuatordecls sensordecls DEDENT

    COLON           shift and go to state 25


state 20

    (17) ardecls -> ALLREAD COLON . NL INDENT rvdecls DEDENT

    NL              shift and go to state 26


state 21

    (1) program -> agent modules awdecls ardecls locdecls . stagedecl init events Numdecl
    (3) stagedecl -> . DEF STAGE LCURLY stagelist RCURLY NL
    (4) stagedecl -> . empty
    (100) empty -> .

    DEF             shift and go to state 29
    INIT            reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)

    stagedecl                      shift and go to state 28
    empty                          shift and go to state 27

state 22

    (19) locdecls -> LOCAL . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 30


state 23

    (20) locdecls -> empty .

    DEF             reduce using rule 20 (locdecls -> empty .)
    INIT            reduce using rule 20 (locdecls -> empty .)
    LID             reduce using rule 20 (locdecls -> empty .)


state 24

    (15) awdecls -> ALLWRITE COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 31


state 25

    (10) module -> USING MODULE CID COLON . NL INDENT actuatordecls sensordecls DEDENT

    NL              shift and go to state 32


state 26

    (17) ardecls -> ALLREAD COLON NL . INDENT rvdecls DEDENT

    INDENT          shift and go to state 33


state 27

    (4) stagedecl -> empty .

    INIT            reduce using rule 4 (stagedecl -> empty .)
    LID             reduce using rule 4 (stagedecl -> empty .)


state 28

    (1) program -> agent modules awdecls ardecls locdecls stagedecl . init events Numdecl
    (42) init -> . INIT COLON NL INDENT stmts DEDENT
    (43) init -> . empty
    (100) empty -> .

    INIT            shift and go to state 34
    LID             reduce using rule 100 (empty -> .)

    init                           shift and go to state 35
    empty                          shift and go to state 36

state 29

    (3) stagedecl -> DEF . STAGE LCURLY stagelist RCURLY NL

    STAGE           shift and go to state 37


state 30

    (19) locdecls -> LOCAL COLON . NL INDENT decls DEDENT

    NL              shift and go to state 38


state 31

    (15) awdecls -> ALLWRITE COLON NL INDENT . decls DEDENT
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN
    (41) type -> . INPUTMAP

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 42
    STRING          shift and go to state 40
    FLOAT           shift and go to state 43
    IPOS            shift and go to state 44
    BOOLEAN         shift and go to state 45
    INPUTMAP        shift and go to state 41

    decl                           shift and go to state 39
    decls                          shift and go to state 47
    type                           shift and go to state 46
    empty                          shift and go to state 48

state 32

    (10) module -> USING MODULE CID COLON NL . INDENT actuatordecls sensordecls DEDENT

    INDENT          shift and go to state 49


state 33

    (17) ardecls -> ALLREAD COLON NL INDENT . rvdecls DEDENT
    (25) rvdecls -> . rvdecl rvdecls
    (26) rvdecls -> . empty
    (27) rvdecl -> . type varname LBRACE owner RBRACE NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN
    (41) type -> . INPUTMAP

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 42
    STRING          shift and go to state 40
    FLOAT           shift and go to state 43
    IPOS            shift and go to state 44
    BOOLEAN         shift and go to state 45
    INPUTMAP        shift and go to state 41

    rvdecl                         shift and go to state 50
    rvdecls                        shift and go to state 51
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 34

    (42) init -> INIT . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 54


state 35

    (1) program -> agent modules awdecls ardecls locdecls stagedecl init . events Numdecl
    (44) events -> . event events
    (45) events -> . event
    (46) event -> . LID COLON NL INDENT PRE COLON cond NL effblock DEDENT

    LID             shift and go to state 55

    event                          shift and go to state 56
    events                         shift and go to state 57

state 36

    (43) init -> empty .

    LID             reduce using rule 43 (init -> empty .)


state 37

    (3) stagedecl -> DEF STAGE . LCURLY stagelist RCURLY NL

    LCURLY          shift and go to state 58


state 38

    (19) locdecls -> LOCAL COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 59


state 39

    (21) decls -> decl . decls
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN
    (41) type -> . INPUTMAP

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 42
    STRING          shift and go to state 40
    FLOAT           shift and go to state 43
    IPOS            shift and go to state 44
    BOOLEAN         shift and go to state 45
    INPUTMAP        shift and go to state 41

    decl                           shift and go to state 39
    decls                          shift and go to state 60
    type                           shift and go to state 46
    empty                          shift and go to state 48

state 40

    (37) type -> STRING .

    LID             reduce using rule 37 (type -> STRING .)


state 41

    (41) type -> INPUTMAP .

    LID             reduce using rule 41 (type -> INPUTMAP .)


state 42

    (36) type -> INT .

    LID             reduce using rule 36 (type -> INT .)


state 43

    (38) type -> FLOAT .

    LID             reduce using rule 38 (type -> FLOAT .)


state 44

    (39) type -> IPOS .

    LID             reduce using rule 39 (type -> IPOS .)


state 45

    (40) type -> BOOLEAN .

    LID             reduce using rule 40 (type -> BOOLEAN .)


state 46

    (23) decl -> type . varname ASGN exp NL
    (24) decl -> type . varname NL
    (92) varname -> . LID

    LID             shift and go to state 61

    varname                        shift and go to state 62

state 47

    (15) awdecls -> ALLWRITE COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 63


state 48

    (22) decls -> empty .

    DEDENT          reduce using rule 22 (decls -> empty .)


state 49

    (10) module -> USING MODULE CID COLON NL INDENT . actuatordecls sensordecls DEDENT
    (11) actuatordecls -> . ACTUATORS COLON NL INDENT decls DEDENT
    (12) actuatordecls -> . empty
    (100) empty -> .

    ACTUATORS       shift and go to state 64
    SENSORS         reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

    actuatordecls                  shift and go to state 65
    empty                          shift and go to state 66

state 50

    (25) rvdecls -> rvdecl . rvdecls
    (25) rvdecls -> . rvdecl rvdecls
    (26) rvdecls -> . empty
    (27) rvdecl -> . type varname LBRACE owner RBRACE NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN
    (41) type -> . INPUTMAP

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 42
    STRING          shift and go to state 40
    FLOAT           shift and go to state 43
    IPOS            shift and go to state 44
    BOOLEAN         shift and go to state 45
    INPUTMAP        shift and go to state 41

    rvdecl                         shift and go to state 50
    rvdecls                        shift and go to state 67
    type                           shift and go to state 52
    empty                          shift and go to state 53

state 51

    (17) ardecls -> ALLREAD COLON NL INDENT rvdecls . DEDENT

    DEDENT          shift and go to state 68


state 52

    (27) rvdecl -> type . varname LBRACE owner RBRACE NL
    (92) varname -> . LID

    LID             shift and go to state 61

    varname                        shift and go to state 69

state 53

    (26) rvdecls -> empty .

    DEDENT          reduce using rule 26 (rvdecls -> empty .)


state 54

    (42) init -> INIT COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 70


state 55

    (46) event -> LID . COLON NL INDENT PRE COLON cond NL effblock DEDENT

    COLON           shift and go to state 71


state 56

    (44) events -> event . events
    (45) events -> event .
    (44) events -> . event events
    (45) events -> . event
    (46) event -> . LID COLON NL INDENT PRE COLON cond NL effblock DEDENT

    NUM             reduce using rule 45 (events -> event .)
    LID             shift and go to state 55

    event                          shift and go to state 56
    events                         shift and go to state 72

state 57

    (1) program -> agent modules awdecls ardecls locdecls stagedecl init events . Numdecl
    (2) Numdecl -> . NUM INUM NL

    NUM             shift and go to state 74

    Numdecl                        shift and go to state 73

state 58

    (3) stagedecl -> DEF STAGE LCURLY . stagelist RCURLY NL
    (5) stagelist -> . LID COMMA stagelist
    (6) stagelist -> . LID

    LID             shift and go to state 75

    stagelist                      shift and go to state 76

state 59

    (19) locdecls -> LOCAL COLON NL INDENT . decls DEDENT
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN
    (41) type -> . INPUTMAP

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 42
    STRING          shift and go to state 40
    FLOAT           shift and go to state 43
    IPOS            shift and go to state 44
    BOOLEAN         shift and go to state 45
    INPUTMAP        shift and go to state 41

    decl                           shift and go to state 39
    decls                          shift and go to state 77
    type                           shift and go to state 46
    empty                          shift and go to state 48

state 60

    (21) decls -> decl decls .

    DEDENT          reduce using rule 21 (decls -> decl decls .)


state 61

    (92) varname -> LID .

    ASGN            reduce using rule 92 (varname -> LID .)
    LPAR            reduce using rule 92 (varname -> LID .)
    NL              reduce using rule 92 (varname -> LID .)
    LBRACE          reduce using rule 92 (varname -> LID .)


state 62

    (23) decl -> type varname . ASGN exp NL
    (24) decl -> type varname . NL

    ASGN            shift and go to state 79
    NL              shift and go to state 78


state 63

    (15) awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .

    ALLREAD         reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)
    LOCAL           reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)
    DEF             reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)
    INIT            reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)
    LID             reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)


state 64

    (11) actuatordecls -> ACTUATORS . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 80


state 65

    (10) module -> USING MODULE CID COLON NL INDENT actuatordecls . sensordecls DEDENT
    (13) sensordecls -> . SENSORS COLON NL INDENT decls DEDENT
    (14) sensordecls -> . empty
    (100) empty -> .

    SENSORS         shift and go to state 82
    DEDENT          reduce using rule 100 (empty -> .)

    empty                          shift and go to state 83
    sensordecls                    shift and go to state 81

state 66

    (12) actuatordecls -> empty .

    SENSORS         reduce using rule 12 (actuatordecls -> empty .)
    DEDENT          reduce using rule 12 (actuatordecls -> empty .)


state 67

    (25) rvdecls -> rvdecl rvdecls .

    DEDENT          reduce using rule 25 (rvdecls -> rvdecl rvdecls .)


state 68

    (17) ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .

    LOCAL           reduce using rule 17 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)
    DEF             reduce using rule 17 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)
    INIT            reduce using rule 17 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)
    LID             reduce using rule 17 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)


state 69

    (27) rvdecl -> type varname . LBRACE owner RBRACE NL

    LBRACE          shift and go to state 84


state 70

    (42) init -> INIT COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 85


state 71

    (46) event -> LID COLON . NL INDENT PRE COLON cond NL effblock DEDENT

    NL              shift and go to state 86


state 72

    (44) events -> event events .

    NUM             reduce using rule 44 (events -> event events .)


state 73

    (1) program -> agent modules awdecls ardecls locdecls stagedecl init events Numdecl .

    $end            reduce using rule 1 (program -> agent modules awdecls ardecls locdecls stagedecl init events Numdecl .)


state 74

    (2) Numdecl -> NUM . INUM NL

    INUM            shift and go to state 87


state 75

    (5) stagelist -> LID . COMMA stagelist
    (6) stagelist -> LID .

    COMMA           shift and go to state 88
    RCURLY          reduce using rule 6 (stagelist -> LID .)


state 76

    (3) stagedecl -> DEF STAGE LCURLY stagelist . RCURLY NL

    RCURLY          shift and go to state 89


state 77

    (19) locdecls -> LOCAL COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 90


state 78

    (24) decl -> type varname NL .

    INT             reduce using rule 24 (decl -> type varname NL .)
    STRING          reduce using rule 24 (decl -> type varname NL .)
    FLOAT           reduce using rule 24 (decl -> type varname NL .)
    IPOS            reduce using rule 24 (decl -> type varname NL .)
    BOOLEAN         reduce using rule 24 (decl -> type varname NL .)
    INPUTMAP        reduce using rule 24 (decl -> type varname NL .)
    DEDENT          reduce using rule 24 (decl -> type varname NL .)


state 79

    (23) decl -> type varname ASGN . exp NL
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 102
    LID             shift and go to state 91
    LPAR            shift and go to state 92
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    exp                            shift and go to state 108
    bval                           shift and go to state 98

state 80

    (11) actuatordecls -> ACTUATORS COLON . NL INDENT decls DEDENT

    NL              shift and go to state 110


state 81

    (10) module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls . DEDENT

    DEDENT          shift and go to state 111


state 82

    (13) sensordecls -> SENSORS . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 112


state 83

    (14) sensordecls -> empty .

    DEDENT          reduce using rule 14 (sensordecls -> empty .)


state 84

    (27) rvdecl -> type varname LBRACE . owner RBRACE NL
    (28) owner -> . TIMES
    (29) owner -> . INUM

    TIMES           shift and go to state 113
    INUM            shift and go to state 114

    owner                          shift and go to state 115

state 85

    (42) init -> INIT COLON NL INDENT . stmts DEDENT
    (54) stmts -> . stmt stmts
    (55) stmts -> . stmt
    (56) stmt -> . asgn
    (57) stmt -> . wptstmt
    (58) stmt -> . exit
    (59) stmt -> . funccall NL
    (60) stmt -> . modulefunccall NL
    (61) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (62) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (67) asgn -> . varname ASGN exp NL
    (68) asgn -> . stagechange
    (71) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (63) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR
    (92) varname -> . LID
    (70) stagechange -> . STAGE ASGN varname NL

    ATOMIC          shift and go to state 116
    IF              shift and go to state 124
    EXIT            shift and go to state 128
    CID             shift and go to state 94
    LID             shift and go to state 61
    STAGE           shift and go to state 120

    stagechange                    shift and go to state 125
    funccall                       shift and go to state 121
    stmts                          shift and go to state 117
    varname                        shift and go to state 126
    stmt                           shift and go to state 123
    asgn                           shift and go to state 118
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    exit                           shift and go to state 119

state 86

    (46) event -> LID COLON NL . INDENT PRE COLON cond NL effblock DEDENT

    INDENT          shift and go to state 129


state 87

    (2) Numdecl -> NUM INUM . NL

    NL              shift and go to state 130


state 88

    (5) stagelist -> LID COMMA . stagelist
    (5) stagelist -> . LID COMMA stagelist
    (6) stagelist -> . LID

    LID             shift and go to state 75

    stagelist                      shift and go to state 131

state 89

    (3) stagedecl -> DEF STAGE LCURLY stagelist RCURLY . NL

    NL              shift and go to state 132


state 90

    (19) locdecls -> LOCAL COLON NL INDENT decls DEDENT .

    DEF             reduce using rule 19 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)
    INIT            reduce using rule 19 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)
    LID             reduce using rule 19 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)


state 91

    (81) exp -> LID . LBRACE exp RBRACE
    (92) varname -> LID .

    LBRACE          shift and go to state 133
    LPAR            reduce using rule 92 (varname -> LID .)
    RPAR            reduce using rule 92 (varname -> LID .)
    PLUS            reduce using rule 92 (varname -> LID .)
    TIMES           reduce using rule 92 (varname -> LID .)
    MINUS           reduce using rule 92 (varname -> LID .)
    BY              reduce using rule 92 (varname -> LID .)
    AND             reduce using rule 92 (varname -> LID .)
    OR              reduce using rule 92 (varname -> LID .)
    EQ              reduce using rule 92 (varname -> LID .)
    NEQ             reduce using rule 92 (varname -> LID .)
    GEQ             reduce using rule 92 (varname -> LID .)
    LEQ             reduce using rule 92 (varname -> LID .)
    GT              reduce using rule 92 (varname -> LID .)
    LT              reduce using rule 92 (varname -> LID .)
    COLON           reduce using rule 92 (varname -> LID .)
    NL              reduce using rule 92 (varname -> LID .)
    COMMA           reduce using rule 92 (varname -> LID .)
    RBRACE          reduce using rule 92 (varname -> LID .)


state 92

    (86) bracketexp -> LPAR . exp RPAR
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 102
    LID             shift and go to state 91
    LPAR            shift and go to state 92
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    exp                            shift and go to state 134
    bval                           shift and go to state 98

state 93

    (72) exp -> bracketexp .

    NL              reduce using rule 72 (exp -> bracketexp .)
    PLUS            reduce using rule 72 (exp -> bracketexp .)
    TIMES           reduce using rule 72 (exp -> bracketexp .)
    MINUS           reduce using rule 72 (exp -> bracketexp .)
    BY              reduce using rule 72 (exp -> bracketexp .)
    RPAR            reduce using rule 72 (exp -> bracketexp .)
    COMMA           reduce using rule 72 (exp -> bracketexp .)
    COLON           reduce using rule 72 (exp -> bracketexp .)
    RBRACE          reduce using rule 72 (exp -> bracketexp .)
    AND             reduce using rule 72 (exp -> bracketexp .)
    OR              reduce using rule 72 (exp -> bracketexp .)
    EQ              reduce using rule 72 (exp -> bracketexp .)
    NEQ             reduce using rule 72 (exp -> bracketexp .)
    GEQ             reduce using rule 72 (exp -> bracketexp .)
    LEQ             reduce using rule 72 (exp -> bracketexp .)
    GT              reduce using rule 72 (exp -> bracketexp .)
    LT              reduce using rule 72 (exp -> bracketexp .)


state 94

    (64) modulefunccall -> CID . LPAR args RPAR

    LPAR            shift and go to state 135


state 95

    (90) num -> FNUM .

    COMMA           reduce using rule 90 (num -> FNUM .)
    PLUS            reduce using rule 90 (num -> FNUM .)
    TIMES           reduce using rule 90 (num -> FNUM .)
    MINUS           reduce using rule 90 (num -> FNUM .)
    BY              reduce using rule 90 (num -> FNUM .)
    RPAR            reduce using rule 90 (num -> FNUM .)
    NL              reduce using rule 90 (num -> FNUM .)
    COLON           reduce using rule 90 (num -> FNUM .)
    RBRACE          reduce using rule 90 (num -> FNUM .)
    AND             reduce using rule 90 (num -> FNUM .)
    OR              reduce using rule 90 (num -> FNUM .)
    EQ              reduce using rule 90 (num -> FNUM .)
    NEQ             reduce using rule 90 (num -> FNUM .)
    GEQ             reduce using rule 90 (num -> FNUM .)
    LEQ             reduce using rule 90 (num -> FNUM .)
    GT              reduce using rule 90 (num -> FNUM .)
    LT              reduce using rule 90 (num -> FNUM .)


state 96

    (80) exp -> pid .

    NL              reduce using rule 80 (exp -> pid .)
    PLUS            reduce using rule 80 (exp -> pid .)
    TIMES           reduce using rule 80 (exp -> pid .)
    MINUS           reduce using rule 80 (exp -> pid .)
    BY              reduce using rule 80 (exp -> pid .)
    RPAR            reduce using rule 80 (exp -> pid .)
    COMMA           reduce using rule 80 (exp -> pid .)
    COLON           reduce using rule 80 (exp -> pid .)
    RBRACE          reduce using rule 80 (exp -> pid .)
    AND             reduce using rule 80 (exp -> pid .)
    OR              reduce using rule 80 (exp -> pid .)
    EQ              reduce using rule 80 (exp -> pid .)
    NEQ             reduce using rule 80 (exp -> pid .)
    GEQ             reduce using rule 80 (exp -> pid .)
    LEQ             reduce using rule 80 (exp -> pid .)
    GT              reduce using rule 80 (exp -> pid .)
    LT              reduce using rule 80 (exp -> pid .)


state 97

    (82) exp -> num .

    NL              reduce using rule 82 (exp -> num .)
    PLUS            reduce using rule 82 (exp -> num .)
    TIMES           reduce using rule 82 (exp -> num .)
    MINUS           reduce using rule 82 (exp -> num .)
    BY              reduce using rule 82 (exp -> num .)
    RPAR            reduce using rule 82 (exp -> num .)
    COMMA           reduce using rule 82 (exp -> num .)
    COLON           reduce using rule 82 (exp -> num .)
    RBRACE          reduce using rule 82 (exp -> num .)
    AND             reduce using rule 82 (exp -> num .)
    OR              reduce using rule 82 (exp -> num .)
    EQ              reduce using rule 82 (exp -> num .)
    NEQ             reduce using rule 82 (exp -> num .)
    GEQ             reduce using rule 82 (exp -> num .)
    LEQ             reduce using rule 82 (exp -> num .)
    GT              reduce using rule 82 (exp -> num .)
    LT              reduce using rule 82 (exp -> num .)


state 98

    (79) exp -> bval .

    NL              reduce using rule 79 (exp -> bval .)
    PLUS            reduce using rule 79 (exp -> bval .)
    TIMES           reduce using rule 79 (exp -> bval .)
    MINUS           reduce using rule 79 (exp -> bval .)
    BY              reduce using rule 79 (exp -> bval .)
    RPAR            reduce using rule 79 (exp -> bval .)
    COMMA           reduce using rule 79 (exp -> bval .)
    COLON           reduce using rule 79 (exp -> bval .)
    RBRACE          reduce using rule 79 (exp -> bval .)
    AND             reduce using rule 79 (exp -> bval .)
    OR              reduce using rule 79 (exp -> bval .)
    EQ              reduce using rule 79 (exp -> bval .)
    NEQ             reduce using rule 79 (exp -> bval .)
    GEQ             reduce using rule 79 (exp -> bval .)
    LEQ             reduce using rule 79 (exp -> bval .)
    GT              reduce using rule 79 (exp -> bval .)
    LT              reduce using rule 79 (exp -> bval .)


state 99

    (83) exp -> null .

    NL              reduce using rule 83 (exp -> null .)
    PLUS            reduce using rule 83 (exp -> null .)
    TIMES           reduce using rule 83 (exp -> null .)
    MINUS           reduce using rule 83 (exp -> null .)
    BY              reduce using rule 83 (exp -> null .)
    RPAR            reduce using rule 83 (exp -> null .)
    COMMA           reduce using rule 83 (exp -> null .)
    COLON           reduce using rule 83 (exp -> null .)
    RBRACE          reduce using rule 83 (exp -> null .)
    AND             reduce using rule 83 (exp -> null .)
    OR              reduce using rule 83 (exp -> null .)
    EQ              reduce using rule 83 (exp -> null .)
    NEQ             reduce using rule 83 (exp -> null .)
    GEQ             reduce using rule 83 (exp -> null .)
    LEQ             reduce using rule 83 (exp -> null .)
    GT              reduce using rule 83 (exp -> null .)
    LT              reduce using rule 83 (exp -> null .)


state 100

    (87) bval -> TRUE .

    PLUS            reduce using rule 87 (bval -> TRUE .)
    TIMES           reduce using rule 87 (bval -> TRUE .)
    MINUS           reduce using rule 87 (bval -> TRUE .)
    BY              reduce using rule 87 (bval -> TRUE .)
    NL              reduce using rule 87 (bval -> TRUE .)
    RPAR            reduce using rule 87 (bval -> TRUE .)
    COLON           reduce using rule 87 (bval -> TRUE .)
    RBRACE          reduce using rule 87 (bval -> TRUE .)
    COMMA           reduce using rule 87 (bval -> TRUE .)
    AND             reduce using rule 87 (bval -> TRUE .)
    OR              reduce using rule 87 (bval -> TRUE .)
    EQ              reduce using rule 87 (bval -> TRUE .)
    NEQ             reduce using rule 87 (bval -> TRUE .)
    GEQ             reduce using rule 87 (bval -> TRUE .)
    LEQ             reduce using rule 87 (bval -> TRUE .)
    GT              reduce using rule 87 (bval -> TRUE .)
    LT              reduce using rule 87 (bval -> TRUE .)


state 101

    (91) pid -> PID .

    COMMA           reduce using rule 91 (pid -> PID .)
    PLUS            reduce using rule 91 (pid -> PID .)
    TIMES           reduce using rule 91 (pid -> PID .)
    MINUS           reduce using rule 91 (pid -> PID .)
    BY              reduce using rule 91 (pid -> PID .)
    RPAR            reduce using rule 91 (pid -> PID .)
    NL              reduce using rule 91 (pid -> PID .)
    COLON           reduce using rule 91 (pid -> PID .)
    RBRACE          reduce using rule 91 (pid -> PID .)
    AND             reduce using rule 91 (pid -> PID .)
    OR              reduce using rule 91 (pid -> PID .)
    EQ              reduce using rule 91 (pid -> PID .)
    NEQ             reduce using rule 91 (pid -> PID .)
    GEQ             reduce using rule 91 (pid -> PID .)
    LEQ             reduce using rule 91 (pid -> PID .)
    GT              reduce using rule 91 (pid -> PID .)
    LT              reduce using rule 91 (pid -> PID .)


state 102

    (78) exp -> STAGE .

    NL              reduce using rule 78 (exp -> STAGE .)
    PLUS            reduce using rule 78 (exp -> STAGE .)
    TIMES           reduce using rule 78 (exp -> STAGE .)
    MINUS           reduce using rule 78 (exp -> STAGE .)
    BY              reduce using rule 78 (exp -> STAGE .)
    RPAR            reduce using rule 78 (exp -> STAGE .)
    COMMA           reduce using rule 78 (exp -> STAGE .)
    COLON           reduce using rule 78 (exp -> STAGE .)
    RBRACE          reduce using rule 78 (exp -> STAGE .)
    AND             reduce using rule 78 (exp -> STAGE .)
    OR              reduce using rule 78 (exp -> STAGE .)
    EQ              reduce using rule 78 (exp -> STAGE .)
    NEQ             reduce using rule 78 (exp -> STAGE .)
    GEQ             reduce using rule 78 (exp -> STAGE .)
    LEQ             reduce using rule 78 (exp -> STAGE .)
    GT              reduce using rule 78 (exp -> STAGE .)
    LT              reduce using rule 78 (exp -> STAGE .)


state 103

    (84) exp -> funccall .

    NL              reduce using rule 84 (exp -> funccall .)
    PLUS            reduce using rule 84 (exp -> funccall .)
    TIMES           reduce using rule 84 (exp -> funccall .)
    MINUS           reduce using rule 84 (exp -> funccall .)
    BY              reduce using rule 84 (exp -> funccall .)
    RPAR            reduce using rule 84 (exp -> funccall .)
    COMMA           reduce using rule 84 (exp -> funccall .)
    COLON           reduce using rule 84 (exp -> funccall .)
    RBRACE          reduce using rule 84 (exp -> funccall .)
    AND             reduce using rule 84 (exp -> funccall .)
    OR              reduce using rule 84 (exp -> funccall .)
    EQ              reduce using rule 84 (exp -> funccall .)
    NEQ             reduce using rule 84 (exp -> funccall .)
    GEQ             reduce using rule 84 (exp -> funccall .)
    LEQ             reduce using rule 84 (exp -> funccall .)
    GT              reduce using rule 84 (exp -> funccall .)
    LT              reduce using rule 84 (exp -> funccall .)


state 104

    (85) exp -> modulefunccall .

    NL              reduce using rule 85 (exp -> modulefunccall .)
    PLUS            reduce using rule 85 (exp -> modulefunccall .)
    TIMES           reduce using rule 85 (exp -> modulefunccall .)
    MINUS           reduce using rule 85 (exp -> modulefunccall .)
    BY              reduce using rule 85 (exp -> modulefunccall .)
    RPAR            reduce using rule 85 (exp -> modulefunccall .)
    COMMA           reduce using rule 85 (exp -> modulefunccall .)
    COLON           reduce using rule 85 (exp -> modulefunccall .)
    RBRACE          reduce using rule 85 (exp -> modulefunccall .)
    AND             reduce using rule 85 (exp -> modulefunccall .)
    OR              reduce using rule 85 (exp -> modulefunccall .)
    EQ              reduce using rule 85 (exp -> modulefunccall .)
    NEQ             reduce using rule 85 (exp -> modulefunccall .)
    GEQ             reduce using rule 85 (exp -> modulefunccall .)
    LEQ             reduce using rule 85 (exp -> modulefunccall .)
    GT              reduce using rule 85 (exp -> modulefunccall .)
    LT              reduce using rule 85 (exp -> modulefunccall .)


state 105

    (93) null -> NULL .

    PLUS            reduce using rule 93 (null -> NULL .)
    TIMES           reduce using rule 93 (null -> NULL .)
    MINUS           reduce using rule 93 (null -> NULL .)
    BY              reduce using rule 93 (null -> NULL .)
    RPAR            reduce using rule 93 (null -> NULL .)
    NL              reduce using rule 93 (null -> NULL .)
    COLON           reduce using rule 93 (null -> NULL .)
    RBRACE          reduce using rule 93 (null -> NULL .)
    COMMA           reduce using rule 93 (null -> NULL .)
    AND             reduce using rule 93 (null -> NULL .)
    OR              reduce using rule 93 (null -> NULL .)
    EQ              reduce using rule 93 (null -> NULL .)
    NEQ             reduce using rule 93 (null -> NULL .)
    GEQ             reduce using rule 93 (null -> NULL .)
    LEQ             reduce using rule 93 (null -> NULL .)
    GT              reduce using rule 93 (null -> NULL .)
    LT              reduce using rule 93 (null -> NULL .)


state 106

    (88) bval -> FALSE .

    PLUS            reduce using rule 88 (bval -> FALSE .)
    TIMES           reduce using rule 88 (bval -> FALSE .)
    MINUS           reduce using rule 88 (bval -> FALSE .)
    BY              reduce using rule 88 (bval -> FALSE .)
    NL              reduce using rule 88 (bval -> FALSE .)
    RPAR            reduce using rule 88 (bval -> FALSE .)
    COLON           reduce using rule 88 (bval -> FALSE .)
    RBRACE          reduce using rule 88 (bval -> FALSE .)
    COMMA           reduce using rule 88 (bval -> FALSE .)
    AND             reduce using rule 88 (bval -> FALSE .)
    OR              reduce using rule 88 (bval -> FALSE .)
    EQ              reduce using rule 88 (bval -> FALSE .)
    NEQ             reduce using rule 88 (bval -> FALSE .)
    GEQ             reduce using rule 88 (bval -> FALSE .)
    LEQ             reduce using rule 88 (bval -> FALSE .)
    GT              reduce using rule 88 (bval -> FALSE .)
    LT              reduce using rule 88 (bval -> FALSE .)


state 107

    (77) exp -> varname .
    (30) funccall -> varname . LPAR args RPAR

    NL              reduce using rule 77 (exp -> varname .)
    PLUS            reduce using rule 77 (exp -> varname .)
    TIMES           reduce using rule 77 (exp -> varname .)
    MINUS           reduce using rule 77 (exp -> varname .)
    BY              reduce using rule 77 (exp -> varname .)
    RPAR            reduce using rule 77 (exp -> varname .)
    COMMA           reduce using rule 77 (exp -> varname .)
    COLON           reduce using rule 77 (exp -> varname .)
    RBRACE          reduce using rule 77 (exp -> varname .)
    AND             reduce using rule 77 (exp -> varname .)
    OR              reduce using rule 77 (exp -> varname .)
    EQ              reduce using rule 77 (exp -> varname .)
    NEQ             reduce using rule 77 (exp -> varname .)
    GEQ             reduce using rule 77 (exp -> varname .)
    LEQ             reduce using rule 77 (exp -> varname .)
    GT              reduce using rule 77 (exp -> varname .)
    LT              reduce using rule 77 (exp -> varname .)
    LPAR            shift and go to state 136


state 108

    (23) decl -> type varname ASGN exp . NL
    (73) exp -> exp . PLUS exp
    (74) exp -> exp . TIMES exp
    (75) exp -> exp . MINUS exp
    (76) exp -> exp . BY exp

    NL              shift and go to state 137
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138


state 109

    (89) num -> INUM .

    COMMA           reduce using rule 89 (num -> INUM .)
    PLUS            reduce using rule 89 (num -> INUM .)
    TIMES           reduce using rule 89 (num -> INUM .)
    MINUS           reduce using rule 89 (num -> INUM .)
    BY              reduce using rule 89 (num -> INUM .)
    RPAR            reduce using rule 89 (num -> INUM .)
    NL              reduce using rule 89 (num -> INUM .)
    COLON           reduce using rule 89 (num -> INUM .)
    RBRACE          reduce using rule 89 (num -> INUM .)
    AND             reduce using rule 89 (num -> INUM .)
    OR              reduce using rule 89 (num -> INUM .)
    EQ              reduce using rule 89 (num -> INUM .)
    NEQ             reduce using rule 89 (num -> INUM .)
    GEQ             reduce using rule 89 (num -> INUM .)
    LEQ             reduce using rule 89 (num -> INUM .)
    GT              reduce using rule 89 (num -> INUM .)
    LT              reduce using rule 89 (num -> INUM .)


state 110

    (11) actuatordecls -> ACTUATORS COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 142


state 111

    (10) module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .

    USING           reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    ALLWRITE        reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    ALLREAD         reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    LOCAL           reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    DEF             reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    INIT            reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    LID             reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)


state 112

    (13) sensordecls -> SENSORS COLON . NL INDENT decls DEDENT

    NL              shift and go to state 143


state 113

    (28) owner -> TIMES .

    RBRACE          reduce using rule 28 (owner -> TIMES .)


state 114

    (29) owner -> INUM .

    RBRACE          reduce using rule 29 (owner -> INUM .)


state 115

    (27) rvdecl -> type varname LBRACE owner . RBRACE NL

    RBRACE          shift and go to state 144


state 116

    (61) stmt -> ATOMIC . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 145


state 117

    (42) init -> INIT COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 146


state 118

    (56) stmt -> asgn .

    ATOMIC          reduce using rule 56 (stmt -> asgn .)
    IF              reduce using rule 56 (stmt -> asgn .)
    EXIT            reduce using rule 56 (stmt -> asgn .)
    CID             reduce using rule 56 (stmt -> asgn .)
    LID             reduce using rule 56 (stmt -> asgn .)
    STAGE           reduce using rule 56 (stmt -> asgn .)
    DEDENT          reduce using rule 56 (stmt -> asgn .)


state 119

    (58) stmt -> exit .

    ATOMIC          reduce using rule 58 (stmt -> exit .)
    IF              reduce using rule 58 (stmt -> exit .)
    EXIT            reduce using rule 58 (stmt -> exit .)
    CID             reduce using rule 58 (stmt -> exit .)
    LID             reduce using rule 58 (stmt -> exit .)
    STAGE           reduce using rule 58 (stmt -> exit .)
    DEDENT          reduce using rule 58 (stmt -> exit .)


state 120

    (70) stagechange -> STAGE . ASGN varname NL

    ASGN            shift and go to state 147


state 121

    (59) stmt -> funccall . NL

    NL              shift and go to state 148


state 122

    (60) stmt -> modulefunccall . NL

    NL              shift and go to state 149


state 123

    (54) stmts -> stmt . stmts
    (55) stmts -> stmt .
    (54) stmts -> . stmt stmts
    (55) stmts -> . stmt
    (56) stmt -> . asgn
    (57) stmt -> . wptstmt
    (58) stmt -> . exit
    (59) stmt -> . funccall NL
    (60) stmt -> . modulefunccall NL
    (61) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (62) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (67) asgn -> . varname ASGN exp NL
    (68) asgn -> . stagechange
    (71) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (63) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR
    (92) varname -> . LID
    (70) stagechange -> . STAGE ASGN varname NL

    DEDENT          reduce using rule 55 (stmts -> stmt .)
    ATOMIC          shift and go to state 116
    IF              shift and go to state 124
    EXIT            shift and go to state 128
    CID             shift and go to state 94
    LID             shift and go to state 61
    STAGE           shift and go to state 120

    stagechange                    shift and go to state 125
    funccall                       shift and go to state 121
    stmts                          shift and go to state 150
    varname                        shift and go to state 126
    stmt                           shift and go to state 123
    asgn                           shift and go to state 118
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    exit                           shift and go to state 119

state 124

    (62) stmt -> IF . cond COLON NL INDENT stmts DEDENT elseblock
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . exp
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 151
    STAGE           shift and go to state 102
    LID             shift and go to state 91
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    modulefunccall                 shift and go to state 104
    null                           shift and go to state 99
    num                            shift and go to state 97
    cond                           shift and go to state 152
    exp                            shift and go to state 153
    bval                           shift and go to state 98

state 125

    (68) asgn -> stagechange .

    ATOMIC          reduce using rule 68 (asgn -> stagechange .)
    IF              reduce using rule 68 (asgn -> stagechange .)
    EXIT            reduce using rule 68 (asgn -> stagechange .)
    CID             reduce using rule 68 (asgn -> stagechange .)
    LID             reduce using rule 68 (asgn -> stagechange .)
    STAGE           reduce using rule 68 (asgn -> stagechange .)
    DEDENT          reduce using rule 68 (asgn -> stagechange .)


state 126

    (67) asgn -> varname . ASGN exp NL
    (71) wptstmt -> varname . ASGN GETINPUT LPAR RPAR NL
    (30) funccall -> varname . LPAR args RPAR

    ASGN            shift and go to state 154
    LPAR            shift and go to state 136


state 127

    (57) stmt -> wptstmt .

    ATOMIC          reduce using rule 57 (stmt -> wptstmt .)
    IF              reduce using rule 57 (stmt -> wptstmt .)
    EXIT            reduce using rule 57 (stmt -> wptstmt .)
    CID             reduce using rule 57 (stmt -> wptstmt .)
    LID             reduce using rule 57 (stmt -> wptstmt .)
    STAGE           reduce using rule 57 (stmt -> wptstmt .)
    DEDENT          reduce using rule 57 (stmt -> wptstmt .)


state 128

    (63) exit -> EXIT . NL

    NL              shift and go to state 155


state 129

    (46) event -> LID COLON NL INDENT . PRE COLON cond NL effblock DEDENT

    PRE             shift and go to state 156


state 130

    (2) Numdecl -> NUM INUM NL .

    $end            reduce using rule 2 (Numdecl -> NUM INUM NL .)


state 131

    (5) stagelist -> LID COMMA stagelist .

    RCURLY          reduce using rule 5 (stagelist -> LID COMMA stagelist .)


state 132

    (3) stagedecl -> DEF STAGE LCURLY stagelist RCURLY NL .

    INIT            reduce using rule 3 (stagedecl -> DEF STAGE LCURLY stagelist RCURLY NL .)
    LID             reduce using rule 3 (stagedecl -> DEF STAGE LCURLY stagelist RCURLY NL .)


state 133

    (81) exp -> LID LBRACE . exp RBRACE
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 102
    LID             shift and go to state 91
    LPAR            shift and go to state 92
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    exp                            shift and go to state 157
    bval                           shift and go to state 98

state 134

    (86) bracketexp -> LPAR exp . RPAR
    (73) exp -> exp . PLUS exp
    (74) exp -> exp . TIMES exp
    (75) exp -> exp . MINUS exp
    (76) exp -> exp . BY exp

    RPAR            shift and go to state 158
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138


state 135

    (64) modulefunccall -> CID LPAR . args RPAR
    (31) args -> . neargs
    (32) args -> . noargs
    (34) neargs -> . exp
    (35) neargs -> . exp COMMA neargs
    (33) noargs -> . empty
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (100) empty -> .
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 102
    LID             shift and go to state 91
    RPAR            reduce using rule 100 (empty -> .)
    LPAR            shift and go to state 92
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    args                           shift and go to state 162
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    exp                            shift and go to state 163
    noargs                         shift and go to state 159
    neargs                         shift and go to state 160
    bval                           shift and go to state 98
    empty                          shift and go to state 161

state 136

    (30) funccall -> varname LPAR . args RPAR
    (31) args -> . neargs
    (32) args -> . noargs
    (34) neargs -> . exp
    (35) neargs -> . exp COMMA neargs
    (33) noargs -> . empty
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (100) empty -> .
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 102
    LID             shift and go to state 91
    RPAR            reduce using rule 100 (empty -> .)
    LPAR            shift and go to state 92
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    args                           shift and go to state 164
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    exp                            shift and go to state 163
    noargs                         shift and go to state 159
    neargs                         shift and go to state 160
    bval                           shift and go to state 98
    empty                          shift and go to state 161

state 137

    (23) decl -> type varname ASGN exp NL .

    INT             reduce using rule 23 (decl -> type varname ASGN exp NL .)
    STRING          reduce using rule 23 (decl -> type varname ASGN exp NL .)
    FLOAT           reduce using rule 23 (decl -> type varname ASGN exp NL .)
    IPOS            reduce using rule 23 (decl -> type varname ASGN exp NL .)
    BOOLEAN         reduce using rule 23 (decl -> type varname ASGN exp NL .)
    INPUTMAP        reduce using rule 23 (decl -> type varname ASGN exp NL .)
    DEDENT          reduce using rule 23 (decl -> type varname ASGN exp NL .)


state 138

    (76) exp -> exp BY . exp
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 102
    LID             shift and go to state 91
    LPAR            shift and go to state 92
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    exp                            shift and go to state 165
    bval                           shift and go to state 98

state 139

    (73) exp -> exp PLUS . exp
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 102
    LID             shift and go to state 91
    LPAR            shift and go to state 92
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    exp                            shift and go to state 166
    bval                           shift and go to state 98

state 140

    (74) exp -> exp TIMES . exp
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 102
    LID             shift and go to state 91
    LPAR            shift and go to state 92
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    exp                            shift and go to state 167
    bval                           shift and go to state 98

state 141

    (75) exp -> exp MINUS . exp
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 102
    LID             shift and go to state 91
    LPAR            shift and go to state 92
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    exp                            shift and go to state 168
    bval                           shift and go to state 98

state 142

    (11) actuatordecls -> ACTUATORS COLON NL INDENT . decls DEDENT
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN
    (41) type -> . INPUTMAP

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 42
    STRING          shift and go to state 40
    FLOAT           shift and go to state 43
    IPOS            shift and go to state 44
    BOOLEAN         shift and go to state 45
    INPUTMAP        shift and go to state 41

    decl                           shift and go to state 39
    decls                          shift and go to state 169
    type                           shift and go to state 46
    empty                          shift and go to state 48

state 143

    (13) sensordecls -> SENSORS COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 170


state 144

    (27) rvdecl -> type varname LBRACE owner RBRACE . NL

    NL              shift and go to state 171


state 145

    (61) stmt -> ATOMIC COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 172


state 146

    (42) init -> INIT COLON NL INDENT stmts DEDENT .

    LID             reduce using rule 42 (init -> INIT COLON NL INDENT stmts DEDENT .)


state 147

    (70) stagechange -> STAGE ASGN . varname NL
    (92) varname -> . LID

    LID             shift and go to state 61

    varname                        shift and go to state 173

state 148

    (59) stmt -> funccall NL .

    ATOMIC          reduce using rule 59 (stmt -> funccall NL .)
    IF              reduce using rule 59 (stmt -> funccall NL .)
    EXIT            reduce using rule 59 (stmt -> funccall NL .)
    CID             reduce using rule 59 (stmt -> funccall NL .)
    LID             reduce using rule 59 (stmt -> funccall NL .)
    STAGE           reduce using rule 59 (stmt -> funccall NL .)
    DEDENT          reduce using rule 59 (stmt -> funccall NL .)


state 149

    (60) stmt -> modulefunccall NL .

    ATOMIC          reduce using rule 60 (stmt -> modulefunccall NL .)
    IF              reduce using rule 60 (stmt -> modulefunccall NL .)
    EXIT            reduce using rule 60 (stmt -> modulefunccall NL .)
    CID             reduce using rule 60 (stmt -> modulefunccall NL .)
    LID             reduce using rule 60 (stmt -> modulefunccall NL .)
    STAGE           reduce using rule 60 (stmt -> modulefunccall NL .)
    DEDENT          reduce using rule 60 (stmt -> modulefunccall NL .)


state 150

    (54) stmts -> stmt stmts .

    DEDENT          reduce using rule 54 (stmts -> stmt stmts .)


state 151

    (49) cond -> LPAR . cond AND cond RPAR
    (50) cond -> LPAR . cond OR cond RPAR
    (51) cond -> LPAR . cond op cond RPAR
    (52) cond -> LPAR . NOT cond RPAR
    (86) bracketexp -> LPAR . exp RPAR
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . exp
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    NOT             shift and go to state 176
    LPAR            shift and go to state 151
    STAGE           shift and go to state 102
    LID             shift and go to state 91
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    cond                           shift and go to state 174
    exp                            shift and go to state 175
    bval                           shift and go to state 98

state 152

    (62) stmt -> IF cond . COLON NL INDENT stmts DEDENT elseblock

    COLON           shift and go to state 177


state 153

    (53) cond -> exp .
    (73) exp -> exp . PLUS exp
    (74) exp -> exp . TIMES exp
    (75) exp -> exp . MINUS exp
    (76) exp -> exp . BY exp

    NL              reduce using rule 53 (cond -> exp .)
    RPAR            reduce using rule 53 (cond -> exp .)
    COLON           reduce using rule 53 (cond -> exp .)
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138


state 154

    (67) asgn -> varname ASGN . exp NL
    (71) wptstmt -> varname ASGN . GETINPUT LPAR RPAR NL
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    GETINPUT        shift and go to state 179
    STAGE           shift and go to state 102
    LID             shift and go to state 91
    LPAR            shift and go to state 92
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    exp                            shift and go to state 178
    bval                           shift and go to state 98

state 155

    (63) exit -> EXIT NL .

    ATOMIC          reduce using rule 63 (exit -> EXIT NL .)
    IF              reduce using rule 63 (exit -> EXIT NL .)
    EXIT            reduce using rule 63 (exit -> EXIT NL .)
    CID             reduce using rule 63 (exit -> EXIT NL .)
    LID             reduce using rule 63 (exit -> EXIT NL .)
    STAGE           reduce using rule 63 (exit -> EXIT NL .)
    DEDENT          reduce using rule 63 (exit -> EXIT NL .)


state 156

    (46) event -> LID COLON NL INDENT PRE . COLON cond NL effblock DEDENT

    COLON           shift and go to state 180


state 157

    (81) exp -> LID LBRACE exp . RBRACE
    (73) exp -> exp . PLUS exp
    (74) exp -> exp . TIMES exp
    (75) exp -> exp . MINUS exp
    (76) exp -> exp . BY exp

    RBRACE          shift and go to state 181
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138


state 158

    (86) bracketexp -> LPAR exp RPAR .

    PLUS            reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    TIMES           reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    MINUS           reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    BY              reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    RPAR            reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    NL              reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    COLON           reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    RBRACE          reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    COMMA           reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    AND             reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    OR              reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    EQ              reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    NEQ             reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    GEQ             reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    LEQ             reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    GT              reduce using rule 86 (bracketexp -> LPAR exp RPAR .)
    LT              reduce using rule 86 (bracketexp -> LPAR exp RPAR .)


state 159

    (32) args -> noargs .

    RPAR            reduce using rule 32 (args -> noargs .)


state 160

    (31) args -> neargs .

    RPAR            reduce using rule 31 (args -> neargs .)


state 161

    (33) noargs -> empty .

    RPAR            reduce using rule 33 (noargs -> empty .)


state 162

    (64) modulefunccall -> CID LPAR args . RPAR

    RPAR            shift and go to state 182


state 163

    (34) neargs -> exp .
    (35) neargs -> exp . COMMA neargs
    (73) exp -> exp . PLUS exp
    (74) exp -> exp . TIMES exp
    (75) exp -> exp . MINUS exp
    (76) exp -> exp . BY exp

    RPAR            reduce using rule 34 (neargs -> exp .)
    COMMA           shift and go to state 183
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138


state 164

    (30) funccall -> varname LPAR args . RPAR

    RPAR            shift and go to state 184


state 165

    (76) exp -> exp BY exp .
    (73) exp -> exp . PLUS exp
    (74) exp -> exp . TIMES exp
    (75) exp -> exp . MINUS exp
    (76) exp -> exp . BY exp

    NL              reduce using rule 76 (exp -> exp BY exp .)
    PLUS            reduce using rule 76 (exp -> exp BY exp .)
    TIMES           reduce using rule 76 (exp -> exp BY exp .)
    MINUS           reduce using rule 76 (exp -> exp BY exp .)
    BY              reduce using rule 76 (exp -> exp BY exp .)
    RPAR            reduce using rule 76 (exp -> exp BY exp .)
    COMMA           reduce using rule 76 (exp -> exp BY exp .)
    COLON           reduce using rule 76 (exp -> exp BY exp .)
    RBRACE          reduce using rule 76 (exp -> exp BY exp .)
    AND             reduce using rule 76 (exp -> exp BY exp .)
    OR              reduce using rule 76 (exp -> exp BY exp .)
    EQ              reduce using rule 76 (exp -> exp BY exp .)
    NEQ             reduce using rule 76 (exp -> exp BY exp .)
    GEQ             reduce using rule 76 (exp -> exp BY exp .)
    LEQ             reduce using rule 76 (exp -> exp BY exp .)
    GT              reduce using rule 76 (exp -> exp BY exp .)
    LT              reduce using rule 76 (exp -> exp BY exp .)

  ! PLUS            [ shift and go to state 139 ]
  ! TIMES           [ shift and go to state 140 ]
  ! MINUS           [ shift and go to state 141 ]
  ! BY              [ shift and go to state 138 ]


state 166

    (73) exp -> exp PLUS exp .
    (73) exp -> exp . PLUS exp
    (74) exp -> exp . TIMES exp
    (75) exp -> exp . MINUS exp
    (76) exp -> exp . BY exp

    NL              reduce using rule 73 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 73 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 73 (exp -> exp PLUS exp .)
    RPAR            reduce using rule 73 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 73 (exp -> exp PLUS exp .)
    COLON           reduce using rule 73 (exp -> exp PLUS exp .)
    RBRACE          reduce using rule 73 (exp -> exp PLUS exp .)
    AND             reduce using rule 73 (exp -> exp PLUS exp .)
    OR              reduce using rule 73 (exp -> exp PLUS exp .)
    EQ              reduce using rule 73 (exp -> exp PLUS exp .)
    NEQ             reduce using rule 73 (exp -> exp PLUS exp .)
    GEQ             reduce using rule 73 (exp -> exp PLUS exp .)
    LEQ             reduce using rule 73 (exp -> exp PLUS exp .)
    GT              reduce using rule 73 (exp -> exp PLUS exp .)
    LT              reduce using rule 73 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 140
    BY              shift and go to state 138

  ! TIMES           [ reduce using rule 73 (exp -> exp PLUS exp .) ]
  ! BY              [ reduce using rule 73 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 141 ]


state 167

    (74) exp -> exp TIMES exp .
    (73) exp -> exp . PLUS exp
    (74) exp -> exp . TIMES exp
    (75) exp -> exp . MINUS exp
    (76) exp -> exp . BY exp

    NL              reduce using rule 74 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 74 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 74 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 74 (exp -> exp TIMES exp .)
    BY              reduce using rule 74 (exp -> exp TIMES exp .)
    RPAR            reduce using rule 74 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 74 (exp -> exp TIMES exp .)
    COLON           reduce using rule 74 (exp -> exp TIMES exp .)
    RBRACE          reduce using rule 74 (exp -> exp TIMES exp .)
    AND             reduce using rule 74 (exp -> exp TIMES exp .)
    OR              reduce using rule 74 (exp -> exp TIMES exp .)
    EQ              reduce using rule 74 (exp -> exp TIMES exp .)
    NEQ             reduce using rule 74 (exp -> exp TIMES exp .)
    GEQ             reduce using rule 74 (exp -> exp TIMES exp .)
    LEQ             reduce using rule 74 (exp -> exp TIMES exp .)
    GT              reduce using rule 74 (exp -> exp TIMES exp .)
    LT              reduce using rule 74 (exp -> exp TIMES exp .)

  ! PLUS            [ shift and go to state 139 ]
  ! TIMES           [ shift and go to state 140 ]
  ! MINUS           [ shift and go to state 141 ]
  ! BY              [ shift and go to state 138 ]


state 168

    (75) exp -> exp MINUS exp .
    (73) exp -> exp . PLUS exp
    (74) exp -> exp . TIMES exp
    (75) exp -> exp . MINUS exp
    (76) exp -> exp . BY exp

    NL              reduce using rule 75 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 75 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 75 (exp -> exp MINUS exp .)
    RPAR            reduce using rule 75 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 75 (exp -> exp MINUS exp .)
    COLON           reduce using rule 75 (exp -> exp MINUS exp .)
    RBRACE          reduce using rule 75 (exp -> exp MINUS exp .)
    AND             reduce using rule 75 (exp -> exp MINUS exp .)
    OR              reduce using rule 75 (exp -> exp MINUS exp .)
    EQ              reduce using rule 75 (exp -> exp MINUS exp .)
    NEQ             reduce using rule 75 (exp -> exp MINUS exp .)
    GEQ             reduce using rule 75 (exp -> exp MINUS exp .)
    LEQ             reduce using rule 75 (exp -> exp MINUS exp .)
    GT              reduce using rule 75 (exp -> exp MINUS exp .)
    LT              reduce using rule 75 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 140
    BY              shift and go to state 138

  ! TIMES           [ reduce using rule 75 (exp -> exp MINUS exp .) ]
  ! BY              [ reduce using rule 75 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 141 ]


state 169

    (11) actuatordecls -> ACTUATORS COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 185


state 170

    (13) sensordecls -> SENSORS COLON NL INDENT . decls DEDENT
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN
    (41) type -> . INPUTMAP

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 42
    STRING          shift and go to state 40
    FLOAT           shift and go to state 43
    IPOS            shift and go to state 44
    BOOLEAN         shift and go to state 45
    INPUTMAP        shift and go to state 41

    decl                           shift and go to state 39
    decls                          shift and go to state 186
    type                           shift and go to state 46
    empty                          shift and go to state 48

state 171

    (27) rvdecl -> type varname LBRACE owner RBRACE NL .

    INT             reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    STRING          reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    FLOAT           reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    IPOS            reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    BOOLEAN         reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    INPUTMAP        reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    DEDENT          reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)


state 172

    (61) stmt -> ATOMIC COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 187


state 173

    (70) stagechange -> STAGE ASGN varname . NL

    NL              shift and go to state 188


state 174

    (49) cond -> LPAR cond . AND cond RPAR
    (50) cond -> LPAR cond . OR cond RPAR
    (51) cond -> LPAR cond . op cond RPAR
    (94) op -> . EQ
    (95) op -> . NEQ
    (96) op -> . GEQ
    (97) op -> . LEQ
    (98) op -> . GT
    (99) op -> . LT

    AND             shift and go to state 189
    OR              shift and go to state 196
    EQ              shift and go to state 195
    NEQ             shift and go to state 194
    GEQ             shift and go to state 190
    LEQ             shift and go to state 192
    GT              shift and go to state 191
    LT              shift and go to state 193

    op                             shift and go to state 197

state 175

    (86) bracketexp -> LPAR exp . RPAR
    (53) cond -> exp .
    (73) exp -> exp . PLUS exp
    (74) exp -> exp . TIMES exp
    (75) exp -> exp . MINUS exp
    (76) exp -> exp . BY exp

    RPAR            shift and go to state 158
    AND             reduce using rule 53 (cond -> exp .)
    OR              reduce using rule 53 (cond -> exp .)
    EQ              reduce using rule 53 (cond -> exp .)
    NEQ             reduce using rule 53 (cond -> exp .)
    GEQ             reduce using rule 53 (cond -> exp .)
    LEQ             reduce using rule 53 (cond -> exp .)
    GT              reduce using rule 53 (cond -> exp .)
    LT              reduce using rule 53 (cond -> exp .)
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138


state 176

    (52) cond -> LPAR NOT . cond RPAR
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . exp
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 151
    STAGE           shift and go to state 102
    LID             shift and go to state 91
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    cond                           shift and go to state 198
    exp                            shift and go to state 153
    bval                           shift and go to state 98

state 177

    (62) stmt -> IF cond COLON . NL INDENT stmts DEDENT elseblock

    NL              shift and go to state 199


state 178

    (67) asgn -> varname ASGN exp . NL
    (73) exp -> exp . PLUS exp
    (74) exp -> exp . TIMES exp
    (75) exp -> exp . MINUS exp
    (76) exp -> exp . BY exp

    NL              shift and go to state 200
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138


state 179

    (71) wptstmt -> varname ASGN GETINPUT . LPAR RPAR NL

    LPAR            shift and go to state 201


state 180

    (46) event -> LID COLON NL INDENT PRE COLON . cond NL effblock DEDENT
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . exp
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 151
    STAGE           shift and go to state 102
    LID             shift and go to state 91
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    cond                           shift and go to state 202
    exp                            shift and go to state 153
    bval                           shift and go to state 98

state 181

    (81) exp -> LID LBRACE exp RBRACE .

    NL              reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    PLUS            reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    TIMES           reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    MINUS           reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    BY              reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    RPAR            reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    COMMA           reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    COLON           reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    RBRACE          reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    AND             reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    OR              reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    EQ              reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    NEQ             reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    GEQ             reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    LEQ             reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    GT              reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)
    LT              reduce using rule 81 (exp -> LID LBRACE exp RBRACE .)


state 182

    (64) modulefunccall -> CID LPAR args RPAR .

    PLUS            reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    TIMES           reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    MINUS           reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    BY              reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    RPAR            reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    NL              reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    COLON           reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    RBRACE          reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    COMMA           reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    AND             reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    OR              reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    EQ              reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    NEQ             reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    GEQ             reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    LEQ             reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    GT              reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)
    LT              reduce using rule 64 (modulefunccall -> CID LPAR args RPAR .)


state 183

    (35) neargs -> exp COMMA . neargs
    (34) neargs -> . exp
    (35) neargs -> . exp COMMA neargs
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 102
    LID             shift and go to state 91
    LPAR            shift and go to state 92
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    exp                            shift and go to state 163
    neargs                         shift and go to state 203
    bval                           shift and go to state 98

state 184

    (30) funccall -> varname LPAR args RPAR .

    COMMA           reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    PLUS            reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    TIMES           reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    MINUS           reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    BY              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    RPAR            reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    NL              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    AND             reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    OR              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    EQ              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    NEQ             reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    GEQ             reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    LEQ             reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    GT              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    LT              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    COLON           reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    RBRACE          reduce using rule 30 (funccall -> varname LPAR args RPAR .)


state 185

    (11) actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT .

    SENSORS         reduce using rule 11 (actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT .)
    DEDENT          reduce using rule 11 (actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT .)


state 186

    (13) sensordecls -> SENSORS COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 204


state 187

    (61) stmt -> ATOMIC COLON NL INDENT . stmts DEDENT
    (54) stmts -> . stmt stmts
    (55) stmts -> . stmt
    (56) stmt -> . asgn
    (57) stmt -> . wptstmt
    (58) stmt -> . exit
    (59) stmt -> . funccall NL
    (60) stmt -> . modulefunccall NL
    (61) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (62) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (67) asgn -> . varname ASGN exp NL
    (68) asgn -> . stagechange
    (71) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (63) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR
    (92) varname -> . LID
    (70) stagechange -> . STAGE ASGN varname NL

    ATOMIC          shift and go to state 116
    IF              shift and go to state 124
    EXIT            shift and go to state 128
    CID             shift and go to state 94
    LID             shift and go to state 61
    STAGE           shift and go to state 120

    stagechange                    shift and go to state 125
    funccall                       shift and go to state 121
    stmts                          shift and go to state 205
    varname                        shift and go to state 126
    stmt                           shift and go to state 123
    asgn                           shift and go to state 118
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    exit                           shift and go to state 119

state 188

    (70) stagechange -> STAGE ASGN varname NL .

    ATOMIC          reduce using rule 70 (stagechange -> STAGE ASGN varname NL .)
    IF              reduce using rule 70 (stagechange -> STAGE ASGN varname NL .)
    EXIT            reduce using rule 70 (stagechange -> STAGE ASGN varname NL .)
    CID             reduce using rule 70 (stagechange -> STAGE ASGN varname NL .)
    LID             reduce using rule 70 (stagechange -> STAGE ASGN varname NL .)
    STAGE           reduce using rule 70 (stagechange -> STAGE ASGN varname NL .)
    DEDENT          reduce using rule 70 (stagechange -> STAGE ASGN varname NL .)


state 189

    (49) cond -> LPAR cond AND . cond RPAR
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . exp
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 151
    STAGE           shift and go to state 102
    LID             shift and go to state 91
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    cond                           shift and go to state 206
    exp                            shift and go to state 153
    bval                           shift and go to state 98

state 190

    (96) op -> GEQ .

    LPAR            reduce using rule 96 (op -> GEQ .)
    STAGE           reduce using rule 96 (op -> GEQ .)
    LID             reduce using rule 96 (op -> GEQ .)
    TRUE            reduce using rule 96 (op -> GEQ .)
    FALSE           reduce using rule 96 (op -> GEQ .)
    PID             reduce using rule 96 (op -> GEQ .)
    INUM            reduce using rule 96 (op -> GEQ .)
    FNUM            reduce using rule 96 (op -> GEQ .)
    NULL            reduce using rule 96 (op -> GEQ .)
    CID             reduce using rule 96 (op -> GEQ .)


state 191

    (98) op -> GT .

    LPAR            reduce using rule 98 (op -> GT .)
    STAGE           reduce using rule 98 (op -> GT .)
    LID             reduce using rule 98 (op -> GT .)
    TRUE            reduce using rule 98 (op -> GT .)
    FALSE           reduce using rule 98 (op -> GT .)
    PID             reduce using rule 98 (op -> GT .)
    INUM            reduce using rule 98 (op -> GT .)
    FNUM            reduce using rule 98 (op -> GT .)
    NULL            reduce using rule 98 (op -> GT .)
    CID             reduce using rule 98 (op -> GT .)


state 192

    (97) op -> LEQ .

    LPAR            reduce using rule 97 (op -> LEQ .)
    STAGE           reduce using rule 97 (op -> LEQ .)
    LID             reduce using rule 97 (op -> LEQ .)
    TRUE            reduce using rule 97 (op -> LEQ .)
    FALSE           reduce using rule 97 (op -> LEQ .)
    PID             reduce using rule 97 (op -> LEQ .)
    INUM            reduce using rule 97 (op -> LEQ .)
    FNUM            reduce using rule 97 (op -> LEQ .)
    NULL            reduce using rule 97 (op -> LEQ .)
    CID             reduce using rule 97 (op -> LEQ .)


state 193

    (99) op -> LT .

    LPAR            reduce using rule 99 (op -> LT .)
    STAGE           reduce using rule 99 (op -> LT .)
    LID             reduce using rule 99 (op -> LT .)
    TRUE            reduce using rule 99 (op -> LT .)
    FALSE           reduce using rule 99 (op -> LT .)
    PID             reduce using rule 99 (op -> LT .)
    INUM            reduce using rule 99 (op -> LT .)
    FNUM            reduce using rule 99 (op -> LT .)
    NULL            reduce using rule 99 (op -> LT .)
    CID             reduce using rule 99 (op -> LT .)


state 194

    (95) op -> NEQ .

    LPAR            reduce using rule 95 (op -> NEQ .)
    STAGE           reduce using rule 95 (op -> NEQ .)
    LID             reduce using rule 95 (op -> NEQ .)
    TRUE            reduce using rule 95 (op -> NEQ .)
    FALSE           reduce using rule 95 (op -> NEQ .)
    PID             reduce using rule 95 (op -> NEQ .)
    INUM            reduce using rule 95 (op -> NEQ .)
    FNUM            reduce using rule 95 (op -> NEQ .)
    NULL            reduce using rule 95 (op -> NEQ .)
    CID             reduce using rule 95 (op -> NEQ .)


state 195

    (94) op -> EQ .

    LPAR            reduce using rule 94 (op -> EQ .)
    STAGE           reduce using rule 94 (op -> EQ .)
    LID             reduce using rule 94 (op -> EQ .)
    TRUE            reduce using rule 94 (op -> EQ .)
    FALSE           reduce using rule 94 (op -> EQ .)
    PID             reduce using rule 94 (op -> EQ .)
    INUM            reduce using rule 94 (op -> EQ .)
    FNUM            reduce using rule 94 (op -> EQ .)
    NULL            reduce using rule 94 (op -> EQ .)
    CID             reduce using rule 94 (op -> EQ .)


state 196

    (50) cond -> LPAR cond OR . cond RPAR
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . exp
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 151
    STAGE           shift and go to state 102
    LID             shift and go to state 91
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    cond                           shift and go to state 207
    exp                            shift and go to state 153
    bval                           shift and go to state 98

state 197

    (51) cond -> LPAR cond op . cond RPAR
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . exp
    (72) exp -> . bracketexp
    (73) exp -> . exp PLUS exp
    (74) exp -> . exp TIMES exp
    (75) exp -> . exp MINUS exp
    (76) exp -> . exp BY exp
    (77) exp -> . varname
    (78) exp -> . STAGE
    (79) exp -> . bval
    (80) exp -> . pid
    (81) exp -> . LID LBRACE exp RBRACE
    (82) exp -> . num
    (83) exp -> . null
    (84) exp -> . funccall
    (85) exp -> . modulefunccall
    (86) bracketexp -> . LPAR exp RPAR
    (92) varname -> . LID
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (91) pid -> . PID
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 151
    STAGE           shift and go to state 102
    LID             shift and go to state 91
    TRUE            shift and go to state 100
    FALSE           shift and go to state 106
    PID             shift and go to state 101
    INUM            shift and go to state 109
    FNUM            shift and go to state 95
    NULL            shift and go to state 105
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    funccall                       shift and go to state 103
    modulefunccall                 shift and go to state 104
    varname                        shift and go to state 107
    pid                            shift and go to state 96
    null                           shift and go to state 99
    num                            shift and go to state 97
    cond                           shift and go to state 208
    exp                            shift and go to state 153
    bval                           shift and go to state 98

state 198

    (52) cond -> LPAR NOT cond . RPAR

    RPAR            shift and go to state 209


state 199

    (62) stmt -> IF cond COLON NL . INDENT stmts DEDENT elseblock

    INDENT          shift and go to state 210


state 200

    (67) asgn -> varname ASGN exp NL .

    ATOMIC          reduce using rule 67 (asgn -> varname ASGN exp NL .)
    IF              reduce using rule 67 (asgn -> varname ASGN exp NL .)
    EXIT            reduce using rule 67 (asgn -> varname ASGN exp NL .)
    CID             reduce using rule 67 (asgn -> varname ASGN exp NL .)
    LID             reduce using rule 67 (asgn -> varname ASGN exp NL .)
    STAGE           reduce using rule 67 (asgn -> varname ASGN exp NL .)
    DEDENT          reduce using rule 67 (asgn -> varname ASGN exp NL .)


state 201

    (71) wptstmt -> varname ASGN GETINPUT LPAR . RPAR NL

    RPAR            shift and go to state 211


state 202

    (46) event -> LID COLON NL INDENT PRE COLON cond . NL effblock DEDENT

    NL              shift and go to state 212


state 203

    (35) neargs -> exp COMMA neargs .

    RPAR            reduce using rule 35 (neargs -> exp COMMA neargs .)


state 204

    (13) sensordecls -> SENSORS COLON NL INDENT decls DEDENT .

    DEDENT          reduce using rule 13 (sensordecls -> SENSORS COLON NL INDENT decls DEDENT .)


state 205

    (61) stmt -> ATOMIC COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 213


state 206

    (49) cond -> LPAR cond AND cond . RPAR

    RPAR            shift and go to state 214


state 207

    (50) cond -> LPAR cond OR cond . RPAR

    RPAR            shift and go to state 215


state 208

    (51) cond -> LPAR cond op cond . RPAR

    RPAR            shift and go to state 216


state 209

    (52) cond -> LPAR NOT cond RPAR .

    NL              reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    RPAR            reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    COLON           reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    AND             reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    OR              reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    EQ              reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    NEQ             reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    GEQ             reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    LEQ             reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    GT              reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    LT              reduce using rule 52 (cond -> LPAR NOT cond RPAR .)


state 210

    (62) stmt -> IF cond COLON NL INDENT . stmts DEDENT elseblock
    (54) stmts -> . stmt stmts
    (55) stmts -> . stmt
    (56) stmt -> . asgn
    (57) stmt -> . wptstmt
    (58) stmt -> . exit
    (59) stmt -> . funccall NL
    (60) stmt -> . modulefunccall NL
    (61) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (62) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (67) asgn -> . varname ASGN exp NL
    (68) asgn -> . stagechange
    (71) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (63) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR
    (92) varname -> . LID
    (70) stagechange -> . STAGE ASGN varname NL

    ATOMIC          shift and go to state 116
    IF              shift and go to state 124
    EXIT            shift and go to state 128
    CID             shift and go to state 94
    LID             shift and go to state 61
    STAGE           shift and go to state 120

    stagechange                    shift and go to state 125
    funccall                       shift and go to state 121
    stmts                          shift and go to state 217
    varname                        shift and go to state 126
    stmt                           shift and go to state 123
    asgn                           shift and go to state 118
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    exit                           shift and go to state 119

state 211

    (71) wptstmt -> varname ASGN GETINPUT LPAR RPAR . NL

    NL              shift and go to state 218


state 212

    (46) event -> LID COLON NL INDENT PRE COLON cond NL . effblock DEDENT
    (47) effblock -> . EFF COLON NL INDENT stmts DEDENT
    (48) effblock -> . EFF COLON stmt

    EFF             shift and go to state 220

    effblock                       shift and go to state 219

state 213

    (61) stmt -> ATOMIC COLON NL INDENT stmts DEDENT .

    ATOMIC          reduce using rule 61 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    IF              reduce using rule 61 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    EXIT            reduce using rule 61 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    CID             reduce using rule 61 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    LID             reduce using rule 61 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    STAGE           reduce using rule 61 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    DEDENT          reduce using rule 61 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)


state 214

    (49) cond -> LPAR cond AND cond RPAR .

    NL              reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    RPAR            reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    COLON           reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    AND             reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    OR              reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    EQ              reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    NEQ             reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    GEQ             reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    LEQ             reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    GT              reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    LT              reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)


state 215

    (50) cond -> LPAR cond OR cond RPAR .

    NL              reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    RPAR            reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    COLON           reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    AND             reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    OR              reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    EQ              reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    NEQ             reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    GEQ             reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    LEQ             reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    GT              reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    LT              reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)


state 216

    (51) cond -> LPAR cond op cond RPAR .

    NL              reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    RPAR            reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    COLON           reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    AND             reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    OR              reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    EQ              reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    NEQ             reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    GEQ             reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    LEQ             reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    GT              reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    LT              reduce using rule 51 (cond -> LPAR cond op cond RPAR .)


state 217

    (62) stmt -> IF cond COLON NL INDENT stmts . DEDENT elseblock

    DEDENT          shift and go to state 221


state 218

    (71) wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .

    ATOMIC          reduce using rule 71 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    IF              reduce using rule 71 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    EXIT            reduce using rule 71 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    CID             reduce using rule 71 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    LID             reduce using rule 71 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    STAGE           reduce using rule 71 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    DEDENT          reduce using rule 71 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)


state 219

    (46) event -> LID COLON NL INDENT PRE COLON cond NL effblock . DEDENT

    DEDENT          shift and go to state 222


state 220

    (47) effblock -> EFF . COLON NL INDENT stmts DEDENT
    (48) effblock -> EFF . COLON stmt

    COLON           shift and go to state 223


state 221

    (62) stmt -> IF cond COLON NL INDENT stmts DEDENT . elseblock
    (65) elseblock -> . ELSE COLON NL INDENT stmts DEDENT
    (66) elseblock -> . empty
    (100) empty -> .

    ELSE            shift and go to state 225
    ATOMIC          reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    EXIT            reduce using rule 100 (empty -> .)
    CID             reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)
    STAGE           reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

    elseblock                      shift and go to state 224
    empty                          shift and go to state 226

state 222

    (46) event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .

    LID             reduce using rule 46 (event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .)
    NUM             reduce using rule 46 (event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .)


state 223

    (47) effblock -> EFF COLON . NL INDENT stmts DEDENT
    (48) effblock -> EFF COLON . stmt
    (56) stmt -> . asgn
    (57) stmt -> . wptstmt
    (58) stmt -> . exit
    (59) stmt -> . funccall NL
    (60) stmt -> . modulefunccall NL
    (61) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (62) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (67) asgn -> . varname ASGN exp NL
    (68) asgn -> . stagechange
    (71) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (63) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR
    (92) varname -> . LID
    (70) stagechange -> . STAGE ASGN varname NL

    NL              shift and go to state 227
    ATOMIC          shift and go to state 116
    IF              shift and go to state 124
    EXIT            shift and go to state 128
    CID             shift and go to state 94
    LID             shift and go to state 61
    STAGE           shift and go to state 120

    stagechange                    shift and go to state 125
    funccall                       shift and go to state 121
    varname                        shift and go to state 126
    stmt                           shift and go to state 228
    asgn                           shift and go to state 118
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    exit                           shift and go to state 119

state 224

    (62) stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .

    ATOMIC          reduce using rule 62 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    IF              reduce using rule 62 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    EXIT            reduce using rule 62 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    CID             reduce using rule 62 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    LID             reduce using rule 62 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    STAGE           reduce using rule 62 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    DEDENT          reduce using rule 62 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)


state 225

    (65) elseblock -> ELSE . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 229


state 226

    (66) elseblock -> empty .

    ATOMIC          reduce using rule 66 (elseblock -> empty .)
    IF              reduce using rule 66 (elseblock -> empty .)
    EXIT            reduce using rule 66 (elseblock -> empty .)
    CID             reduce using rule 66 (elseblock -> empty .)
    LID             reduce using rule 66 (elseblock -> empty .)
    STAGE           reduce using rule 66 (elseblock -> empty .)
    DEDENT          reduce using rule 66 (elseblock -> empty .)


state 227

    (47) effblock -> EFF COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 230


state 228

    (48) effblock -> EFF COLON stmt .

    DEDENT          reduce using rule 48 (effblock -> EFF COLON stmt .)


state 229

    (65) elseblock -> ELSE COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 231


state 230

    (47) effblock -> EFF COLON NL INDENT . stmts DEDENT
    (54) stmts -> . stmt stmts
    (55) stmts -> . stmt
    (56) stmt -> . asgn
    (57) stmt -> . wptstmt
    (58) stmt -> . exit
    (59) stmt -> . funccall NL
    (60) stmt -> . modulefunccall NL
    (61) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (62) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (67) asgn -> . varname ASGN exp NL
    (68) asgn -> . stagechange
    (71) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (63) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR
    (92) varname -> . LID
    (70) stagechange -> . STAGE ASGN varname NL

    ATOMIC          shift and go to state 116
    IF              shift and go to state 124
    EXIT            shift and go to state 128
    CID             shift and go to state 94
    LID             shift and go to state 61
    STAGE           shift and go to state 120

    stagechange                    shift and go to state 125
    funccall                       shift and go to state 121
    stmts                          shift and go to state 232
    varname                        shift and go to state 126
    stmt                           shift and go to state 123
    asgn                           shift and go to state 118
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    exit                           shift and go to state 119

state 231

    (65) elseblock -> ELSE COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 233


state 232

    (47) effblock -> EFF COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 234


state 233

    (65) elseblock -> ELSE COLON NL INDENT . stmts DEDENT
    (54) stmts -> . stmt stmts
    (55) stmts -> . stmt
    (56) stmt -> . asgn
    (57) stmt -> . wptstmt
    (58) stmt -> . exit
    (59) stmt -> . funccall NL
    (60) stmt -> . modulefunccall NL
    (61) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (62) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (67) asgn -> . varname ASGN exp NL
    (68) asgn -> . stagechange
    (71) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (63) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (64) modulefunccall -> . CID LPAR args RPAR
    (92) varname -> . LID
    (70) stagechange -> . STAGE ASGN varname NL

    ATOMIC          shift and go to state 116
    IF              shift and go to state 124
    EXIT            shift and go to state 128
    CID             shift and go to state 94
    LID             shift and go to state 61
    STAGE           shift and go to state 120

    stagechange                    shift and go to state 125
    funccall                       shift and go to state 121
    stmts                          shift and go to state 235
    varname                        shift and go to state 126
    stmt                           shift and go to state 123
    asgn                           shift and go to state 118
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    exit                           shift and go to state 119

state 234

    (47) effblock -> EFF COLON NL INDENT stmts DEDENT .

    DEDENT          reduce using rule 47 (effblock -> EFF COLON NL INDENT stmts DEDENT .)


state 235

    (65) elseblock -> ELSE COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 236


state 236

    (65) elseblock -> ELSE COLON NL INDENT stmts DEDENT .

    ATOMIC          reduce using rule 65 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    IF              reduce using rule 65 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    EXIT            reduce using rule 65 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    CID             reduce using rule 65 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    LID             reduce using rule 65 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    STAGE           reduce using rule 65 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    DEDENT          reduce using rule 65 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)

