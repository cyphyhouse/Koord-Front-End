Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Unused terminals:

    WS
    MAP

Grammar

Rule 0     S' -> program
Rule 1     program -> agent modules awdecls ardecls locdecls stagedecl init events Numdecl
Rule 2     Numdecl -> NUM INUM NL
Rule 3     stagedecl -> DEF STAGE LCURLY stagelist RCURLY NL
Rule 4     stagedecl -> empty
Rule 5     stagelist -> LID COMMA stagelist
Rule 6     stagelist -> LID
Rule 7     agent -> AGENT CID NL
Rule 8     modules -> module modules
Rule 9     modules -> empty
Rule 10    module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT
Rule 11    actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT
Rule 12    actuatordecls -> empty
Rule 13    sensordecls -> SENSORS COLON NL INDENT decls DEDENT
Rule 14    sensordecls -> empty
Rule 15    awdecls -> ALLWRITE COLON NL INDENT decls DEDENT
Rule 16    awdecls -> empty
Rule 17    ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT
Rule 18    ardecls -> empty
Rule 19    locdecls -> LOCAL COLON NL INDENT decls DEDENT
Rule 20    locdecls -> empty
Rule 21    decls -> decl decls
Rule 22    decls -> empty
Rule 23    decl -> type varname ASGN exp NL
Rule 24    decl -> type varname NL
Rule 25    rvdecls -> rvdecl rvdecls
Rule 26    rvdecls -> empty
Rule 27    rvdecl -> type varname LBRACE owner RBRACE NL
Rule 28    owner -> TIMES
Rule 29    owner -> INUM
Rule 30    funccall -> varname LPAR args RPAR
Rule 31    args -> neargs
Rule 32    args -> noargs
Rule 33    noargs -> empty
Rule 34    neargs -> exp
Rule 35    neargs -> exp COMMA neargs
Rule 36    type -> INT
Rule 37    type -> STRING
Rule 38    type -> FLOAT
Rule 39    type -> IPOS
Rule 40    type -> BOOLEAN
Rule 41    init -> INIT COLON NL INDENT stmts DEDENT
Rule 42    init -> empty
Rule 43    events -> event events
Rule 44    events -> empty
Rule 45    event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT
Rule 46    event -> LID COLON NL INDENT PRE COLON CID NL effblock DEDENT
Rule 47    effblock -> EFF COLON NL INDENT stmts DEDENT
Rule 48    effblock -> EFF COLON stmt
Rule 49    cond -> LPAR cond AND cond RPAR
Rule 50    cond -> LPAR cond OR cond RPAR
Rule 51    cond -> LPAR cond op cond RPAR
Rule 52    cond -> LPAR NOT cond RPAR
Rule 53    cond -> LPAR cond RPAR
Rule 54    cond -> exp
Rule 55    stmts -> stmt stmts
Rule 56    stmts -> empty
Rule 57    stmt -> asgn
Rule 58    stmt -> wptstmt
Rule 59    stmt -> pass
Rule 60    stmt -> EXIT NL
Rule 61    stmt -> funccall NL
Rule 62    stmt -> modulefunccall NL
Rule 63    stmt -> ATOMIC COLON NL INDENT stmts DEDENT
Rule 64    stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock
Rule 65    modulefunccall -> CID LPAR args RPAR
Rule 66    elseblock -> ELSE COLON NL INDENT stmts DEDENT
Rule 67    elseblock -> empty
Rule 68    pass -> PASS NL
Rule 69    asgn -> varname ASGN exp NL
Rule 70    wptstmt -> varname ASGN GETINPUT LPAR RPAR NL
Rule 71    exp -> bracketexp
Rule 72    exp -> exp PLUS exp
Rule 73    exp -> exp TIMES exp
Rule 74    exp -> exp MINUS exp
Rule 75    exp -> exp BY exp
Rule 76    exp -> varname
Rule 77    exp -> varname LBRACE exp RBRACE
Rule 78    exp -> bval
Rule 79    exp -> PID
Rule 80    exp -> num
Rule 81    exp -> null
Rule 82    exp -> moduleflag
Rule 83    exp -> funccall
Rule 84    exp -> modulefunccall
Rule 85    bracketexp -> LPAR exp RPAR
Rule 86    moduleflag -> CID
Rule 87    bval -> TRUE
Rule 88    bval -> FALSE
Rule 89    num -> INUM
Rule 90    num -> FNUM
Rule 91    varname -> LID
Rule 92    varname -> STAGE
Rule 93    null -> NULL
Rule 94    op -> EQ
Rule 95    op -> NEQ
Rule 96    op -> GEQ
Rule 97    op -> LEQ
Rule 98    op -> GT
Rule 99    op -> LT
Rule 100   empty -> <empty>

Terminals, with rules where they appear

ACTUATORS            : 11
AGENT                : 7
ALLREAD              : 17
ALLWRITE             : 15
AND                  : 49
ASGN                 : 23 69 70
ATOMIC               : 63
BOOLEAN              : 40
BY                   : 75
CID                  : 7 10 46 65 86
COLON                : 10 11 13 15 17 19 41 45 45 46 46 47 48 63 64 66
COMMA                : 5 35
DEDENT               : 10 11 13 15 17 19 41 45 46 47 63 64 66
DEF                  : 3
EFF                  : 47 48
ELSE                 : 66
EQ                   : 94
EXIT                 : 60
FALSE                : 88
FLOAT                : 38
FNUM                 : 90
GEQ                  : 96
GETINPUT             : 70
GT                   : 98
IF                   : 64
INDENT               : 10 11 13 15 17 19 41 45 46 47 63 64 66
INIT                 : 41
INT                  : 36
INUM                 : 2 29 89
IPOS                 : 39
LBRACE               : 27 77
LCURLY               : 3
LEQ                  : 97
LID                  : 5 6 45 46 91
LOCAL                : 19
LPAR                 : 30 49 50 51 52 53 65 70 85
LT                   : 99
MAP                  : 
MINUS                : 74
MODULE               : 10
NEQ                  : 95
NL                   : 2 3 7 10 11 13 15 17 19 23 24 27 41 45 45 46 46 47 60 61 62 63 64 66 68 69 70
NOT                  : 52
NULL                 : 93
NUM                  : 2
OR                   : 50
PASS                 : 68
PID                  : 79
PLUS                 : 72
PRE                  : 45 46
RBRACE               : 27 77
RCURLY               : 3
RPAR                 : 30 49 50 51 52 53 65 70 85
SENSORS              : 13
STAGE                : 3 92
STRING               : 37
TIMES                : 28 73
TRUE                 : 87
USING                : 10
WS                   : 
error                : 

Nonterminals, with rules where they appear

Numdecl              : 1
actuatordecls        : 10
agent                : 1
ardecls              : 1
args                 : 30 65
asgn                 : 57
awdecls              : 1
bracketexp           : 71
bval                 : 78
cond                 : 45 49 49 50 50 51 51 52 53 64
decl                 : 21
decls                : 11 13 15 19 21
effblock             : 45 46
elseblock            : 64
empty                : 4 9 12 14 16 18 20 22 26 33 42 44 56 67
event                : 43
events               : 1 43
exp                  : 23 34 35 54 69 72 72 73 73 74 74 75 75 77 85
funccall             : 61 83
init                 : 1
locdecls             : 1
module               : 8
moduleflag           : 82
modulefunccall       : 62 84
modules              : 1 8
neargs               : 31 35
noargs               : 32
null                 : 81
num                  : 80
op                   : 51
owner                : 27
pass                 : 59
program              : 0
rvdecl               : 25
rvdecls              : 17 25
sensordecls          : 10
stagedecl            : 1
stagelist            : 3 5
stmt                 : 48 55
stmts                : 41 47 55 63 64 66
type                 : 23 24 27
varname              : 23 24 27 30 69 70 76 77
wptstmt              : 58

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . agent modules awdecls ardecls locdecls stagedecl init events Numdecl
    (7) agent -> . AGENT CID NL

    AGENT           shift and go to state 1

    agent                          shift and go to state 2
    program                        shift and go to state 3

state 1

    (7) agent -> AGENT . CID NL

    CID             shift and go to state 4


state 2

    (1) program -> agent . modules awdecls ardecls locdecls stagedecl init events Numdecl
    (8) modules -> . module modules
    (9) modules -> . empty
    (10) module -> . USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT
    (100) empty -> .

    USING           shift and go to state 7
    ALLWRITE        reduce using rule 100 (empty -> .)
    ALLREAD         reduce using rule 100 (empty -> .)
    LOCAL           reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    INIT            reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)
    NUM             reduce using rule 100 (empty -> .)

    module                         shift and go to state 5
    modules                        shift and go to state 6
    empty                          shift and go to state 8

state 3

    (0) S' -> program .



state 4

    (7) agent -> AGENT CID . NL

    NL              shift and go to state 9


state 5

    (8) modules -> module . modules
    (8) modules -> . module modules
    (9) modules -> . empty
    (10) module -> . USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT
    (100) empty -> .

    USING           shift and go to state 7
    ALLWRITE        reduce using rule 100 (empty -> .)
    ALLREAD         reduce using rule 100 (empty -> .)
    LOCAL           reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    INIT            reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)
    NUM             reduce using rule 100 (empty -> .)

    modules                        shift and go to state 10
    empty                          shift and go to state 8
    module                         shift and go to state 5

state 6

    (1) program -> agent modules . awdecls ardecls locdecls stagedecl init events Numdecl
    (15) awdecls -> . ALLWRITE COLON NL INDENT decls DEDENT
    (16) awdecls -> . empty
    (100) empty -> .

    ALLWRITE        shift and go to state 12
    ALLREAD         reduce using rule 100 (empty -> .)
    LOCAL           reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    INIT            reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)
    NUM             reduce using rule 100 (empty -> .)

    awdecls                        shift and go to state 11
    empty                          shift and go to state 13

state 7

    (10) module -> USING . MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT

    MODULE          shift and go to state 14


state 8

    (9) modules -> empty .

    ALLWRITE        reduce using rule 9 (modules -> empty .)
    ALLREAD         reduce using rule 9 (modules -> empty .)
    LOCAL           reduce using rule 9 (modules -> empty .)
    DEF             reduce using rule 9 (modules -> empty .)
    INIT            reduce using rule 9 (modules -> empty .)
    LID             reduce using rule 9 (modules -> empty .)
    NUM             reduce using rule 9 (modules -> empty .)


state 9

    (7) agent -> AGENT CID NL .

    USING           reduce using rule 7 (agent -> AGENT CID NL .)
    ALLWRITE        reduce using rule 7 (agent -> AGENT CID NL .)
    ALLREAD         reduce using rule 7 (agent -> AGENT CID NL .)
    LOCAL           reduce using rule 7 (agent -> AGENT CID NL .)
    DEF             reduce using rule 7 (agent -> AGENT CID NL .)
    INIT            reduce using rule 7 (agent -> AGENT CID NL .)
    LID             reduce using rule 7 (agent -> AGENT CID NL .)
    NUM             reduce using rule 7 (agent -> AGENT CID NL .)


state 10

    (8) modules -> module modules .

    ALLWRITE        reduce using rule 8 (modules -> module modules .)
    ALLREAD         reduce using rule 8 (modules -> module modules .)
    LOCAL           reduce using rule 8 (modules -> module modules .)
    DEF             reduce using rule 8 (modules -> module modules .)
    INIT            reduce using rule 8 (modules -> module modules .)
    LID             reduce using rule 8 (modules -> module modules .)
    NUM             reduce using rule 8 (modules -> module modules .)


state 11

    (1) program -> agent modules awdecls . ardecls locdecls stagedecl init events Numdecl
    (17) ardecls -> . ALLREAD COLON NL INDENT rvdecls DEDENT
    (18) ardecls -> . empty
    (100) empty -> .

    ALLREAD         shift and go to state 15
    LOCAL           reduce using rule 100 (empty -> .)
    DEF             reduce using rule 100 (empty -> .)
    INIT            reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)
    NUM             reduce using rule 100 (empty -> .)

    ardecls                        shift and go to state 16
    empty                          shift and go to state 17

state 12

    (15) awdecls -> ALLWRITE . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 18


state 13

    (16) awdecls -> empty .

    ALLREAD         reduce using rule 16 (awdecls -> empty .)
    LOCAL           reduce using rule 16 (awdecls -> empty .)
    DEF             reduce using rule 16 (awdecls -> empty .)
    INIT            reduce using rule 16 (awdecls -> empty .)
    LID             reduce using rule 16 (awdecls -> empty .)
    NUM             reduce using rule 16 (awdecls -> empty .)


state 14

    (10) module -> USING MODULE . CID COLON NL INDENT actuatordecls sensordecls DEDENT

    CID             shift and go to state 19


state 15

    (17) ardecls -> ALLREAD . COLON NL INDENT rvdecls DEDENT

    COLON           shift and go to state 20


state 16

    (1) program -> agent modules awdecls ardecls . locdecls stagedecl init events Numdecl
    (19) locdecls -> . LOCAL COLON NL INDENT decls DEDENT
    (20) locdecls -> . empty
    (100) empty -> .

    LOCAL           shift and go to state 22
    DEF             reduce using rule 100 (empty -> .)
    INIT            reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)
    NUM             reduce using rule 100 (empty -> .)

    locdecls                       shift and go to state 21
    empty                          shift and go to state 23

state 17

    (18) ardecls -> empty .

    LOCAL           reduce using rule 18 (ardecls -> empty .)
    DEF             reduce using rule 18 (ardecls -> empty .)
    INIT            reduce using rule 18 (ardecls -> empty .)
    LID             reduce using rule 18 (ardecls -> empty .)
    NUM             reduce using rule 18 (ardecls -> empty .)


state 18

    (15) awdecls -> ALLWRITE COLON . NL INDENT decls DEDENT

    NL              shift and go to state 24


state 19

    (10) module -> USING MODULE CID . COLON NL INDENT actuatordecls sensordecls DEDENT

    COLON           shift and go to state 25


state 20

    (17) ardecls -> ALLREAD COLON . NL INDENT rvdecls DEDENT

    NL              shift and go to state 26


state 21

    (1) program -> agent modules awdecls ardecls locdecls . stagedecl init events Numdecl
    (3) stagedecl -> . DEF STAGE LCURLY stagelist RCURLY NL
    (4) stagedecl -> . empty
    (100) empty -> .

    DEF             shift and go to state 29
    INIT            reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)
    NUM             reduce using rule 100 (empty -> .)

    stagedecl                      shift and go to state 28
    empty                          shift and go to state 27

state 22

    (19) locdecls -> LOCAL . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 30


state 23

    (20) locdecls -> empty .

    DEF             reduce using rule 20 (locdecls -> empty .)
    INIT            reduce using rule 20 (locdecls -> empty .)
    LID             reduce using rule 20 (locdecls -> empty .)
    NUM             reduce using rule 20 (locdecls -> empty .)


state 24

    (15) awdecls -> ALLWRITE COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 31


state 25

    (10) module -> USING MODULE CID COLON . NL INDENT actuatordecls sensordecls DEDENT

    NL              shift and go to state 32


state 26

    (17) ardecls -> ALLREAD COLON NL . INDENT rvdecls DEDENT

    INDENT          shift and go to state 33


state 27

    (4) stagedecl -> empty .

    INIT            reduce using rule 4 (stagedecl -> empty .)
    LID             reduce using rule 4 (stagedecl -> empty .)
    NUM             reduce using rule 4 (stagedecl -> empty .)


state 28

    (1) program -> agent modules awdecls ardecls locdecls stagedecl . init events Numdecl
    (41) init -> . INIT COLON NL INDENT stmts DEDENT
    (42) init -> . empty
    (100) empty -> .

    INIT            shift and go to state 34
    LID             reduce using rule 100 (empty -> .)
    NUM             reduce using rule 100 (empty -> .)

    init                           shift and go to state 35
    empty                          shift and go to state 36

state 29

    (3) stagedecl -> DEF . STAGE LCURLY stagelist RCURLY NL

    STAGE           shift and go to state 37


state 30

    (19) locdecls -> LOCAL COLON . NL INDENT decls DEDENT

    NL              shift and go to state 38


state 31

    (15) awdecls -> ALLWRITE COLON NL INDENT . decls DEDENT
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    decl                           shift and go to state 39
    decls                          shift and go to state 46
    type                           shift and go to state 45
    empty                          shift and go to state 47

state 32

    (10) module -> USING MODULE CID COLON NL . INDENT actuatordecls sensordecls DEDENT

    INDENT          shift and go to state 48


state 33

    (17) ardecls -> ALLREAD COLON NL INDENT . rvdecls DEDENT
    (25) rvdecls -> . rvdecl rvdecls
    (26) rvdecls -> . empty
    (27) rvdecl -> . type varname LBRACE owner RBRACE NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    rvdecl                         shift and go to state 49
    rvdecls                        shift and go to state 50
    type                           shift and go to state 51
    empty                          shift and go to state 52

state 34

    (41) init -> INIT . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 53


state 35

    (1) program -> agent modules awdecls ardecls locdecls stagedecl init . events Numdecl
    (43) events -> . event events
    (44) events -> . empty
    (45) event -> . LID COLON NL INDENT PRE COLON cond NL effblock DEDENT
    (46) event -> . LID COLON NL INDENT PRE COLON CID NL effblock DEDENT
    (100) empty -> .

    LID             shift and go to state 54
    NUM             reduce using rule 100 (empty -> .)

    event                          shift and go to state 55
    events                         shift and go to state 56
    empty                          shift and go to state 57

state 36

    (42) init -> empty .

    LID             reduce using rule 42 (init -> empty .)
    NUM             reduce using rule 42 (init -> empty .)


state 37

    (3) stagedecl -> DEF STAGE . LCURLY stagelist RCURLY NL

    LCURLY          shift and go to state 58


state 38

    (19) locdecls -> LOCAL COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 59


state 39

    (21) decls -> decl . decls
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    decl                           shift and go to state 39
    decls                          shift and go to state 60
    type                           shift and go to state 45
    empty                          shift and go to state 47

state 40

    (37) type -> STRING .

    LID             reduce using rule 37 (type -> STRING .)
    STAGE           reduce using rule 37 (type -> STRING .)


state 41

    (36) type -> INT .

    LID             reduce using rule 36 (type -> INT .)
    STAGE           reduce using rule 36 (type -> INT .)


state 42

    (38) type -> FLOAT .

    LID             reduce using rule 38 (type -> FLOAT .)
    STAGE           reduce using rule 38 (type -> FLOAT .)


state 43

    (39) type -> IPOS .

    LID             reduce using rule 39 (type -> IPOS .)
    STAGE           reduce using rule 39 (type -> IPOS .)


state 44

    (40) type -> BOOLEAN .

    LID             reduce using rule 40 (type -> BOOLEAN .)
    STAGE           reduce using rule 40 (type -> BOOLEAN .)


state 45

    (23) decl -> type . varname ASGN exp NL
    (24) decl -> type . varname NL
    (91) varname -> . LID
    (92) varname -> . STAGE

    LID             shift and go to state 61
    STAGE           shift and go to state 63

    varname                        shift and go to state 62

state 46

    (15) awdecls -> ALLWRITE COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 64


state 47

    (22) decls -> empty .

    DEDENT          reduce using rule 22 (decls -> empty .)


state 48

    (10) module -> USING MODULE CID COLON NL INDENT . actuatordecls sensordecls DEDENT
    (11) actuatordecls -> . ACTUATORS COLON NL INDENT decls DEDENT
    (12) actuatordecls -> . empty
    (100) empty -> .

    ACTUATORS       shift and go to state 65
    SENSORS         reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

    actuatordecls                  shift and go to state 66
    empty                          shift and go to state 67

state 49

    (25) rvdecls -> rvdecl . rvdecls
    (25) rvdecls -> . rvdecl rvdecls
    (26) rvdecls -> . empty
    (27) rvdecl -> . type varname LBRACE owner RBRACE NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    rvdecl                         shift and go to state 49
    rvdecls                        shift and go to state 68
    type                           shift and go to state 51
    empty                          shift and go to state 52

state 50

    (17) ardecls -> ALLREAD COLON NL INDENT rvdecls . DEDENT

    DEDENT          shift and go to state 69


state 51

    (27) rvdecl -> type . varname LBRACE owner RBRACE NL
    (91) varname -> . LID
    (92) varname -> . STAGE

    LID             shift and go to state 61
    STAGE           shift and go to state 63

    varname                        shift and go to state 70

state 52

    (26) rvdecls -> empty .

    DEDENT          reduce using rule 26 (rvdecls -> empty .)


state 53

    (41) init -> INIT COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 71


state 54

    (45) event -> LID . COLON NL INDENT PRE COLON cond NL effblock DEDENT
    (46) event -> LID . COLON NL INDENT PRE COLON CID NL effblock DEDENT

    COLON           shift and go to state 72


state 55

    (43) events -> event . events
    (43) events -> . event events
    (44) events -> . empty
    (45) event -> . LID COLON NL INDENT PRE COLON cond NL effblock DEDENT
    (46) event -> . LID COLON NL INDENT PRE COLON CID NL effblock DEDENT
    (100) empty -> .

    LID             shift and go to state 54
    NUM             reduce using rule 100 (empty -> .)

    event                          shift and go to state 55
    empty                          shift and go to state 57
    events                         shift and go to state 73

state 56

    (1) program -> agent modules awdecls ardecls locdecls stagedecl init events . Numdecl
    (2) Numdecl -> . NUM INUM NL

    NUM             shift and go to state 75

    Numdecl                        shift and go to state 74

state 57

    (44) events -> empty .

    NUM             reduce using rule 44 (events -> empty .)


state 58

    (3) stagedecl -> DEF STAGE LCURLY . stagelist RCURLY NL
    (5) stagelist -> . LID COMMA stagelist
    (6) stagelist -> . LID

    LID             shift and go to state 76

    stagelist                      shift and go to state 77

state 59

    (19) locdecls -> LOCAL COLON NL INDENT . decls DEDENT
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    decl                           shift and go to state 39
    decls                          shift and go to state 78
    type                           shift and go to state 45
    empty                          shift and go to state 47

state 60

    (21) decls -> decl decls .

    DEDENT          reduce using rule 21 (decls -> decl decls .)


state 61

    (91) varname -> LID .

    LBRACE          reduce using rule 91 (varname -> LID .)
    ASGN            reduce using rule 91 (varname -> LID .)
    LPAR            reduce using rule 91 (varname -> LID .)
    NL              reduce using rule 91 (varname -> LID .)
    RPAR            reduce using rule 91 (varname -> LID .)
    PLUS            reduce using rule 91 (varname -> LID .)
    TIMES           reduce using rule 91 (varname -> LID .)
    MINUS           reduce using rule 91 (varname -> LID .)
    BY              reduce using rule 91 (varname -> LID .)
    AND             reduce using rule 91 (varname -> LID .)
    OR              reduce using rule 91 (varname -> LID .)
    EQ              reduce using rule 91 (varname -> LID .)
    NEQ             reduce using rule 91 (varname -> LID .)
    GEQ             reduce using rule 91 (varname -> LID .)
    LEQ             reduce using rule 91 (varname -> LID .)
    GT              reduce using rule 91 (varname -> LID .)
    LT              reduce using rule 91 (varname -> LID .)
    COLON           reduce using rule 91 (varname -> LID .)
    COMMA           reduce using rule 91 (varname -> LID .)
    RBRACE          reduce using rule 91 (varname -> LID .)


state 62

    (23) decl -> type varname . ASGN exp NL
    (24) decl -> type varname . NL

    ASGN            shift and go to state 80
    NL              shift and go to state 79


state 63

    (92) varname -> STAGE .

    LBRACE          reduce using rule 92 (varname -> STAGE .)
    ASGN            reduce using rule 92 (varname -> STAGE .)
    LPAR            reduce using rule 92 (varname -> STAGE .)
    NL              reduce using rule 92 (varname -> STAGE .)
    RPAR            reduce using rule 92 (varname -> STAGE .)
    PLUS            reduce using rule 92 (varname -> STAGE .)
    TIMES           reduce using rule 92 (varname -> STAGE .)
    MINUS           reduce using rule 92 (varname -> STAGE .)
    BY              reduce using rule 92 (varname -> STAGE .)
    AND             reduce using rule 92 (varname -> STAGE .)
    OR              reduce using rule 92 (varname -> STAGE .)
    EQ              reduce using rule 92 (varname -> STAGE .)
    NEQ             reduce using rule 92 (varname -> STAGE .)
    GEQ             reduce using rule 92 (varname -> STAGE .)
    LEQ             reduce using rule 92 (varname -> STAGE .)
    GT              reduce using rule 92 (varname -> STAGE .)
    LT              reduce using rule 92 (varname -> STAGE .)
    COLON           reduce using rule 92 (varname -> STAGE .)
    COMMA           reduce using rule 92 (varname -> STAGE .)
    RBRACE          reduce using rule 92 (varname -> STAGE .)


state 64

    (15) awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .

    ALLREAD         reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)
    LOCAL           reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)
    DEF             reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)
    INIT            reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)
    LID             reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)
    NUM             reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)


state 65

    (11) actuatordecls -> ACTUATORS . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 81


state 66

    (10) module -> USING MODULE CID COLON NL INDENT actuatordecls . sensordecls DEDENT
    (13) sensordecls -> . SENSORS COLON NL INDENT decls DEDENT
    (14) sensordecls -> . empty
    (100) empty -> .

    SENSORS         shift and go to state 83
    DEDENT          reduce using rule 100 (empty -> .)

    empty                          shift and go to state 84
    sensordecls                    shift and go to state 82

state 67

    (12) actuatordecls -> empty .

    SENSORS         reduce using rule 12 (actuatordecls -> empty .)
    DEDENT          reduce using rule 12 (actuatordecls -> empty .)


state 68

    (25) rvdecls -> rvdecl rvdecls .

    DEDENT          reduce using rule 25 (rvdecls -> rvdecl rvdecls .)


state 69

    (17) ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .

    LOCAL           reduce using rule 17 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)
    DEF             reduce using rule 17 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)
    INIT            reduce using rule 17 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)
    LID             reduce using rule 17 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)
    NUM             reduce using rule 17 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)


state 70

    (27) rvdecl -> type varname . LBRACE owner RBRACE NL

    LBRACE          shift and go to state 85


state 71

    (41) init -> INIT COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 86


state 72

    (45) event -> LID COLON . NL INDENT PRE COLON cond NL effblock DEDENT
    (46) event -> LID COLON . NL INDENT PRE COLON CID NL effblock DEDENT

    NL              shift and go to state 87


state 73

    (43) events -> event events .

    NUM             reduce using rule 43 (events -> event events .)


state 74

    (1) program -> agent modules awdecls ardecls locdecls stagedecl init events Numdecl .

    $end            reduce using rule 1 (program -> agent modules awdecls ardecls locdecls stagedecl init events Numdecl .)


state 75

    (2) Numdecl -> NUM . INUM NL

    INUM            shift and go to state 88


state 76

    (5) stagelist -> LID . COMMA stagelist
    (6) stagelist -> LID .

    COMMA           shift and go to state 89
    RCURLY          reduce using rule 6 (stagelist -> LID .)


state 77

    (3) stagedecl -> DEF STAGE LCURLY stagelist . RCURLY NL

    RCURLY          shift and go to state 90


state 78

    (19) locdecls -> LOCAL COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 91


state 79

    (24) decl -> type varname NL .

    INT             reduce using rule 24 (decl -> type varname NL .)
    STRING          reduce using rule 24 (decl -> type varname NL .)
    FLOAT           reduce using rule 24 (decl -> type varname NL .)
    IPOS            reduce using rule 24 (decl -> type varname NL .)
    BOOLEAN         reduce using rule 24 (decl -> type varname NL .)
    DEDENT          reduce using rule 24 (decl -> type varname NL .)


state 80

    (23) decl -> type varname ASGN . exp NL
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    PID             shift and go to state 100
    LPAR            shift and go to state 92
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    moduleflag                     shift and go to state 101
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 107
    bval                           shift and go to state 97

state 81

    (11) actuatordecls -> ACTUATORS COLON . NL INDENT decls DEDENT

    NL              shift and go to state 109


state 82

    (10) module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls . DEDENT

    DEDENT          shift and go to state 110


state 83

    (13) sensordecls -> SENSORS . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 111


state 84

    (14) sensordecls -> empty .

    DEDENT          reduce using rule 14 (sensordecls -> empty .)


state 85

    (27) rvdecl -> type varname LBRACE . owner RBRACE NL
    (28) owner -> . TIMES
    (29) owner -> . INUM

    TIMES           shift and go to state 112
    INUM            shift and go to state 113

    owner                          shift and go to state 114

state 86

    (41) init -> INIT COLON NL INDENT . stmts DEDENT
    (55) stmts -> . stmt stmts
    (56) stmts -> . empty
    (57) stmt -> . asgn
    (58) stmt -> . wptstmt
    (59) stmt -> . pass
    (60) stmt -> . EXIT NL
    (61) stmt -> . funccall NL
    (62) stmt -> . modulefunccall NL
    (63) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (64) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (100) empty -> .
    (69) asgn -> . varname ASGN exp NL
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (68) pass -> . PASS NL
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE

    EXIT            shift and go to state 128
    ATOMIC          shift and go to state 116
    IF              shift and go to state 125
    DEDENT          reduce using rule 100 (empty -> .)
    PASS            shift and go to state 124
    CID             shift and go to state 115
    LID             shift and go to state 61
    STAGE           shift and go to state 63

    funccall                       shift and go to state 121
    stmts                          shift and go to state 118
    varname                        shift and go to state 126
    stmt                           shift and go to state 123
    asgn                           shift and go to state 119
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    pass                           shift and go to state 117
    empty                          shift and go to state 120

state 87

    (45) event -> LID COLON NL . INDENT PRE COLON cond NL effblock DEDENT
    (46) event -> LID COLON NL . INDENT PRE COLON CID NL effblock DEDENT

    INDENT          shift and go to state 129


state 88

    (2) Numdecl -> NUM INUM . NL

    NL              shift and go to state 130


state 89

    (5) stagelist -> LID COMMA . stagelist
    (5) stagelist -> . LID COMMA stagelist
    (6) stagelist -> . LID

    LID             shift and go to state 76

    stagelist                      shift and go to state 131

state 90

    (3) stagedecl -> DEF STAGE LCURLY stagelist RCURLY . NL

    NL              shift and go to state 132


state 91

    (19) locdecls -> LOCAL COLON NL INDENT decls DEDENT .

    DEF             reduce using rule 19 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)
    INIT            reduce using rule 19 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)
    LID             reduce using rule 19 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)
    NUM             reduce using rule 19 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)


state 92

    (85) bracketexp -> LPAR . exp RPAR
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    PID             shift and go to state 100
    LPAR            shift and go to state 92
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    null                           shift and go to state 98
    num                            shift and go to state 96
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    bracketexp                     shift and go to state 93
    exp                            shift and go to state 133
    moduleflag                     shift and go to state 101
    bval                           shift and go to state 97

state 93

    (71) exp -> bracketexp .

    PLUS            reduce using rule 71 (exp -> bracketexp .)
    TIMES           reduce using rule 71 (exp -> bracketexp .)
    MINUS           reduce using rule 71 (exp -> bracketexp .)
    BY              reduce using rule 71 (exp -> bracketexp .)
    RPAR            reduce using rule 71 (exp -> bracketexp .)
    NL              reduce using rule 71 (exp -> bracketexp .)
    COLON           reduce using rule 71 (exp -> bracketexp .)
    COMMA           reduce using rule 71 (exp -> bracketexp .)
    RBRACE          reduce using rule 71 (exp -> bracketexp .)
    AND             reduce using rule 71 (exp -> bracketexp .)
    OR              reduce using rule 71 (exp -> bracketexp .)
    EQ              reduce using rule 71 (exp -> bracketexp .)
    NEQ             reduce using rule 71 (exp -> bracketexp .)
    GEQ             reduce using rule 71 (exp -> bracketexp .)
    LEQ             reduce using rule 71 (exp -> bracketexp .)
    GT              reduce using rule 71 (exp -> bracketexp .)
    LT              reduce using rule 71 (exp -> bracketexp .)


state 94

    (86) moduleflag -> CID .
    (65) modulefunccall -> CID . LPAR args RPAR

    NL              reduce using rule 86 (moduleflag -> CID .)
    PLUS            reduce using rule 86 (moduleflag -> CID .)
    TIMES           reduce using rule 86 (moduleflag -> CID .)
    MINUS           reduce using rule 86 (moduleflag -> CID .)
    BY              reduce using rule 86 (moduleflag -> CID .)
    COMMA           reduce using rule 86 (moduleflag -> CID .)
    RPAR            reduce using rule 86 (moduleflag -> CID .)
    COLON           reduce using rule 86 (moduleflag -> CID .)
    RBRACE          reduce using rule 86 (moduleflag -> CID .)
    AND             reduce using rule 86 (moduleflag -> CID .)
    OR              reduce using rule 86 (moduleflag -> CID .)
    EQ              reduce using rule 86 (moduleflag -> CID .)
    NEQ             reduce using rule 86 (moduleflag -> CID .)
    GEQ             reduce using rule 86 (moduleflag -> CID .)
    LEQ             reduce using rule 86 (moduleflag -> CID .)
    GT              reduce using rule 86 (moduleflag -> CID .)
    LT              reduce using rule 86 (moduleflag -> CID .)
    LPAR            shift and go to state 134


state 95

    (90) num -> FNUM .

    RBRACE          reduce using rule 90 (num -> FNUM .)
    PLUS            reduce using rule 90 (num -> FNUM .)
    TIMES           reduce using rule 90 (num -> FNUM .)
    MINUS           reduce using rule 90 (num -> FNUM .)
    BY              reduce using rule 90 (num -> FNUM .)
    RPAR            reduce using rule 90 (num -> FNUM .)
    NL              reduce using rule 90 (num -> FNUM .)
    COLON           reduce using rule 90 (num -> FNUM .)
    COMMA           reduce using rule 90 (num -> FNUM .)
    AND             reduce using rule 90 (num -> FNUM .)
    OR              reduce using rule 90 (num -> FNUM .)
    EQ              reduce using rule 90 (num -> FNUM .)
    NEQ             reduce using rule 90 (num -> FNUM .)
    GEQ             reduce using rule 90 (num -> FNUM .)
    LEQ             reduce using rule 90 (num -> FNUM .)
    GT              reduce using rule 90 (num -> FNUM .)
    LT              reduce using rule 90 (num -> FNUM .)


state 96

    (80) exp -> num .

    PLUS            reduce using rule 80 (exp -> num .)
    TIMES           reduce using rule 80 (exp -> num .)
    MINUS           reduce using rule 80 (exp -> num .)
    BY              reduce using rule 80 (exp -> num .)
    RPAR            reduce using rule 80 (exp -> num .)
    NL              reduce using rule 80 (exp -> num .)
    COLON           reduce using rule 80 (exp -> num .)
    COMMA           reduce using rule 80 (exp -> num .)
    RBRACE          reduce using rule 80 (exp -> num .)
    AND             reduce using rule 80 (exp -> num .)
    OR              reduce using rule 80 (exp -> num .)
    EQ              reduce using rule 80 (exp -> num .)
    NEQ             reduce using rule 80 (exp -> num .)
    GEQ             reduce using rule 80 (exp -> num .)
    LEQ             reduce using rule 80 (exp -> num .)
    GT              reduce using rule 80 (exp -> num .)
    LT              reduce using rule 80 (exp -> num .)


state 97

    (78) exp -> bval .

    PLUS            reduce using rule 78 (exp -> bval .)
    TIMES           reduce using rule 78 (exp -> bval .)
    MINUS           reduce using rule 78 (exp -> bval .)
    BY              reduce using rule 78 (exp -> bval .)
    RPAR            reduce using rule 78 (exp -> bval .)
    NL              reduce using rule 78 (exp -> bval .)
    COLON           reduce using rule 78 (exp -> bval .)
    COMMA           reduce using rule 78 (exp -> bval .)
    RBRACE          reduce using rule 78 (exp -> bval .)
    AND             reduce using rule 78 (exp -> bval .)
    OR              reduce using rule 78 (exp -> bval .)
    EQ              reduce using rule 78 (exp -> bval .)
    NEQ             reduce using rule 78 (exp -> bval .)
    GEQ             reduce using rule 78 (exp -> bval .)
    LEQ             reduce using rule 78 (exp -> bval .)
    GT              reduce using rule 78 (exp -> bval .)
    LT              reduce using rule 78 (exp -> bval .)


state 98

    (81) exp -> null .

    PLUS            reduce using rule 81 (exp -> null .)
    TIMES           reduce using rule 81 (exp -> null .)
    MINUS           reduce using rule 81 (exp -> null .)
    BY              reduce using rule 81 (exp -> null .)
    RPAR            reduce using rule 81 (exp -> null .)
    NL              reduce using rule 81 (exp -> null .)
    COLON           reduce using rule 81 (exp -> null .)
    COMMA           reduce using rule 81 (exp -> null .)
    RBRACE          reduce using rule 81 (exp -> null .)
    AND             reduce using rule 81 (exp -> null .)
    OR              reduce using rule 81 (exp -> null .)
    EQ              reduce using rule 81 (exp -> null .)
    NEQ             reduce using rule 81 (exp -> null .)
    GEQ             reduce using rule 81 (exp -> null .)
    LEQ             reduce using rule 81 (exp -> null .)
    GT              reduce using rule 81 (exp -> null .)
    LT              reduce using rule 81 (exp -> null .)


state 99

    (87) bval -> TRUE .

    PLUS            reduce using rule 87 (bval -> TRUE .)
    TIMES           reduce using rule 87 (bval -> TRUE .)
    MINUS           reduce using rule 87 (bval -> TRUE .)
    BY              reduce using rule 87 (bval -> TRUE .)
    NL              reduce using rule 87 (bval -> TRUE .)
    RPAR            reduce using rule 87 (bval -> TRUE .)
    COLON           reduce using rule 87 (bval -> TRUE .)
    COMMA           reduce using rule 87 (bval -> TRUE .)
    RBRACE          reduce using rule 87 (bval -> TRUE .)
    AND             reduce using rule 87 (bval -> TRUE .)
    OR              reduce using rule 87 (bval -> TRUE .)
    EQ              reduce using rule 87 (bval -> TRUE .)
    NEQ             reduce using rule 87 (bval -> TRUE .)
    GEQ             reduce using rule 87 (bval -> TRUE .)
    LEQ             reduce using rule 87 (bval -> TRUE .)
    GT              reduce using rule 87 (bval -> TRUE .)
    LT              reduce using rule 87 (bval -> TRUE .)


state 100

    (79) exp -> PID .

    PLUS            reduce using rule 79 (exp -> PID .)
    TIMES           reduce using rule 79 (exp -> PID .)
    MINUS           reduce using rule 79 (exp -> PID .)
    BY              reduce using rule 79 (exp -> PID .)
    RPAR            reduce using rule 79 (exp -> PID .)
    NL              reduce using rule 79 (exp -> PID .)
    COLON           reduce using rule 79 (exp -> PID .)
    COMMA           reduce using rule 79 (exp -> PID .)
    RBRACE          reduce using rule 79 (exp -> PID .)
    AND             reduce using rule 79 (exp -> PID .)
    OR              reduce using rule 79 (exp -> PID .)
    EQ              reduce using rule 79 (exp -> PID .)
    NEQ             reduce using rule 79 (exp -> PID .)
    GEQ             reduce using rule 79 (exp -> PID .)
    LEQ             reduce using rule 79 (exp -> PID .)
    GT              reduce using rule 79 (exp -> PID .)
    LT              reduce using rule 79 (exp -> PID .)


state 101

    (82) exp -> moduleflag .

    PLUS            reduce using rule 82 (exp -> moduleflag .)
    TIMES           reduce using rule 82 (exp -> moduleflag .)
    MINUS           reduce using rule 82 (exp -> moduleflag .)
    BY              reduce using rule 82 (exp -> moduleflag .)
    RPAR            reduce using rule 82 (exp -> moduleflag .)
    NL              reduce using rule 82 (exp -> moduleflag .)
    COLON           reduce using rule 82 (exp -> moduleflag .)
    COMMA           reduce using rule 82 (exp -> moduleflag .)
    RBRACE          reduce using rule 82 (exp -> moduleflag .)
    AND             reduce using rule 82 (exp -> moduleflag .)
    OR              reduce using rule 82 (exp -> moduleflag .)
    EQ              reduce using rule 82 (exp -> moduleflag .)
    NEQ             reduce using rule 82 (exp -> moduleflag .)
    GEQ             reduce using rule 82 (exp -> moduleflag .)
    LEQ             reduce using rule 82 (exp -> moduleflag .)
    GT              reduce using rule 82 (exp -> moduleflag .)
    LT              reduce using rule 82 (exp -> moduleflag .)


state 102

    (83) exp -> funccall .

    PLUS            reduce using rule 83 (exp -> funccall .)
    TIMES           reduce using rule 83 (exp -> funccall .)
    MINUS           reduce using rule 83 (exp -> funccall .)
    BY              reduce using rule 83 (exp -> funccall .)
    RPAR            reduce using rule 83 (exp -> funccall .)
    NL              reduce using rule 83 (exp -> funccall .)
    COLON           reduce using rule 83 (exp -> funccall .)
    COMMA           reduce using rule 83 (exp -> funccall .)
    RBRACE          reduce using rule 83 (exp -> funccall .)
    AND             reduce using rule 83 (exp -> funccall .)
    OR              reduce using rule 83 (exp -> funccall .)
    EQ              reduce using rule 83 (exp -> funccall .)
    NEQ             reduce using rule 83 (exp -> funccall .)
    GEQ             reduce using rule 83 (exp -> funccall .)
    LEQ             reduce using rule 83 (exp -> funccall .)
    GT              reduce using rule 83 (exp -> funccall .)
    LT              reduce using rule 83 (exp -> funccall .)


state 103

    (84) exp -> modulefunccall .

    PLUS            reduce using rule 84 (exp -> modulefunccall .)
    TIMES           reduce using rule 84 (exp -> modulefunccall .)
    MINUS           reduce using rule 84 (exp -> modulefunccall .)
    BY              reduce using rule 84 (exp -> modulefunccall .)
    RPAR            reduce using rule 84 (exp -> modulefunccall .)
    NL              reduce using rule 84 (exp -> modulefunccall .)
    COLON           reduce using rule 84 (exp -> modulefunccall .)
    COMMA           reduce using rule 84 (exp -> modulefunccall .)
    RBRACE          reduce using rule 84 (exp -> modulefunccall .)
    AND             reduce using rule 84 (exp -> modulefunccall .)
    OR              reduce using rule 84 (exp -> modulefunccall .)
    EQ              reduce using rule 84 (exp -> modulefunccall .)
    NEQ             reduce using rule 84 (exp -> modulefunccall .)
    GEQ             reduce using rule 84 (exp -> modulefunccall .)
    LEQ             reduce using rule 84 (exp -> modulefunccall .)
    GT              reduce using rule 84 (exp -> modulefunccall .)
    LT              reduce using rule 84 (exp -> modulefunccall .)


state 104

    (93) null -> NULL .

    PLUS            reduce using rule 93 (null -> NULL .)
    TIMES           reduce using rule 93 (null -> NULL .)
    MINUS           reduce using rule 93 (null -> NULL .)
    BY              reduce using rule 93 (null -> NULL .)
    RPAR            reduce using rule 93 (null -> NULL .)
    NL              reduce using rule 93 (null -> NULL .)
    COLON           reduce using rule 93 (null -> NULL .)
    COMMA           reduce using rule 93 (null -> NULL .)
    RBRACE          reduce using rule 93 (null -> NULL .)
    AND             reduce using rule 93 (null -> NULL .)
    OR              reduce using rule 93 (null -> NULL .)
    EQ              reduce using rule 93 (null -> NULL .)
    NEQ             reduce using rule 93 (null -> NULL .)
    GEQ             reduce using rule 93 (null -> NULL .)
    LEQ             reduce using rule 93 (null -> NULL .)
    GT              reduce using rule 93 (null -> NULL .)
    LT              reduce using rule 93 (null -> NULL .)


state 105

    (88) bval -> FALSE .

    PLUS            reduce using rule 88 (bval -> FALSE .)
    TIMES           reduce using rule 88 (bval -> FALSE .)
    MINUS           reduce using rule 88 (bval -> FALSE .)
    BY              reduce using rule 88 (bval -> FALSE .)
    NL              reduce using rule 88 (bval -> FALSE .)
    RPAR            reduce using rule 88 (bval -> FALSE .)
    COLON           reduce using rule 88 (bval -> FALSE .)
    COMMA           reduce using rule 88 (bval -> FALSE .)
    RBRACE          reduce using rule 88 (bval -> FALSE .)
    AND             reduce using rule 88 (bval -> FALSE .)
    OR              reduce using rule 88 (bval -> FALSE .)
    EQ              reduce using rule 88 (bval -> FALSE .)
    NEQ             reduce using rule 88 (bval -> FALSE .)
    GEQ             reduce using rule 88 (bval -> FALSE .)
    LEQ             reduce using rule 88 (bval -> FALSE .)
    GT              reduce using rule 88 (bval -> FALSE .)
    LT              reduce using rule 88 (bval -> FALSE .)


state 106

    (76) exp -> varname .
    (77) exp -> varname . LBRACE exp RBRACE
    (30) funccall -> varname . LPAR args RPAR

    PLUS            reduce using rule 76 (exp -> varname .)
    TIMES           reduce using rule 76 (exp -> varname .)
    MINUS           reduce using rule 76 (exp -> varname .)
    BY              reduce using rule 76 (exp -> varname .)
    RPAR            reduce using rule 76 (exp -> varname .)
    NL              reduce using rule 76 (exp -> varname .)
    COLON           reduce using rule 76 (exp -> varname .)
    COMMA           reduce using rule 76 (exp -> varname .)
    RBRACE          reduce using rule 76 (exp -> varname .)
    AND             reduce using rule 76 (exp -> varname .)
    OR              reduce using rule 76 (exp -> varname .)
    EQ              reduce using rule 76 (exp -> varname .)
    NEQ             reduce using rule 76 (exp -> varname .)
    GEQ             reduce using rule 76 (exp -> varname .)
    LEQ             reduce using rule 76 (exp -> varname .)
    GT              reduce using rule 76 (exp -> varname .)
    LT              reduce using rule 76 (exp -> varname .)
    LBRACE          shift and go to state 136
    LPAR            shift and go to state 135


state 107

    (23) decl -> type varname ASGN exp . NL
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    NL              shift and go to state 137
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138


state 108

    (89) num -> INUM .

    RBRACE          reduce using rule 89 (num -> INUM .)
    PLUS            reduce using rule 89 (num -> INUM .)
    TIMES           reduce using rule 89 (num -> INUM .)
    MINUS           reduce using rule 89 (num -> INUM .)
    BY              reduce using rule 89 (num -> INUM .)
    RPAR            reduce using rule 89 (num -> INUM .)
    NL              reduce using rule 89 (num -> INUM .)
    COLON           reduce using rule 89 (num -> INUM .)
    COMMA           reduce using rule 89 (num -> INUM .)
    AND             reduce using rule 89 (num -> INUM .)
    OR              reduce using rule 89 (num -> INUM .)
    EQ              reduce using rule 89 (num -> INUM .)
    NEQ             reduce using rule 89 (num -> INUM .)
    GEQ             reduce using rule 89 (num -> INUM .)
    LEQ             reduce using rule 89 (num -> INUM .)
    GT              reduce using rule 89 (num -> INUM .)
    LT              reduce using rule 89 (num -> INUM .)


state 109

    (11) actuatordecls -> ACTUATORS COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 142


state 110

    (10) module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .

    USING           reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    ALLWRITE        reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    ALLREAD         reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    LOCAL           reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    DEF             reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    INIT            reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    LID             reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    NUM             reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)


state 111

    (13) sensordecls -> SENSORS COLON . NL INDENT decls DEDENT

    NL              shift and go to state 143


state 112

    (28) owner -> TIMES .

    RBRACE          reduce using rule 28 (owner -> TIMES .)


state 113

    (29) owner -> INUM .

    RBRACE          reduce using rule 29 (owner -> INUM .)


state 114

    (27) rvdecl -> type varname LBRACE owner . RBRACE NL

    RBRACE          shift and go to state 144


state 115

    (65) modulefunccall -> CID . LPAR args RPAR

    LPAR            shift and go to state 134


state 116

    (63) stmt -> ATOMIC . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 145


state 117

    (59) stmt -> pass .

    DEDENT          reduce using rule 59 (stmt -> pass .)
    EXIT            reduce using rule 59 (stmt -> pass .)
    ATOMIC          reduce using rule 59 (stmt -> pass .)
    IF              reduce using rule 59 (stmt -> pass .)
    PASS            reduce using rule 59 (stmt -> pass .)
    CID             reduce using rule 59 (stmt -> pass .)
    LID             reduce using rule 59 (stmt -> pass .)
    STAGE           reduce using rule 59 (stmt -> pass .)


state 118

    (41) init -> INIT COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 146


state 119

    (57) stmt -> asgn .

    DEDENT          reduce using rule 57 (stmt -> asgn .)
    EXIT            reduce using rule 57 (stmt -> asgn .)
    ATOMIC          reduce using rule 57 (stmt -> asgn .)
    IF              reduce using rule 57 (stmt -> asgn .)
    PASS            reduce using rule 57 (stmt -> asgn .)
    CID             reduce using rule 57 (stmt -> asgn .)
    LID             reduce using rule 57 (stmt -> asgn .)
    STAGE           reduce using rule 57 (stmt -> asgn .)


state 120

    (56) stmts -> empty .

    DEDENT          reduce using rule 56 (stmts -> empty .)


state 121

    (61) stmt -> funccall . NL

    NL              shift and go to state 147


state 122

    (62) stmt -> modulefunccall . NL

    NL              shift and go to state 148


state 123

    (55) stmts -> stmt . stmts
    (55) stmts -> . stmt stmts
    (56) stmts -> . empty
    (57) stmt -> . asgn
    (58) stmt -> . wptstmt
    (59) stmt -> . pass
    (60) stmt -> . EXIT NL
    (61) stmt -> . funccall NL
    (62) stmt -> . modulefunccall NL
    (63) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (64) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (100) empty -> .
    (69) asgn -> . varname ASGN exp NL
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (68) pass -> . PASS NL
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE

    EXIT            shift and go to state 128
    ATOMIC          shift and go to state 116
    IF              shift and go to state 125
    DEDENT          reduce using rule 100 (empty -> .)
    PASS            shift and go to state 124
    CID             shift and go to state 115
    LID             shift and go to state 61
    STAGE           shift and go to state 63

    funccall                       shift and go to state 121
    stmts                          shift and go to state 149
    varname                        shift and go to state 126
    stmt                           shift and go to state 123
    asgn                           shift and go to state 119
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    pass                           shift and go to state 117
    empty                          shift and go to state 120

state 124

    (68) pass -> PASS . NL

    NL              shift and go to state 150


state 125

    (64) stmt -> IF . cond COLON NL INDENT stmts DEDENT elseblock
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . LPAR cond RPAR
    (54) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 151
    PID             shift and go to state 100
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    moduleflag                     shift and go to state 101
    funccall                       shift and go to state 102
    varname                        shift and go to state 106
    null                           shift and go to state 98
    modulefunccall                 shift and go to state 103
    num                            shift and go to state 96
    cond                           shift and go to state 152
    exp                            shift and go to state 153
    bval                           shift and go to state 97

state 126

    (69) asgn -> varname . ASGN exp NL
    (70) wptstmt -> varname . ASGN GETINPUT LPAR RPAR NL
    (30) funccall -> varname . LPAR args RPAR

    ASGN            shift and go to state 154
    LPAR            shift and go to state 135


state 127

    (58) stmt -> wptstmt .

    DEDENT          reduce using rule 58 (stmt -> wptstmt .)
    EXIT            reduce using rule 58 (stmt -> wptstmt .)
    ATOMIC          reduce using rule 58 (stmt -> wptstmt .)
    IF              reduce using rule 58 (stmt -> wptstmt .)
    PASS            reduce using rule 58 (stmt -> wptstmt .)
    CID             reduce using rule 58 (stmt -> wptstmt .)
    LID             reduce using rule 58 (stmt -> wptstmt .)
    STAGE           reduce using rule 58 (stmt -> wptstmt .)


state 128

    (60) stmt -> EXIT . NL

    NL              shift and go to state 155


state 129

    (45) event -> LID COLON NL INDENT . PRE COLON cond NL effblock DEDENT
    (46) event -> LID COLON NL INDENT . PRE COLON CID NL effblock DEDENT

    PRE             shift and go to state 156


state 130

    (2) Numdecl -> NUM INUM NL .

    $end            reduce using rule 2 (Numdecl -> NUM INUM NL .)


state 131

    (5) stagelist -> LID COMMA stagelist .

    RCURLY          reduce using rule 5 (stagelist -> LID COMMA stagelist .)


state 132

    (3) stagedecl -> DEF STAGE LCURLY stagelist RCURLY NL .

    INIT            reduce using rule 3 (stagedecl -> DEF STAGE LCURLY stagelist RCURLY NL .)
    LID             reduce using rule 3 (stagedecl -> DEF STAGE LCURLY stagelist RCURLY NL .)
    NUM             reduce using rule 3 (stagedecl -> DEF STAGE LCURLY stagelist RCURLY NL .)


state 133

    (85) bracketexp -> LPAR exp . RPAR
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    RPAR            shift and go to state 157
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138


state 134

    (65) modulefunccall -> CID LPAR . args RPAR
    (31) args -> . neargs
    (32) args -> . noargs
    (34) neargs -> . exp
    (35) neargs -> . exp COMMA neargs
    (33) noargs -> . empty
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (100) empty -> .
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    PID             shift and go to state 100
    RPAR            reduce using rule 100 (empty -> .)
    LPAR            shift and go to state 92
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    moduleflag                     shift and go to state 101
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    args                           shift and go to state 161
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 162
    noargs                         shift and go to state 158
    neargs                         shift and go to state 159
    bval                           shift and go to state 97
    empty                          shift and go to state 160

state 135

    (30) funccall -> varname LPAR . args RPAR
    (31) args -> . neargs
    (32) args -> . noargs
    (34) neargs -> . exp
    (35) neargs -> . exp COMMA neargs
    (33) noargs -> . empty
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (100) empty -> .
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    PID             shift and go to state 100
    RPAR            reduce using rule 100 (empty -> .)
    LPAR            shift and go to state 92
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    moduleflag                     shift and go to state 101
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    args                           shift and go to state 163
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 162
    noargs                         shift and go to state 158
    neargs                         shift and go to state 159
    bval                           shift and go to state 97
    empty                          shift and go to state 160

state 136

    (77) exp -> varname LBRACE . exp RBRACE
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    PID             shift and go to state 100
    LPAR            shift and go to state 92
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    null                           shift and go to state 98
    num                            shift and go to state 96
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    bracketexp                     shift and go to state 93
    exp                            shift and go to state 164
    moduleflag                     shift and go to state 101
    bval                           shift and go to state 97

state 137

    (23) decl -> type varname ASGN exp NL .

    INT             reduce using rule 23 (decl -> type varname ASGN exp NL .)
    STRING          reduce using rule 23 (decl -> type varname ASGN exp NL .)
    FLOAT           reduce using rule 23 (decl -> type varname ASGN exp NL .)
    IPOS            reduce using rule 23 (decl -> type varname ASGN exp NL .)
    BOOLEAN         reduce using rule 23 (decl -> type varname ASGN exp NL .)
    DEDENT          reduce using rule 23 (decl -> type varname ASGN exp NL .)


state 138

    (75) exp -> exp BY . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    PID             shift and go to state 100
    LPAR            shift and go to state 92
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    null                           shift and go to state 98
    num                            shift and go to state 96
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    bracketexp                     shift and go to state 93
    exp                            shift and go to state 165
    moduleflag                     shift and go to state 101
    bval                           shift and go to state 97

state 139

    (72) exp -> exp PLUS . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    PID             shift and go to state 100
    LPAR            shift and go to state 92
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    null                           shift and go to state 98
    num                            shift and go to state 96
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    bracketexp                     shift and go to state 93
    exp                            shift and go to state 166
    moduleflag                     shift and go to state 101
    bval                           shift and go to state 97

state 140

    (73) exp -> exp TIMES . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    PID             shift and go to state 100
    LPAR            shift and go to state 92
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    null                           shift and go to state 98
    num                            shift and go to state 96
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    bracketexp                     shift and go to state 93
    exp                            shift and go to state 167
    moduleflag                     shift and go to state 101
    bval                           shift and go to state 97

state 141

    (74) exp -> exp MINUS . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    PID             shift and go to state 100
    LPAR            shift and go to state 92
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    null                           shift and go to state 98
    num                            shift and go to state 96
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    bracketexp                     shift and go to state 93
    exp                            shift and go to state 168
    moduleflag                     shift and go to state 101
    bval                           shift and go to state 97

state 142

    (11) actuatordecls -> ACTUATORS COLON NL INDENT . decls DEDENT
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    decl                           shift and go to state 39
    decls                          shift and go to state 169
    type                           shift and go to state 45
    empty                          shift and go to state 47

state 143

    (13) sensordecls -> SENSORS COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 170


state 144

    (27) rvdecl -> type varname LBRACE owner RBRACE . NL

    NL              shift and go to state 171


state 145

    (63) stmt -> ATOMIC COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 172


state 146

    (41) init -> INIT COLON NL INDENT stmts DEDENT .

    LID             reduce using rule 41 (init -> INIT COLON NL INDENT stmts DEDENT .)
    NUM             reduce using rule 41 (init -> INIT COLON NL INDENT stmts DEDENT .)


state 147

    (61) stmt -> funccall NL .

    DEDENT          reduce using rule 61 (stmt -> funccall NL .)
    EXIT            reduce using rule 61 (stmt -> funccall NL .)
    ATOMIC          reduce using rule 61 (stmt -> funccall NL .)
    IF              reduce using rule 61 (stmt -> funccall NL .)
    PASS            reduce using rule 61 (stmt -> funccall NL .)
    CID             reduce using rule 61 (stmt -> funccall NL .)
    LID             reduce using rule 61 (stmt -> funccall NL .)
    STAGE           reduce using rule 61 (stmt -> funccall NL .)


state 148

    (62) stmt -> modulefunccall NL .

    DEDENT          reduce using rule 62 (stmt -> modulefunccall NL .)
    EXIT            reduce using rule 62 (stmt -> modulefunccall NL .)
    ATOMIC          reduce using rule 62 (stmt -> modulefunccall NL .)
    IF              reduce using rule 62 (stmt -> modulefunccall NL .)
    PASS            reduce using rule 62 (stmt -> modulefunccall NL .)
    CID             reduce using rule 62 (stmt -> modulefunccall NL .)
    LID             reduce using rule 62 (stmt -> modulefunccall NL .)
    STAGE           reduce using rule 62 (stmt -> modulefunccall NL .)


state 149

    (55) stmts -> stmt stmts .

    DEDENT          reduce using rule 55 (stmts -> stmt stmts .)


state 150

    (68) pass -> PASS NL .

    EXIT            reduce using rule 68 (pass -> PASS NL .)
    ATOMIC          reduce using rule 68 (pass -> PASS NL .)
    IF              reduce using rule 68 (pass -> PASS NL .)
    PASS            reduce using rule 68 (pass -> PASS NL .)
    CID             reduce using rule 68 (pass -> PASS NL .)
    LID             reduce using rule 68 (pass -> PASS NL .)
    STAGE           reduce using rule 68 (pass -> PASS NL .)
    DEDENT          reduce using rule 68 (pass -> PASS NL .)


state 151

    (49) cond -> LPAR . cond AND cond RPAR
    (50) cond -> LPAR . cond OR cond RPAR
    (51) cond -> LPAR . cond op cond RPAR
    (52) cond -> LPAR . NOT cond RPAR
    (53) cond -> LPAR . cond RPAR
    (85) bracketexp -> LPAR . exp RPAR
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . LPAR cond RPAR
    (54) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    NOT             shift and go to state 175
    LPAR            shift and go to state 151
    PID             shift and go to state 100
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    moduleflag                     shift and go to state 101
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    null                           shift and go to state 98
    num                            shift and go to state 96
    cond                           shift and go to state 173
    exp                            shift and go to state 174
    bval                           shift and go to state 97

state 152

    (64) stmt -> IF cond . COLON NL INDENT stmts DEDENT elseblock

    COLON           shift and go to state 176


state 153

    (54) cond -> exp .
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    RPAR            reduce using rule 54 (cond -> exp .)
    COLON           reduce using rule 54 (cond -> exp .)
    NL              reduce using rule 54 (cond -> exp .)
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138


state 154

    (69) asgn -> varname ASGN . exp NL
    (70) wptstmt -> varname ASGN . GETINPUT LPAR RPAR NL
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    GETINPUT        shift and go to state 178
    PID             shift and go to state 100
    LPAR            shift and go to state 92
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    null                           shift and go to state 98
    num                            shift and go to state 96
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    bracketexp                     shift and go to state 93
    exp                            shift and go to state 177
    moduleflag                     shift and go to state 101
    bval                           shift and go to state 97

state 155

    (60) stmt -> EXIT NL .

    DEDENT          reduce using rule 60 (stmt -> EXIT NL .)
    EXIT            reduce using rule 60 (stmt -> EXIT NL .)
    ATOMIC          reduce using rule 60 (stmt -> EXIT NL .)
    IF              reduce using rule 60 (stmt -> EXIT NL .)
    PASS            reduce using rule 60 (stmt -> EXIT NL .)
    CID             reduce using rule 60 (stmt -> EXIT NL .)
    LID             reduce using rule 60 (stmt -> EXIT NL .)
    STAGE           reduce using rule 60 (stmt -> EXIT NL .)


state 156

    (45) event -> LID COLON NL INDENT PRE . COLON cond NL effblock DEDENT
    (46) event -> LID COLON NL INDENT PRE . COLON CID NL effblock DEDENT

    COLON           shift and go to state 179


state 157

    (85) bracketexp -> LPAR exp RPAR .

    PLUS            reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    TIMES           reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    MINUS           reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    BY              reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    RPAR            reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    NL              reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    COLON           reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    COMMA           reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    RBRACE          reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    AND             reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    OR              reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    EQ              reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    NEQ             reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    GEQ             reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    LEQ             reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    GT              reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    LT              reduce using rule 85 (bracketexp -> LPAR exp RPAR .)


state 158

    (32) args -> noargs .

    RPAR            reduce using rule 32 (args -> noargs .)


state 159

    (31) args -> neargs .

    RPAR            reduce using rule 31 (args -> neargs .)


state 160

    (33) noargs -> empty .

    RPAR            reduce using rule 33 (noargs -> empty .)


state 161

    (65) modulefunccall -> CID LPAR args . RPAR

    RPAR            shift and go to state 180


state 162

    (34) neargs -> exp .
    (35) neargs -> exp . COMMA neargs
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    RPAR            reduce using rule 34 (neargs -> exp .)
    COMMA           shift and go to state 181
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138


state 163

    (30) funccall -> varname LPAR args . RPAR

    RPAR            shift and go to state 182


state 164

    (77) exp -> varname LBRACE exp . RBRACE
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    RBRACE          shift and go to state 183
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138


state 165

    (75) exp -> exp BY exp .
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    PLUS            reduce using rule 75 (exp -> exp BY exp .)
    TIMES           reduce using rule 75 (exp -> exp BY exp .)
    MINUS           reduce using rule 75 (exp -> exp BY exp .)
    BY              reduce using rule 75 (exp -> exp BY exp .)
    RPAR            reduce using rule 75 (exp -> exp BY exp .)
    NL              reduce using rule 75 (exp -> exp BY exp .)
    COLON           reduce using rule 75 (exp -> exp BY exp .)
    COMMA           reduce using rule 75 (exp -> exp BY exp .)
    RBRACE          reduce using rule 75 (exp -> exp BY exp .)
    AND             reduce using rule 75 (exp -> exp BY exp .)
    OR              reduce using rule 75 (exp -> exp BY exp .)
    EQ              reduce using rule 75 (exp -> exp BY exp .)
    NEQ             reduce using rule 75 (exp -> exp BY exp .)
    GEQ             reduce using rule 75 (exp -> exp BY exp .)
    LEQ             reduce using rule 75 (exp -> exp BY exp .)
    GT              reduce using rule 75 (exp -> exp BY exp .)
    LT              reduce using rule 75 (exp -> exp BY exp .)

  ! PLUS            [ shift and go to state 139 ]
  ! TIMES           [ shift and go to state 140 ]
  ! MINUS           [ shift and go to state 141 ]
  ! BY              [ shift and go to state 138 ]


state 166

    (72) exp -> exp PLUS exp .
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    PLUS            reduce using rule 72 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 72 (exp -> exp PLUS exp .)
    RPAR            reduce using rule 72 (exp -> exp PLUS exp .)
    NL              reduce using rule 72 (exp -> exp PLUS exp .)
    COLON           reduce using rule 72 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 72 (exp -> exp PLUS exp .)
    RBRACE          reduce using rule 72 (exp -> exp PLUS exp .)
    AND             reduce using rule 72 (exp -> exp PLUS exp .)
    OR              reduce using rule 72 (exp -> exp PLUS exp .)
    EQ              reduce using rule 72 (exp -> exp PLUS exp .)
    NEQ             reduce using rule 72 (exp -> exp PLUS exp .)
    GEQ             reduce using rule 72 (exp -> exp PLUS exp .)
    LEQ             reduce using rule 72 (exp -> exp PLUS exp .)
    GT              reduce using rule 72 (exp -> exp PLUS exp .)
    LT              reduce using rule 72 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 140
    BY              shift and go to state 138

  ! TIMES           [ reduce using rule 72 (exp -> exp PLUS exp .) ]
  ! BY              [ reduce using rule 72 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 141 ]


state 167

    (73) exp -> exp TIMES exp .
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    PLUS            reduce using rule 73 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 73 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 73 (exp -> exp TIMES exp .)
    BY              reduce using rule 73 (exp -> exp TIMES exp .)
    RPAR            reduce using rule 73 (exp -> exp TIMES exp .)
    NL              reduce using rule 73 (exp -> exp TIMES exp .)
    COLON           reduce using rule 73 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 73 (exp -> exp TIMES exp .)
    RBRACE          reduce using rule 73 (exp -> exp TIMES exp .)
    AND             reduce using rule 73 (exp -> exp TIMES exp .)
    OR              reduce using rule 73 (exp -> exp TIMES exp .)
    EQ              reduce using rule 73 (exp -> exp TIMES exp .)
    NEQ             reduce using rule 73 (exp -> exp TIMES exp .)
    GEQ             reduce using rule 73 (exp -> exp TIMES exp .)
    LEQ             reduce using rule 73 (exp -> exp TIMES exp .)
    GT              reduce using rule 73 (exp -> exp TIMES exp .)
    LT              reduce using rule 73 (exp -> exp TIMES exp .)

  ! PLUS            [ shift and go to state 139 ]
  ! TIMES           [ shift and go to state 140 ]
  ! MINUS           [ shift and go to state 141 ]
  ! BY              [ shift and go to state 138 ]


state 168

    (74) exp -> exp MINUS exp .
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    PLUS            reduce using rule 74 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 74 (exp -> exp MINUS exp .)
    RPAR            reduce using rule 74 (exp -> exp MINUS exp .)
    NL              reduce using rule 74 (exp -> exp MINUS exp .)
    COLON           reduce using rule 74 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 74 (exp -> exp MINUS exp .)
    RBRACE          reduce using rule 74 (exp -> exp MINUS exp .)
    AND             reduce using rule 74 (exp -> exp MINUS exp .)
    OR              reduce using rule 74 (exp -> exp MINUS exp .)
    EQ              reduce using rule 74 (exp -> exp MINUS exp .)
    NEQ             reduce using rule 74 (exp -> exp MINUS exp .)
    GEQ             reduce using rule 74 (exp -> exp MINUS exp .)
    LEQ             reduce using rule 74 (exp -> exp MINUS exp .)
    GT              reduce using rule 74 (exp -> exp MINUS exp .)
    LT              reduce using rule 74 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 140
    BY              shift and go to state 138

  ! TIMES           [ reduce using rule 74 (exp -> exp MINUS exp .) ]
  ! BY              [ reduce using rule 74 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 141 ]


state 169

    (11) actuatordecls -> ACTUATORS COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 184


state 170

    (13) sensordecls -> SENSORS COLON NL INDENT . decls DEDENT
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (100) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 100 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    decl                           shift and go to state 39
    decls                          shift and go to state 185
    type                           shift and go to state 45
    empty                          shift and go to state 47

state 171

    (27) rvdecl -> type varname LBRACE owner RBRACE NL .

    INT             reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    STRING          reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    FLOAT           reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    IPOS            reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    BOOLEAN         reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    DEDENT          reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)


state 172

    (63) stmt -> ATOMIC COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 186


state 173

    (49) cond -> LPAR cond . AND cond RPAR
    (50) cond -> LPAR cond . OR cond RPAR
    (51) cond -> LPAR cond . op cond RPAR
    (53) cond -> LPAR cond . RPAR
    (94) op -> . EQ
    (95) op -> . NEQ
    (96) op -> . GEQ
    (97) op -> . LEQ
    (98) op -> . GT
    (99) op -> . LT

    AND             shift and go to state 187
    OR              shift and go to state 195
    RPAR            shift and go to state 190
    EQ              shift and go to state 194
    NEQ             shift and go to state 193
    GEQ             shift and go to state 188
    LEQ             shift and go to state 191
    GT              shift and go to state 189
    LT              shift and go to state 192

    op                             shift and go to state 196

state 174

    (85) bracketexp -> LPAR exp . RPAR
    (54) cond -> exp .
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

  ! shift/reduce conflict for RPAR resolved as shift
    RPAR            shift and go to state 157
    AND             reduce using rule 54 (cond -> exp .)
    OR              reduce using rule 54 (cond -> exp .)
    EQ              reduce using rule 54 (cond -> exp .)
    NEQ             reduce using rule 54 (cond -> exp .)
    GEQ             reduce using rule 54 (cond -> exp .)
    LEQ             reduce using rule 54 (cond -> exp .)
    GT              reduce using rule 54 (cond -> exp .)
    LT              reduce using rule 54 (cond -> exp .)
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138

  ! RPAR            [ reduce using rule 54 (cond -> exp .) ]


state 175

    (52) cond -> LPAR NOT . cond RPAR
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . LPAR cond RPAR
    (54) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 151
    PID             shift and go to state 100
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    moduleflag                     shift and go to state 101
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    null                           shift and go to state 98
    num                            shift and go to state 96
    cond                           shift and go to state 197
    exp                            shift and go to state 153
    bval                           shift and go to state 97

state 176

    (64) stmt -> IF cond COLON . NL INDENT stmts DEDENT elseblock

    NL              shift and go to state 198


state 177

    (69) asgn -> varname ASGN exp . NL
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    NL              shift and go to state 199
    PLUS            shift and go to state 139
    TIMES           shift and go to state 140
    MINUS           shift and go to state 141
    BY              shift and go to state 138


state 178

    (70) wptstmt -> varname ASGN GETINPUT . LPAR RPAR NL

    LPAR            shift and go to state 200


state 179

    (45) event -> LID COLON NL INDENT PRE COLON . cond NL effblock DEDENT
    (46) event -> LID COLON NL INDENT PRE COLON . CID NL effblock DEDENT
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . LPAR cond RPAR
    (54) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    CID             shift and go to state 201
    LPAR            shift and go to state 151
    PID             shift and go to state 100
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104

    bracketexp                     shift and go to state 93
    moduleflag                     shift and go to state 101
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    null                           shift and go to state 98
    num                            shift and go to state 96
    cond                           shift and go to state 202
    exp                            shift and go to state 153
    bval                           shift and go to state 97

state 180

    (65) modulefunccall -> CID LPAR args RPAR .

    PLUS            reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    TIMES           reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    MINUS           reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    BY              reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    RPAR            reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    NL              reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    COLON           reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    COMMA           reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    RBRACE          reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    AND             reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    OR              reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    EQ              reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    NEQ             reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    GEQ             reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    LEQ             reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    GT              reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)
    LT              reduce using rule 65 (modulefunccall -> CID LPAR args RPAR .)


state 181

    (35) neargs -> exp COMMA . neargs
    (34) neargs -> . exp
    (35) neargs -> . exp COMMA neargs
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    PID             shift and go to state 100
    LPAR            shift and go to state 92
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    moduleflag                     shift and go to state 101
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 162
    neargs                         shift and go to state 203
    bval                           shift and go to state 97

state 182

    (30) funccall -> varname LPAR args RPAR .

    NL              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    PLUS            reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    TIMES           reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    MINUS           reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    BY              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    RPAR            reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    AND             reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    OR              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    EQ              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    NEQ             reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    GEQ             reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    LEQ             reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    GT              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    LT              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    COMMA           reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    COLON           reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    RBRACE          reduce using rule 30 (funccall -> varname LPAR args RPAR .)


state 183

    (77) exp -> varname LBRACE exp RBRACE .

    PLUS            reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    TIMES           reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    MINUS           reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    BY              reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    RPAR            reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    NL              reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    COLON           reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    COMMA           reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    RBRACE          reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    AND             reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    OR              reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    EQ              reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    NEQ             reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    GEQ             reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    LEQ             reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    GT              reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)
    LT              reduce using rule 77 (exp -> varname LBRACE exp RBRACE .)


state 184

    (11) actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT .

    SENSORS         reduce using rule 11 (actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT .)
    DEDENT          reduce using rule 11 (actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT .)


state 185

    (13) sensordecls -> SENSORS COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 204


state 186

    (63) stmt -> ATOMIC COLON NL INDENT . stmts DEDENT
    (55) stmts -> . stmt stmts
    (56) stmts -> . empty
    (57) stmt -> . asgn
    (58) stmt -> . wptstmt
    (59) stmt -> . pass
    (60) stmt -> . EXIT NL
    (61) stmt -> . funccall NL
    (62) stmt -> . modulefunccall NL
    (63) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (64) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (100) empty -> .
    (69) asgn -> . varname ASGN exp NL
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (68) pass -> . PASS NL
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE

    EXIT            shift and go to state 128
    ATOMIC          shift and go to state 116
    IF              shift and go to state 125
    DEDENT          reduce using rule 100 (empty -> .)
    PASS            shift and go to state 124
    CID             shift and go to state 115
    LID             shift and go to state 61
    STAGE           shift and go to state 63

    funccall                       shift and go to state 121
    stmts                          shift and go to state 205
    varname                        shift and go to state 126
    stmt                           shift and go to state 123
    asgn                           shift and go to state 119
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    pass                           shift and go to state 117
    empty                          shift and go to state 120

state 187

    (49) cond -> LPAR cond AND . cond RPAR
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . LPAR cond RPAR
    (54) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 151
    PID             shift and go to state 100
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    moduleflag                     shift and go to state 101
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    null                           shift and go to state 98
    num                            shift and go to state 96
    cond                           shift and go to state 206
    exp                            shift and go to state 153
    bval                           shift and go to state 97

state 188

    (96) op -> GEQ .

    LPAR            reduce using rule 96 (op -> GEQ .)
    PID             reduce using rule 96 (op -> GEQ .)
    LID             reduce using rule 96 (op -> GEQ .)
    STAGE           reduce using rule 96 (op -> GEQ .)
    TRUE            reduce using rule 96 (op -> GEQ .)
    FALSE           reduce using rule 96 (op -> GEQ .)
    INUM            reduce using rule 96 (op -> GEQ .)
    FNUM            reduce using rule 96 (op -> GEQ .)
    NULL            reduce using rule 96 (op -> GEQ .)
    CID             reduce using rule 96 (op -> GEQ .)


state 189

    (98) op -> GT .

    LPAR            reduce using rule 98 (op -> GT .)
    PID             reduce using rule 98 (op -> GT .)
    LID             reduce using rule 98 (op -> GT .)
    STAGE           reduce using rule 98 (op -> GT .)
    TRUE            reduce using rule 98 (op -> GT .)
    FALSE           reduce using rule 98 (op -> GT .)
    INUM            reduce using rule 98 (op -> GT .)
    FNUM            reduce using rule 98 (op -> GT .)
    NULL            reduce using rule 98 (op -> GT .)
    CID             reduce using rule 98 (op -> GT .)


state 190

    (53) cond -> LPAR cond RPAR .

    RPAR            reduce using rule 53 (cond -> LPAR cond RPAR .)
    COLON           reduce using rule 53 (cond -> LPAR cond RPAR .)
    AND             reduce using rule 53 (cond -> LPAR cond RPAR .)
    OR              reduce using rule 53 (cond -> LPAR cond RPAR .)
    EQ              reduce using rule 53 (cond -> LPAR cond RPAR .)
    NEQ             reduce using rule 53 (cond -> LPAR cond RPAR .)
    GEQ             reduce using rule 53 (cond -> LPAR cond RPAR .)
    LEQ             reduce using rule 53 (cond -> LPAR cond RPAR .)
    GT              reduce using rule 53 (cond -> LPAR cond RPAR .)
    LT              reduce using rule 53 (cond -> LPAR cond RPAR .)
    NL              reduce using rule 53 (cond -> LPAR cond RPAR .)


state 191

    (97) op -> LEQ .

    LPAR            reduce using rule 97 (op -> LEQ .)
    PID             reduce using rule 97 (op -> LEQ .)
    LID             reduce using rule 97 (op -> LEQ .)
    STAGE           reduce using rule 97 (op -> LEQ .)
    TRUE            reduce using rule 97 (op -> LEQ .)
    FALSE           reduce using rule 97 (op -> LEQ .)
    INUM            reduce using rule 97 (op -> LEQ .)
    FNUM            reduce using rule 97 (op -> LEQ .)
    NULL            reduce using rule 97 (op -> LEQ .)
    CID             reduce using rule 97 (op -> LEQ .)


state 192

    (99) op -> LT .

    LPAR            reduce using rule 99 (op -> LT .)
    PID             reduce using rule 99 (op -> LT .)
    LID             reduce using rule 99 (op -> LT .)
    STAGE           reduce using rule 99 (op -> LT .)
    TRUE            reduce using rule 99 (op -> LT .)
    FALSE           reduce using rule 99 (op -> LT .)
    INUM            reduce using rule 99 (op -> LT .)
    FNUM            reduce using rule 99 (op -> LT .)
    NULL            reduce using rule 99 (op -> LT .)
    CID             reduce using rule 99 (op -> LT .)


state 193

    (95) op -> NEQ .

    LPAR            reduce using rule 95 (op -> NEQ .)
    PID             reduce using rule 95 (op -> NEQ .)
    LID             reduce using rule 95 (op -> NEQ .)
    STAGE           reduce using rule 95 (op -> NEQ .)
    TRUE            reduce using rule 95 (op -> NEQ .)
    FALSE           reduce using rule 95 (op -> NEQ .)
    INUM            reduce using rule 95 (op -> NEQ .)
    FNUM            reduce using rule 95 (op -> NEQ .)
    NULL            reduce using rule 95 (op -> NEQ .)
    CID             reduce using rule 95 (op -> NEQ .)


state 194

    (94) op -> EQ .

    LPAR            reduce using rule 94 (op -> EQ .)
    PID             reduce using rule 94 (op -> EQ .)
    LID             reduce using rule 94 (op -> EQ .)
    STAGE           reduce using rule 94 (op -> EQ .)
    TRUE            reduce using rule 94 (op -> EQ .)
    FALSE           reduce using rule 94 (op -> EQ .)
    INUM            reduce using rule 94 (op -> EQ .)
    FNUM            reduce using rule 94 (op -> EQ .)
    NULL            reduce using rule 94 (op -> EQ .)
    CID             reduce using rule 94 (op -> EQ .)


state 195

    (50) cond -> LPAR cond OR . cond RPAR
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . LPAR cond RPAR
    (54) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 151
    PID             shift and go to state 100
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    moduleflag                     shift and go to state 101
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    null                           shift and go to state 98
    num                            shift and go to state 96
    cond                           shift and go to state 207
    exp                            shift and go to state 153
    bval                           shift and go to state 97

state 196

    (51) cond -> LPAR cond op . cond RPAR
    (49) cond -> . LPAR cond AND cond RPAR
    (50) cond -> . LPAR cond OR cond RPAR
    (51) cond -> . LPAR cond op cond RPAR
    (52) cond -> . LPAR NOT cond RPAR
    (53) cond -> . LPAR cond RPAR
    (54) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . varname LBRACE exp RBRACE
    (78) exp -> . bval
    (79) exp -> . PID
    (80) exp -> . num
    (81) exp -> . null
    (82) exp -> . moduleflag
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE
    (87) bval -> . TRUE
    (88) bval -> . FALSE
    (89) num -> . INUM
    (90) num -> . FNUM
    (93) null -> . NULL
    (86) moduleflag -> . CID
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 151
    PID             shift and go to state 100
    LID             shift and go to state 61
    STAGE           shift and go to state 63
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    INUM            shift and go to state 108
    FNUM            shift and go to state 95
    NULL            shift and go to state 104
    CID             shift and go to state 94

    bracketexp                     shift and go to state 93
    moduleflag                     shift and go to state 101
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    null                           shift and go to state 98
    num                            shift and go to state 96
    cond                           shift and go to state 208
    exp                            shift and go to state 153
    bval                           shift and go to state 97

state 197

    (52) cond -> LPAR NOT cond . RPAR

    RPAR            shift and go to state 209


state 198

    (64) stmt -> IF cond COLON NL . INDENT stmts DEDENT elseblock

    INDENT          shift and go to state 210


state 199

    (69) asgn -> varname ASGN exp NL .

    EXIT            reduce using rule 69 (asgn -> varname ASGN exp NL .)
    ATOMIC          reduce using rule 69 (asgn -> varname ASGN exp NL .)
    IF              reduce using rule 69 (asgn -> varname ASGN exp NL .)
    PASS            reduce using rule 69 (asgn -> varname ASGN exp NL .)
    CID             reduce using rule 69 (asgn -> varname ASGN exp NL .)
    LID             reduce using rule 69 (asgn -> varname ASGN exp NL .)
    STAGE           reduce using rule 69 (asgn -> varname ASGN exp NL .)
    DEDENT          reduce using rule 69 (asgn -> varname ASGN exp NL .)


state 200

    (70) wptstmt -> varname ASGN GETINPUT LPAR . RPAR NL

    RPAR            shift and go to state 211


state 201

    (46) event -> LID COLON NL INDENT PRE COLON CID . NL effblock DEDENT
    (86) moduleflag -> CID .
    (65) modulefunccall -> CID . LPAR args RPAR

  ! shift/reduce conflict for NL resolved as shift
    NL              shift and go to state 212
    PLUS            reduce using rule 86 (moduleflag -> CID .)
    TIMES           reduce using rule 86 (moduleflag -> CID .)
    MINUS           reduce using rule 86 (moduleflag -> CID .)
    BY              reduce using rule 86 (moduleflag -> CID .)
    LPAR            shift and go to state 134

  ! NL              [ reduce using rule 86 (moduleflag -> CID .) ]


state 202

    (45) event -> LID COLON NL INDENT PRE COLON cond . NL effblock DEDENT

    NL              shift and go to state 213


state 203

    (35) neargs -> exp COMMA neargs .

    RPAR            reduce using rule 35 (neargs -> exp COMMA neargs .)


state 204

    (13) sensordecls -> SENSORS COLON NL INDENT decls DEDENT .

    DEDENT          reduce using rule 13 (sensordecls -> SENSORS COLON NL INDENT decls DEDENT .)


state 205

    (63) stmt -> ATOMIC COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 214


state 206

    (49) cond -> LPAR cond AND cond . RPAR

    RPAR            shift and go to state 215


state 207

    (50) cond -> LPAR cond OR cond . RPAR

    RPAR            shift and go to state 216


state 208

    (51) cond -> LPAR cond op cond . RPAR

    RPAR            shift and go to state 217


state 209

    (52) cond -> LPAR NOT cond RPAR .

    RPAR            reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    COLON           reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    AND             reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    OR              reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    EQ              reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    NEQ             reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    GEQ             reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    LEQ             reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    GT              reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    LT              reduce using rule 52 (cond -> LPAR NOT cond RPAR .)
    NL              reduce using rule 52 (cond -> LPAR NOT cond RPAR .)


state 210

    (64) stmt -> IF cond COLON NL INDENT . stmts DEDENT elseblock
    (55) stmts -> . stmt stmts
    (56) stmts -> . empty
    (57) stmt -> . asgn
    (58) stmt -> . wptstmt
    (59) stmt -> . pass
    (60) stmt -> . EXIT NL
    (61) stmt -> . funccall NL
    (62) stmt -> . modulefunccall NL
    (63) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (64) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (100) empty -> .
    (69) asgn -> . varname ASGN exp NL
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (68) pass -> . PASS NL
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE

    EXIT            shift and go to state 128
    ATOMIC          shift and go to state 116
    IF              shift and go to state 125
    DEDENT          reduce using rule 100 (empty -> .)
    PASS            shift and go to state 124
    CID             shift and go to state 115
    LID             shift and go to state 61
    STAGE           shift and go to state 63

    funccall                       shift and go to state 121
    stmts                          shift and go to state 218
    varname                        shift and go to state 126
    stmt                           shift and go to state 123
    asgn                           shift and go to state 119
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    pass                           shift and go to state 117
    empty                          shift and go to state 120

state 211

    (70) wptstmt -> varname ASGN GETINPUT LPAR RPAR . NL

    NL              shift and go to state 219


state 212

    (46) event -> LID COLON NL INDENT PRE COLON CID NL . effblock DEDENT
    (47) effblock -> . EFF COLON NL INDENT stmts DEDENT
    (48) effblock -> . EFF COLON stmt

    EFF             shift and go to state 221

    effblock                       shift and go to state 220

state 213

    (45) event -> LID COLON NL INDENT PRE COLON cond NL . effblock DEDENT
    (47) effblock -> . EFF COLON NL INDENT stmts DEDENT
    (48) effblock -> . EFF COLON stmt

    EFF             shift and go to state 221

    effblock                       shift and go to state 222

state 214

    (63) stmt -> ATOMIC COLON NL INDENT stmts DEDENT .

    DEDENT          reduce using rule 63 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    EXIT            reduce using rule 63 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    ATOMIC          reduce using rule 63 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    IF              reduce using rule 63 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    PASS            reduce using rule 63 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    CID             reduce using rule 63 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    LID             reduce using rule 63 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    STAGE           reduce using rule 63 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)


state 215

    (49) cond -> LPAR cond AND cond RPAR .

    RPAR            reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    COLON           reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    AND             reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    OR              reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    EQ              reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    NEQ             reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    GEQ             reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    LEQ             reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    GT              reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    LT              reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)
    NL              reduce using rule 49 (cond -> LPAR cond AND cond RPAR .)


state 216

    (50) cond -> LPAR cond OR cond RPAR .

    RPAR            reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    COLON           reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    AND             reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    OR              reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    EQ              reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    NEQ             reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    GEQ             reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    LEQ             reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    GT              reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    LT              reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)
    NL              reduce using rule 50 (cond -> LPAR cond OR cond RPAR .)


state 217

    (51) cond -> LPAR cond op cond RPAR .

    RPAR            reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    COLON           reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    AND             reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    OR              reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    EQ              reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    NEQ             reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    GEQ             reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    LEQ             reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    GT              reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    LT              reduce using rule 51 (cond -> LPAR cond op cond RPAR .)
    NL              reduce using rule 51 (cond -> LPAR cond op cond RPAR .)


state 218

    (64) stmt -> IF cond COLON NL INDENT stmts . DEDENT elseblock

    DEDENT          shift and go to state 223


state 219

    (70) wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .

    EXIT            reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    ATOMIC          reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    IF              reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    PASS            reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    CID             reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    LID             reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    STAGE           reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    DEDENT          reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)


state 220

    (46) event -> LID COLON NL INDENT PRE COLON CID NL effblock . DEDENT

    DEDENT          shift and go to state 224


state 221

    (47) effblock -> EFF . COLON NL INDENT stmts DEDENT
    (48) effblock -> EFF . COLON stmt

    COLON           shift and go to state 225


state 222

    (45) event -> LID COLON NL INDENT PRE COLON cond NL effblock . DEDENT

    DEDENT          shift and go to state 226


state 223

    (64) stmt -> IF cond COLON NL INDENT stmts DEDENT . elseblock
    (66) elseblock -> . ELSE COLON NL INDENT stmts DEDENT
    (67) elseblock -> . empty
    (100) empty -> .

    ELSE            shift and go to state 228
    EXIT            reduce using rule 100 (empty -> .)
    ATOMIC          reduce using rule 100 (empty -> .)
    IF              reduce using rule 100 (empty -> .)
    PASS            reduce using rule 100 (empty -> .)
    CID             reduce using rule 100 (empty -> .)
    LID             reduce using rule 100 (empty -> .)
    STAGE           reduce using rule 100 (empty -> .)
    DEDENT          reduce using rule 100 (empty -> .)

    elseblock                      shift and go to state 227
    empty                          shift and go to state 229

state 224

    (46) event -> LID COLON NL INDENT PRE COLON CID NL effblock DEDENT .

    LID             reduce using rule 46 (event -> LID COLON NL INDENT PRE COLON CID NL effblock DEDENT .)
    NUM             reduce using rule 46 (event -> LID COLON NL INDENT PRE COLON CID NL effblock DEDENT .)


state 225

    (47) effblock -> EFF COLON . NL INDENT stmts DEDENT
    (48) effblock -> EFF COLON . stmt
    (57) stmt -> . asgn
    (58) stmt -> . wptstmt
    (59) stmt -> . pass
    (60) stmt -> . EXIT NL
    (61) stmt -> . funccall NL
    (62) stmt -> . modulefunccall NL
    (63) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (64) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (69) asgn -> . varname ASGN exp NL
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (68) pass -> . PASS NL
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE

    NL              shift and go to state 230
    EXIT            shift and go to state 128
    ATOMIC          shift and go to state 116
    IF              shift and go to state 125
    PASS            shift and go to state 124
    CID             shift and go to state 115
    LID             shift and go to state 61
    STAGE           shift and go to state 63

    funccall                       shift and go to state 121
    varname                        shift and go to state 126
    stmt                           shift and go to state 231
    asgn                           shift and go to state 119
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    pass                           shift and go to state 117

state 226

    (45) event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .

    LID             reduce using rule 45 (event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .)
    NUM             reduce using rule 45 (event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .)


state 227

    (64) stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .

    DEDENT          reduce using rule 64 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    EXIT            reduce using rule 64 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    ATOMIC          reduce using rule 64 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    IF              reduce using rule 64 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    PASS            reduce using rule 64 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    CID             reduce using rule 64 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    LID             reduce using rule 64 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    STAGE           reduce using rule 64 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)


state 228

    (66) elseblock -> ELSE . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 232


state 229

    (67) elseblock -> empty .

    EXIT            reduce using rule 67 (elseblock -> empty .)
    ATOMIC          reduce using rule 67 (elseblock -> empty .)
    IF              reduce using rule 67 (elseblock -> empty .)
    PASS            reduce using rule 67 (elseblock -> empty .)
    CID             reduce using rule 67 (elseblock -> empty .)
    LID             reduce using rule 67 (elseblock -> empty .)
    STAGE           reduce using rule 67 (elseblock -> empty .)
    DEDENT          reduce using rule 67 (elseblock -> empty .)


state 230

    (47) effblock -> EFF COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 233


state 231

    (48) effblock -> EFF COLON stmt .

    DEDENT          reduce using rule 48 (effblock -> EFF COLON stmt .)


state 232

    (66) elseblock -> ELSE COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 234


state 233

    (47) effblock -> EFF COLON NL INDENT . stmts DEDENT
    (55) stmts -> . stmt stmts
    (56) stmts -> . empty
    (57) stmt -> . asgn
    (58) stmt -> . wptstmt
    (59) stmt -> . pass
    (60) stmt -> . EXIT NL
    (61) stmt -> . funccall NL
    (62) stmt -> . modulefunccall NL
    (63) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (64) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (100) empty -> .
    (69) asgn -> . varname ASGN exp NL
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (68) pass -> . PASS NL
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE

    EXIT            shift and go to state 128
    ATOMIC          shift and go to state 116
    IF              shift and go to state 125
    DEDENT          reduce using rule 100 (empty -> .)
    PASS            shift and go to state 124
    CID             shift and go to state 115
    LID             shift and go to state 61
    STAGE           shift and go to state 63

    funccall                       shift and go to state 121
    stmts                          shift and go to state 235
    varname                        shift and go to state 126
    stmt                           shift and go to state 123
    asgn                           shift and go to state 119
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    pass                           shift and go to state 117
    empty                          shift and go to state 120

state 234

    (66) elseblock -> ELSE COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 236


state 235

    (47) effblock -> EFF COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 237


state 236

    (66) elseblock -> ELSE COLON NL INDENT . stmts DEDENT
    (55) stmts -> . stmt stmts
    (56) stmts -> . empty
    (57) stmt -> . asgn
    (58) stmt -> . wptstmt
    (59) stmt -> . pass
    (60) stmt -> . EXIT NL
    (61) stmt -> . funccall NL
    (62) stmt -> . modulefunccall NL
    (63) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (64) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (100) empty -> .
    (69) asgn -> . varname ASGN exp NL
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (68) pass -> . PASS NL
    (30) funccall -> . varname LPAR args RPAR
    (65) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (92) varname -> . STAGE

    EXIT            shift and go to state 128
    ATOMIC          shift and go to state 116
    IF              shift and go to state 125
    DEDENT          reduce using rule 100 (empty -> .)
    PASS            shift and go to state 124
    CID             shift and go to state 115
    LID             shift and go to state 61
    STAGE           shift and go to state 63

    funccall                       shift and go to state 121
    stmts                          shift and go to state 238
    varname                        shift and go to state 126
    stmt                           shift and go to state 123
    asgn                           shift and go to state 119
    modulefunccall                 shift and go to state 122
    wptstmt                        shift and go to state 127
    pass                           shift and go to state 117
    empty                          shift and go to state 120

state 237

    (47) effblock -> EFF COLON NL INDENT stmts DEDENT .

    DEDENT          reduce using rule 47 (effblock -> EFF COLON NL INDENT stmts DEDENT .)


state 238

    (66) elseblock -> ELSE COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 239


state 239

    (66) elseblock -> ELSE COLON NL INDENT stmts DEDENT .

    EXIT            reduce using rule 66 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    ATOMIC          reduce using rule 66 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    IF              reduce using rule 66 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    PASS            reduce using rule 66 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    CID             reduce using rule 66 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    LID             reduce using rule 66 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    STAGE           reduce using rule 66 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    DEDENT          reduce using rule 66 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAR in state 174 resolved as shift
WARNING: shift/reduce conflict for NL in state 201 resolved as shift
