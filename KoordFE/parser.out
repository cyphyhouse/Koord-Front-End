Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Unused terminals:

    WS

Grammar

Rule 0     S' -> program
Rule 1     program -> agent modules awdecls ardecls locdecls init events
Rule 2     agent -> AGENT CID NL
Rule 3     modules -> module modules
Rule 4     modules -> module
Rule 5     module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT
Rule 6     actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT
Rule 7     actuatordecls -> ACTUATORS COLON NL INDENT pass DEDENT
Rule 8     sensordecls -> SENSORS COLON NL INDENT decls DEDENT
Rule 9     sensordecls -> SENSORS COLON NL INDENT pass DEDENT
Rule 10    awdecls -> ALLWRITE COLON NL INDENT decls DEDENT
Rule 11    awdecls -> ALLWRITE COLON NL INDENT pass DEDENT
Rule 12    ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT
Rule 13    ardecls -> ALLREAD COLON NL INDENT pass DEDENT
Rule 14    locdecls -> LOCAL COLON NL INDENT decls DEDENT
Rule 15    decls -> decl decls
Rule 16    decls -> type varnames NL
Rule 17    decls -> empty
Rule 18    decl -> type varname ASGN exp NL
Rule 19    decl -> mapdecl NL
Rule 20    mapdecl -> MAP LT type COMMA type GT varname
Rule 21    rvdecls -> rvdecl rvdecls
Rule 22    rvdecls -> empty
Rule 23    rvdecl -> type varname LBRACE owner RBRACE NL
Rule 24    rvdecl -> type varname LBRACE owner RBRACE ASGN num NL
Rule 25    owner -> TIMES
Rule 26    owner -> INUM
Rule 27    funccall -> varname LPAR args RPAR
Rule 28    args -> neargs
Rule 29    args -> noargs
Rule 30    noargs -> empty
Rule 31    neargs -> exp
Rule 32    neargs -> exp COMMA neargs
Rule 33    varnames -> varname
Rule 34    varnames -> varname COMMA varnames
Rule 35    type -> INT
Rule 36    type -> STRING
Rule 37    type -> FLOAT
Rule 38    type -> IPOS
Rule 39    type -> BOOLEAN
Rule 40    init -> INIT COLON NL INDENT stmts DEDENT
Rule 41    init -> empty
Rule 42    events -> event events
Rule 43    events -> empty
Rule 44    event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT
Rule 45    effblock -> EFF COLON NL INDENT stmts DEDENT
Rule 46    effblock -> EFF COLON stmt
Rule 47    cond -> LPAR cond AND cond RPAR
Rule 48    cond -> LPAR cond OR cond RPAR
Rule 49    cond -> LPAR cond op cond RPAR
Rule 50    cond -> LPAR NOT cond RPAR
Rule 51    cond -> exp
Rule 52    stmts -> stmt stmts
Rule 53    stmts -> empty
Rule 54    stmt -> asgn
Rule 55    stmt -> pass
Rule 56    stmt -> funccall NL
Rule 57    stmt -> modulefunccall NL
Rule 58    stmt -> ATOMIC COLON NL INDENT stmts DEDENT
Rule 59    stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock
Rule 60    modulefunccall -> CID LPAR args RPAR
Rule 61    elseblock -> ELSE COLON NL INDENT stmts DEDENT
Rule 62    pass -> PASS NL
Rule 63    asgn -> varname ASGN exp NL
Rule 64    exp -> bracketexp
Rule 65    exp -> exp PLUS exp
Rule 66    exp -> exp TIMES exp
Rule 67    exp -> exp MINUS exp
Rule 68    exp -> exp BY exp
Rule 69    exp -> varname
Rule 70    exp -> bval
Rule 71    exp -> num
Rule 72    exp -> funccall
Rule 73    bracketexp -> LPAR exp RPAR
Rule 74    bval -> TRUE
Rule 75    bval -> FALSE
Rule 76    num -> INUM
Rule 77    num -> FNUM
Rule 78    varname -> LID
Rule 79    op -> EQ
Rule 80    op -> NEQ
Rule 81    op -> GEQ
Rule 82    op -> LEQ
Rule 83    op -> GT
Rule 84    op -> LT
Rule 85    empty -> <empty>

Terminals, with rules where they appear

ACTUATORS            : 6 7
AGENT                : 2
ALLREAD              : 12 13
ALLWRITE             : 10 11
AND                  : 47
ASGN                 : 18 24 63
ATOMIC               : 58
BOOLEAN              : 39
BY                   : 68
CID                  : 2 5 60
COLON                : 5 6 7 8 9 10 11 12 13 14 40 44 44 45 46 58 59 61
COMMA                : 20 32 34
DEDENT               : 5 6 7 8 9 10 11 12 13 14 40 44 45 58 59 61
EFF                  : 45 46
ELSE                 : 61
EQ                   : 79
FALSE                : 75
FLOAT                : 37
FNUM                 : 77
GEQ                  : 81
GT                   : 20 83
IF                   : 59
INDENT               : 5 6 7 8 9 10 11 12 13 14 40 44 45 58 59 61
INIT                 : 40
INT                  : 35
INUM                 : 26 76
IPOS                 : 38
LBRACE               : 23 24
LEQ                  : 82
LID                  : 44 78
LOCAL                : 14
LPAR                 : 27 47 48 49 50 60 73
LT                   : 20 84
MAP                  : 20
MINUS                : 67
MODULE               : 5
NEQ                  : 80
NL                   : 2 5 6 7 8 9 10 11 12 13 14 16 18 19 23 24 40 44 44 45 56 57 58 59 61 62 63
NOT                  : 50
OR                   : 48
PASS                 : 62
PLUS                 : 65
PRE                  : 44
RBRACE               : 23 24
RPAR                 : 27 47 48 49 50 60 73
SENSORS              : 8 9
STRING               : 36
TIMES                : 25 66
TRUE                 : 74
USING                : 5
WS                   : 
error                : 

Nonterminals, with rules where they appear

actuatordecls        : 5
agent                : 1
ardecls              : 1
args                 : 27 60
asgn                 : 54
awdecls              : 1
bracketexp           : 64
bval                 : 70
cond                 : 44 47 47 48 48 49 49 50 59
decl                 : 15
decls                : 6 8 10 14 15
effblock             : 44
elseblock            : 59
empty                : 17 22 30 41 43 53
event                : 42
events               : 1 42
exp                  : 18 31 32 51 63 65 65 66 66 67 67 68 68 73
funccall             : 56 72
init                 : 1
locdecls             : 1
mapdecl              : 19
module               : 3 4
modulefunccall       : 57
modules              : 1 3
neargs               : 28 32
noargs               : 29
num                  : 24 71
op                   : 49
owner                : 23 24
pass                 : 7 9 11 13 55
program              : 0
rvdecl               : 21
rvdecls              : 12 21
sensordecls          : 5
stmt                 : 46 52
stmts                : 40 45 52 58 59 61
type                 : 16 18 20 20 23 24
varname              : 18 20 23 24 27 33 34 63 69
varnames             : 16 34

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . agent modules awdecls ardecls locdecls init events
    (2) agent -> . AGENT CID NL

    AGENT           shift and go to state 3

    agent                          shift and go to state 1
    program                        shift and go to state 2

state 1

    (1) program -> agent . modules awdecls ardecls locdecls init events
    (3) modules -> . module modules
    (4) modules -> . module
    (5) module -> . USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT

    USING           shift and go to state 6

    modules                        shift and go to state 4
    module                         shift and go to state 5

state 2

    (0) S' -> program .



state 3

    (2) agent -> AGENT . CID NL

    CID             shift and go to state 7


state 4

    (1) program -> agent modules . awdecls ardecls locdecls init events
    (10) awdecls -> . ALLWRITE COLON NL INDENT decls DEDENT
    (11) awdecls -> . ALLWRITE COLON NL INDENT pass DEDENT

    ALLWRITE        shift and go to state 9

    awdecls                        shift and go to state 8

state 5

    (3) modules -> module . modules
    (4) modules -> module .
    (3) modules -> . module modules
    (4) modules -> . module
    (5) module -> . USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT

    ALLWRITE        reduce using rule 4 (modules -> module .)
    USING           shift and go to state 6

    modules                        shift and go to state 10
    module                         shift and go to state 5

state 6

    (5) module -> USING . MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT

    MODULE          shift and go to state 11


state 7

    (2) agent -> AGENT CID . NL

    NL              shift and go to state 12


state 8

    (1) program -> agent modules awdecls . ardecls locdecls init events
    (12) ardecls -> . ALLREAD COLON NL INDENT rvdecls DEDENT
    (13) ardecls -> . ALLREAD COLON NL INDENT pass DEDENT

    ALLREAD         shift and go to state 13

    ardecls                        shift and go to state 14

state 9

    (10) awdecls -> ALLWRITE . COLON NL INDENT decls DEDENT
    (11) awdecls -> ALLWRITE . COLON NL INDENT pass DEDENT

    COLON           shift and go to state 15


state 10

    (3) modules -> module modules .

    ALLWRITE        reduce using rule 3 (modules -> module modules .)


state 11

    (5) module -> USING MODULE . CID COLON NL INDENT actuatordecls sensordecls DEDENT

    CID             shift and go to state 16


state 12

    (2) agent -> AGENT CID NL .

    USING           reduce using rule 2 (agent -> AGENT CID NL .)


state 13

    (12) ardecls -> ALLREAD . COLON NL INDENT rvdecls DEDENT
    (13) ardecls -> ALLREAD . COLON NL INDENT pass DEDENT

    COLON           shift and go to state 17


state 14

    (1) program -> agent modules awdecls ardecls . locdecls init events
    (14) locdecls -> . LOCAL COLON NL INDENT decls DEDENT

    LOCAL           shift and go to state 19

    locdecls                       shift and go to state 18

state 15

    (10) awdecls -> ALLWRITE COLON . NL INDENT decls DEDENT
    (11) awdecls -> ALLWRITE COLON . NL INDENT pass DEDENT

    NL              shift and go to state 20


state 16

    (5) module -> USING MODULE CID . COLON NL INDENT actuatordecls sensordecls DEDENT

    COLON           shift and go to state 21


state 17

    (12) ardecls -> ALLREAD COLON . NL INDENT rvdecls DEDENT
    (13) ardecls -> ALLREAD COLON . NL INDENT pass DEDENT

    NL              shift and go to state 22


state 18

    (1) program -> agent modules awdecls ardecls locdecls . init events
    (40) init -> . INIT COLON NL INDENT stmts DEDENT
    (41) init -> . empty
    (85) empty -> .

    INIT            shift and go to state 23
    LID             reduce using rule 85 (empty -> .)
    $end            reduce using rule 85 (empty -> .)

    init                           shift and go to state 24
    empty                          shift and go to state 25

state 19

    (14) locdecls -> LOCAL . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 26


state 20

    (10) awdecls -> ALLWRITE COLON NL . INDENT decls DEDENT
    (11) awdecls -> ALLWRITE COLON NL . INDENT pass DEDENT

    INDENT          shift and go to state 27


state 21

    (5) module -> USING MODULE CID COLON . NL INDENT actuatordecls sensordecls DEDENT

    NL              shift and go to state 28


state 22

    (12) ardecls -> ALLREAD COLON NL . INDENT rvdecls DEDENT
    (13) ardecls -> ALLREAD COLON NL . INDENT pass DEDENT

    INDENT          shift and go to state 29


state 23

    (40) init -> INIT . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 30


state 24

    (1) program -> agent modules awdecls ardecls locdecls init . events
    (42) events -> . event events
    (43) events -> . empty
    (44) event -> . LID COLON NL INDENT PRE COLON cond NL effblock DEDENT
    (85) empty -> .

    LID             shift and go to state 31
    $end            reduce using rule 85 (empty -> .)

    event                          shift and go to state 32
    events                         shift and go to state 33
    empty                          shift and go to state 34

state 25

    (41) init -> empty .

    LID             reduce using rule 41 (init -> empty .)
    $end            reduce using rule 41 (init -> empty .)


state 26

    (14) locdecls -> LOCAL COLON . NL INDENT decls DEDENT

    NL              shift and go to state 35


state 27

    (10) awdecls -> ALLWRITE COLON NL INDENT . decls DEDENT
    (11) awdecls -> ALLWRITE COLON NL INDENT . pass DEDENT
    (15) decls -> . decl decls
    (16) decls -> . type varnames NL
    (17) decls -> . empty
    (62) pass -> . PASS NL
    (18) decl -> . type varname ASGN exp NL
    (19) decl -> . mapdecl NL
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN
    (85) empty -> .
    (20) mapdecl -> . MAP LT type COMMA type GT varname

    PASS            shift and go to state 43
    INT             shift and go to state 46
    STRING          shift and go to state 42
    FLOAT           shift and go to state 47
    IPOS            shift and go to state 39
    BOOLEAN         shift and go to state 48
    DEDENT          reduce using rule 85 (empty -> .)
    MAP             shift and go to state 45

    decl                           shift and go to state 36
    mapdecl                        shift and go to state 37
    pass                           shift and go to state 38
    decls                          shift and go to state 44
    type                           shift and go to state 40
    empty                          shift and go to state 41

state 28

    (5) module -> USING MODULE CID COLON NL . INDENT actuatordecls sensordecls DEDENT

    INDENT          shift and go to state 49


state 29

    (12) ardecls -> ALLREAD COLON NL INDENT . rvdecls DEDENT
    (13) ardecls -> ALLREAD COLON NL INDENT . pass DEDENT
    (21) rvdecls -> . rvdecl rvdecls
    (22) rvdecls -> . empty
    (62) pass -> . PASS NL
    (23) rvdecl -> . type varname LBRACE owner RBRACE NL
    (24) rvdecl -> . type varname LBRACE owner RBRACE ASGN num NL
    (85) empty -> .
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN

    PASS            shift and go to state 43
    DEDENT          reduce using rule 85 (empty -> .)
    INT             shift and go to state 46
    STRING          shift and go to state 42
    FLOAT           shift and go to state 47
    IPOS            shift and go to state 39
    BOOLEAN         shift and go to state 48

    rvdecl                         shift and go to state 52
    pass                           shift and go to state 51
    rvdecls                        shift and go to state 50
    type                           shift and go to state 53
    empty                          shift and go to state 54

state 30

    (40) init -> INIT COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 55


state 31

    (44) event -> LID . COLON NL INDENT PRE COLON cond NL effblock DEDENT

    COLON           shift and go to state 56


state 32

    (42) events -> event . events
    (42) events -> . event events
    (43) events -> . empty
    (44) event -> . LID COLON NL INDENT PRE COLON cond NL effblock DEDENT
    (85) empty -> .

    LID             shift and go to state 31
    $end            reduce using rule 85 (empty -> .)

    event                          shift and go to state 32
    empty                          shift and go to state 34
    events                         shift and go to state 57

state 33

    (1) program -> agent modules awdecls ardecls locdecls init events .

    $end            reduce using rule 1 (program -> agent modules awdecls ardecls locdecls init events .)


state 34

    (43) events -> empty .

    $end            reduce using rule 43 (events -> empty .)


state 35

    (14) locdecls -> LOCAL COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 58


state 36

    (15) decls -> decl . decls
    (15) decls -> . decl decls
    (16) decls -> . type varnames NL
    (17) decls -> . empty
    (18) decl -> . type varname ASGN exp NL
    (19) decl -> . mapdecl NL
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN
    (85) empty -> .
    (20) mapdecl -> . MAP LT type COMMA type GT varname

    INT             shift and go to state 46
    STRING          shift and go to state 42
    FLOAT           shift and go to state 47
    IPOS            shift and go to state 39
    BOOLEAN         shift and go to state 48
    DEDENT          reduce using rule 85 (empty -> .)
    MAP             shift and go to state 45

    decl                           shift and go to state 36
    mapdecl                        shift and go to state 37
    decls                          shift and go to state 59
    type                           shift and go to state 40
    empty                          shift and go to state 41

state 37

    (19) decl -> mapdecl . NL

    NL              shift and go to state 60


state 38

    (11) awdecls -> ALLWRITE COLON NL INDENT pass . DEDENT

    DEDENT          shift and go to state 61


state 39

    (38) type -> IPOS .

    COMMA           reduce using rule 38 (type -> IPOS .)
    LID             reduce using rule 38 (type -> IPOS .)
    GT              reduce using rule 38 (type -> IPOS .)


state 40

    (16) decls -> type . varnames NL
    (18) decl -> type . varname ASGN exp NL
    (33) varnames -> . varname
    (34) varnames -> . varname COMMA varnames
    (78) varname -> . LID

    LID             shift and go to state 62

    varnames                       shift and go to state 64
    varname                        shift and go to state 63

state 41

    (17) decls -> empty .

    DEDENT          reduce using rule 17 (decls -> empty .)


state 42

    (36) type -> STRING .

    COMMA           reduce using rule 36 (type -> STRING .)
    LID             reduce using rule 36 (type -> STRING .)
    GT              reduce using rule 36 (type -> STRING .)


state 43

    (62) pass -> PASS . NL

    NL              shift and go to state 65


state 44

    (10) awdecls -> ALLWRITE COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 66


state 45

    (20) mapdecl -> MAP . LT type COMMA type GT varname

    LT              shift and go to state 67


state 46

    (35) type -> INT .

    COMMA           reduce using rule 35 (type -> INT .)
    LID             reduce using rule 35 (type -> INT .)
    GT              reduce using rule 35 (type -> INT .)


state 47

    (37) type -> FLOAT .

    COMMA           reduce using rule 37 (type -> FLOAT .)
    LID             reduce using rule 37 (type -> FLOAT .)
    GT              reduce using rule 37 (type -> FLOAT .)


state 48

    (39) type -> BOOLEAN .

    COMMA           reduce using rule 39 (type -> BOOLEAN .)
    LID             reduce using rule 39 (type -> BOOLEAN .)
    GT              reduce using rule 39 (type -> BOOLEAN .)


state 49

    (5) module -> USING MODULE CID COLON NL INDENT . actuatordecls sensordecls DEDENT
    (6) actuatordecls -> . ACTUATORS COLON NL INDENT decls DEDENT
    (7) actuatordecls -> . ACTUATORS COLON NL INDENT pass DEDENT

    ACTUATORS       shift and go to state 68

    actuatordecls                  shift and go to state 69

state 50

    (12) ardecls -> ALLREAD COLON NL INDENT rvdecls . DEDENT

    DEDENT          shift and go to state 70


state 51

    (13) ardecls -> ALLREAD COLON NL INDENT pass . DEDENT

    DEDENT          shift and go to state 71


state 52

    (21) rvdecls -> rvdecl . rvdecls
    (21) rvdecls -> . rvdecl rvdecls
    (22) rvdecls -> . empty
    (23) rvdecl -> . type varname LBRACE owner RBRACE NL
    (24) rvdecl -> . type varname LBRACE owner RBRACE ASGN num NL
    (85) empty -> .
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN

    DEDENT          reduce using rule 85 (empty -> .)
    INT             shift and go to state 46
    STRING          shift and go to state 42
    FLOAT           shift and go to state 47
    IPOS            shift and go to state 39
    BOOLEAN         shift and go to state 48

    rvdecl                         shift and go to state 52
    rvdecls                        shift and go to state 72
    type                           shift and go to state 53
    empty                          shift and go to state 54

state 53

    (23) rvdecl -> type . varname LBRACE owner RBRACE NL
    (24) rvdecl -> type . varname LBRACE owner RBRACE ASGN num NL
    (78) varname -> . LID

    LID             shift and go to state 62

    varname                        shift and go to state 73

state 54

    (22) rvdecls -> empty .

    DEDENT          reduce using rule 22 (rvdecls -> empty .)


state 55

    (40) init -> INIT COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 74


state 56

    (44) event -> LID COLON . NL INDENT PRE COLON cond NL effblock DEDENT

    NL              shift and go to state 75


state 57

    (42) events -> event events .

    $end            reduce using rule 42 (events -> event events .)


state 58

    (14) locdecls -> LOCAL COLON NL INDENT . decls DEDENT
    (15) decls -> . decl decls
    (16) decls -> . type varnames NL
    (17) decls -> . empty
    (18) decl -> . type varname ASGN exp NL
    (19) decl -> . mapdecl NL
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN
    (85) empty -> .
    (20) mapdecl -> . MAP LT type COMMA type GT varname

    INT             shift and go to state 46
    STRING          shift and go to state 42
    FLOAT           shift and go to state 47
    IPOS            shift and go to state 39
    BOOLEAN         shift and go to state 48
    DEDENT          reduce using rule 85 (empty -> .)
    MAP             shift and go to state 45

    decl                           shift and go to state 36
    mapdecl                        shift and go to state 37
    decls                          shift and go to state 76
    type                           shift and go to state 40
    empty                          shift and go to state 41

state 59

    (15) decls -> decl decls .

    DEDENT          reduce using rule 15 (decls -> decl decls .)


state 60

    (19) decl -> mapdecl NL .

    INT             reduce using rule 19 (decl -> mapdecl NL .)
    STRING          reduce using rule 19 (decl -> mapdecl NL .)
    FLOAT           reduce using rule 19 (decl -> mapdecl NL .)
    IPOS            reduce using rule 19 (decl -> mapdecl NL .)
    BOOLEAN         reduce using rule 19 (decl -> mapdecl NL .)
    MAP             reduce using rule 19 (decl -> mapdecl NL .)
    DEDENT          reduce using rule 19 (decl -> mapdecl NL .)


state 61

    (11) awdecls -> ALLWRITE COLON NL INDENT pass DEDENT .

    ALLREAD         reduce using rule 11 (awdecls -> ALLWRITE COLON NL INDENT pass DEDENT .)


state 62

    (78) varname -> LID .

    LPAR            reduce using rule 78 (varname -> LID .)
    COMMA           reduce using rule 78 (varname -> LID .)
    PLUS            reduce using rule 78 (varname -> LID .)
    TIMES           reduce using rule 78 (varname -> LID .)
    MINUS           reduce using rule 78 (varname -> LID .)
    BY              reduce using rule 78 (varname -> LID .)
    RPAR            reduce using rule 78 (varname -> LID .)
    ASGN            reduce using rule 78 (varname -> LID .)
    NL              reduce using rule 78 (varname -> LID .)
    COLON           reduce using rule 78 (varname -> LID .)
    AND             reduce using rule 78 (varname -> LID .)
    OR              reduce using rule 78 (varname -> LID .)
    EQ              reduce using rule 78 (varname -> LID .)
    NEQ             reduce using rule 78 (varname -> LID .)
    GEQ             reduce using rule 78 (varname -> LID .)
    LEQ             reduce using rule 78 (varname -> LID .)
    GT              reduce using rule 78 (varname -> LID .)
    LT              reduce using rule 78 (varname -> LID .)
    LBRACE          reduce using rule 78 (varname -> LID .)


state 63

    (18) decl -> type varname . ASGN exp NL
    (33) varnames -> varname .
    (34) varnames -> varname . COMMA varnames

    ASGN            shift and go to state 77
    NL              reduce using rule 33 (varnames -> varname .)
    COMMA           shift and go to state 78


state 64

    (16) decls -> type varnames . NL

    NL              shift and go to state 79


state 65

    (62) pass -> PASS NL .

    ATOMIC          reduce using rule 62 (pass -> PASS NL .)
    IF              reduce using rule 62 (pass -> PASS NL .)
    PASS            reduce using rule 62 (pass -> PASS NL .)
    CID             reduce using rule 62 (pass -> PASS NL .)
    LID             reduce using rule 62 (pass -> PASS NL .)
    DEDENT          reduce using rule 62 (pass -> PASS NL .)


state 66

    (10) awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .

    ALLREAD         reduce using rule 10 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)


state 67

    (20) mapdecl -> MAP LT . type COMMA type GT varname
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN

    INT             shift and go to state 46
    STRING          shift and go to state 42
    FLOAT           shift and go to state 47
    IPOS            shift and go to state 39
    BOOLEAN         shift and go to state 48

    type                           shift and go to state 80

state 68

    (6) actuatordecls -> ACTUATORS . COLON NL INDENT decls DEDENT
    (7) actuatordecls -> ACTUATORS . COLON NL INDENT pass DEDENT

    COLON           shift and go to state 81


state 69

    (5) module -> USING MODULE CID COLON NL INDENT actuatordecls . sensordecls DEDENT
    (8) sensordecls -> . SENSORS COLON NL INDENT decls DEDENT
    (9) sensordecls -> . SENSORS COLON NL INDENT pass DEDENT

    SENSORS         shift and go to state 83

    sensordecls                    shift and go to state 82

state 70

    (12) ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .

    LOCAL           reduce using rule 12 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)


state 71

    (13) ardecls -> ALLREAD COLON NL INDENT pass DEDENT .

    LOCAL           reduce using rule 13 (ardecls -> ALLREAD COLON NL INDENT pass DEDENT .)


state 72

    (21) rvdecls -> rvdecl rvdecls .

    DEDENT          reduce using rule 21 (rvdecls -> rvdecl rvdecls .)


state 73

    (23) rvdecl -> type varname . LBRACE owner RBRACE NL
    (24) rvdecl -> type varname . LBRACE owner RBRACE ASGN num NL

    LBRACE          shift and go to state 84


state 74

    (40) init -> INIT COLON NL INDENT . stmts DEDENT
    (52) stmts -> . stmt stmts
    (53) stmts -> . empty
    (54) stmt -> . asgn
    (55) stmt -> . pass
    (56) stmt -> . funccall NL
    (57) stmt -> . modulefunccall NL
    (58) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (59) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (85) empty -> .
    (63) asgn -> . varname ASGN exp NL
    (62) pass -> . PASS NL
    (27) funccall -> . varname LPAR args RPAR
    (60) modulefunccall -> . CID LPAR args RPAR
    (78) varname -> . LID

    ATOMIC          shift and go to state 86
    IF              shift and go to state 94
    DEDENT          reduce using rule 85 (empty -> .)
    PASS            shift and go to state 43
    CID             shift and go to state 85
    LID             shift and go to state 62

    funccall                       shift and go to state 91
    stmts                          shift and go to state 88
    varname                        shift and go to state 95
    stmt                           shift and go to state 93
    asgn                           shift and go to state 89
    modulefunccall                 shift and go to state 92
    pass                           shift and go to state 87
    empty                          shift and go to state 90

state 75

    (44) event -> LID COLON NL . INDENT PRE COLON cond NL effblock DEDENT

    INDENT          shift and go to state 96


state 76

    (14) locdecls -> LOCAL COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 97


state 77

    (18) decl -> type varname ASGN . exp NL
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 99
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    exp                            shift and go to state 105
    bval                           shift and go to state 98

state 78

    (34) varnames -> varname COMMA . varnames
    (33) varnames -> . varname
    (34) varnames -> . varname COMMA varnames
    (78) varname -> . LID

    LID             shift and go to state 62

    varname                        shift and go to state 109
    varnames                       shift and go to state 110

state 79

    (16) decls -> type varnames NL .

    DEDENT          reduce using rule 16 (decls -> type varnames NL .)


state 80

    (20) mapdecl -> MAP LT type . COMMA type GT varname

    COMMA           shift and go to state 111


state 81

    (6) actuatordecls -> ACTUATORS COLON . NL INDENT decls DEDENT
    (7) actuatordecls -> ACTUATORS COLON . NL INDENT pass DEDENT

    NL              shift and go to state 112


state 82

    (5) module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls . DEDENT

    DEDENT          shift and go to state 113


state 83

    (8) sensordecls -> SENSORS . COLON NL INDENT decls DEDENT
    (9) sensordecls -> SENSORS . COLON NL INDENT pass DEDENT

    COLON           shift and go to state 114


state 84

    (23) rvdecl -> type varname LBRACE . owner RBRACE NL
    (24) rvdecl -> type varname LBRACE . owner RBRACE ASGN num NL
    (25) owner -> . TIMES
    (26) owner -> . INUM

    TIMES           shift and go to state 117
    INUM            shift and go to state 115

    owner                          shift and go to state 116

state 85

    (60) modulefunccall -> CID . LPAR args RPAR

    LPAR            shift and go to state 118


state 86

    (58) stmt -> ATOMIC . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 119


state 87

    (55) stmt -> pass .

    ATOMIC          reduce using rule 55 (stmt -> pass .)
    IF              reduce using rule 55 (stmt -> pass .)
    PASS            reduce using rule 55 (stmt -> pass .)
    CID             reduce using rule 55 (stmt -> pass .)
    LID             reduce using rule 55 (stmt -> pass .)
    DEDENT          reduce using rule 55 (stmt -> pass .)


state 88

    (40) init -> INIT COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 120


state 89

    (54) stmt -> asgn .

    ATOMIC          reduce using rule 54 (stmt -> asgn .)
    IF              reduce using rule 54 (stmt -> asgn .)
    PASS            reduce using rule 54 (stmt -> asgn .)
    CID             reduce using rule 54 (stmt -> asgn .)
    LID             reduce using rule 54 (stmt -> asgn .)
    DEDENT          reduce using rule 54 (stmt -> asgn .)


state 90

    (53) stmts -> empty .

    DEDENT          reduce using rule 53 (stmts -> empty .)


state 91

    (56) stmt -> funccall . NL

    NL              shift and go to state 121


state 92

    (57) stmt -> modulefunccall . NL

    NL              shift and go to state 122


state 93

    (52) stmts -> stmt . stmts
    (52) stmts -> . stmt stmts
    (53) stmts -> . empty
    (54) stmt -> . asgn
    (55) stmt -> . pass
    (56) stmt -> . funccall NL
    (57) stmt -> . modulefunccall NL
    (58) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (59) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (85) empty -> .
    (63) asgn -> . varname ASGN exp NL
    (62) pass -> . PASS NL
    (27) funccall -> . varname LPAR args RPAR
    (60) modulefunccall -> . CID LPAR args RPAR
    (78) varname -> . LID

    ATOMIC          shift and go to state 86
    IF              shift and go to state 94
    DEDENT          reduce using rule 85 (empty -> .)
    PASS            shift and go to state 43
    CID             shift and go to state 85
    LID             shift and go to state 62

    funccall                       shift and go to state 91
    stmts                          shift and go to state 123
    varname                        shift and go to state 95
    stmt                           shift and go to state 93
    asgn                           shift and go to state 89
    modulefunccall                 shift and go to state 92
    pass                           shift and go to state 87
    empty                          shift and go to state 90

state 94

    (59) stmt -> IF . cond COLON NL INDENT stmts DEDENT elseblock
    (47) cond -> . LPAR cond AND cond RPAR
    (48) cond -> . LPAR cond OR cond RPAR
    (49) cond -> . LPAR cond op cond RPAR
    (50) cond -> . LPAR NOT cond RPAR
    (51) cond -> . exp
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 124
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    cond                           shift and go to state 125
    exp                            shift and go to state 126
    bval                           shift and go to state 98

state 95

    (63) asgn -> varname . ASGN exp NL
    (27) funccall -> varname . LPAR args RPAR

    ASGN            shift and go to state 128
    LPAR            shift and go to state 127


state 96

    (44) event -> LID COLON NL INDENT . PRE COLON cond NL effblock DEDENT

    PRE             shift and go to state 129


state 97

    (14) locdecls -> LOCAL COLON NL INDENT decls DEDENT .

    INIT            reduce using rule 14 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)
    LID             reduce using rule 14 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)
    $end            reduce using rule 14 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)


state 98

    (70) exp -> bval .

    NL              reduce using rule 70 (exp -> bval .)
    PLUS            reduce using rule 70 (exp -> bval .)
    TIMES           reduce using rule 70 (exp -> bval .)
    MINUS           reduce using rule 70 (exp -> bval .)
    BY              reduce using rule 70 (exp -> bval .)
    COLON           reduce using rule 70 (exp -> bval .)
    RPAR            reduce using rule 70 (exp -> bval .)
    COMMA           reduce using rule 70 (exp -> bval .)
    AND             reduce using rule 70 (exp -> bval .)
    OR              reduce using rule 70 (exp -> bval .)
    EQ              reduce using rule 70 (exp -> bval .)
    NEQ             reduce using rule 70 (exp -> bval .)
    GEQ             reduce using rule 70 (exp -> bval .)
    LEQ             reduce using rule 70 (exp -> bval .)
    GT              reduce using rule 70 (exp -> bval .)
    LT              reduce using rule 70 (exp -> bval .)


state 99

    (73) bracketexp -> LPAR . exp RPAR
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 99
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    exp                            shift and go to state 130
    bval                           shift and go to state 98

state 100

    (64) exp -> bracketexp .

    NL              reduce using rule 64 (exp -> bracketexp .)
    PLUS            reduce using rule 64 (exp -> bracketexp .)
    TIMES           reduce using rule 64 (exp -> bracketexp .)
    MINUS           reduce using rule 64 (exp -> bracketexp .)
    BY              reduce using rule 64 (exp -> bracketexp .)
    COLON           reduce using rule 64 (exp -> bracketexp .)
    RPAR            reduce using rule 64 (exp -> bracketexp .)
    COMMA           reduce using rule 64 (exp -> bracketexp .)
    AND             reduce using rule 64 (exp -> bracketexp .)
    OR              reduce using rule 64 (exp -> bracketexp .)
    EQ              reduce using rule 64 (exp -> bracketexp .)
    NEQ             reduce using rule 64 (exp -> bracketexp .)
    GEQ             reduce using rule 64 (exp -> bracketexp .)
    LEQ             reduce using rule 64 (exp -> bracketexp .)
    GT              reduce using rule 64 (exp -> bracketexp .)
    LT              reduce using rule 64 (exp -> bracketexp .)


state 101

    (72) exp -> funccall .

    NL              reduce using rule 72 (exp -> funccall .)
    PLUS            reduce using rule 72 (exp -> funccall .)
    TIMES           reduce using rule 72 (exp -> funccall .)
    MINUS           reduce using rule 72 (exp -> funccall .)
    BY              reduce using rule 72 (exp -> funccall .)
    COLON           reduce using rule 72 (exp -> funccall .)
    RPAR            reduce using rule 72 (exp -> funccall .)
    COMMA           reduce using rule 72 (exp -> funccall .)
    AND             reduce using rule 72 (exp -> funccall .)
    OR              reduce using rule 72 (exp -> funccall .)
    EQ              reduce using rule 72 (exp -> funccall .)
    NEQ             reduce using rule 72 (exp -> funccall .)
    GEQ             reduce using rule 72 (exp -> funccall .)
    LEQ             reduce using rule 72 (exp -> funccall .)
    GT              reduce using rule 72 (exp -> funccall .)
    LT              reduce using rule 72 (exp -> funccall .)


state 102

    (69) exp -> varname .
    (27) funccall -> varname . LPAR args RPAR

    NL              reduce using rule 69 (exp -> varname .)
    PLUS            reduce using rule 69 (exp -> varname .)
    TIMES           reduce using rule 69 (exp -> varname .)
    MINUS           reduce using rule 69 (exp -> varname .)
    BY              reduce using rule 69 (exp -> varname .)
    COLON           reduce using rule 69 (exp -> varname .)
    RPAR            reduce using rule 69 (exp -> varname .)
    COMMA           reduce using rule 69 (exp -> varname .)
    AND             reduce using rule 69 (exp -> varname .)
    OR              reduce using rule 69 (exp -> varname .)
    EQ              reduce using rule 69 (exp -> varname .)
    NEQ             reduce using rule 69 (exp -> varname .)
    GEQ             reduce using rule 69 (exp -> varname .)
    LEQ             reduce using rule 69 (exp -> varname .)
    GT              reduce using rule 69 (exp -> varname .)
    LT              reduce using rule 69 (exp -> varname .)
    LPAR            shift and go to state 127


state 103

    (77) num -> FNUM .

    PLUS            reduce using rule 77 (num -> FNUM .)
    TIMES           reduce using rule 77 (num -> FNUM .)
    MINUS           reduce using rule 77 (num -> FNUM .)
    BY              reduce using rule 77 (num -> FNUM .)
    RPAR            reduce using rule 77 (num -> FNUM .)
    NL              reduce using rule 77 (num -> FNUM .)
    COMMA           reduce using rule 77 (num -> FNUM .)
    COLON           reduce using rule 77 (num -> FNUM .)
    AND             reduce using rule 77 (num -> FNUM .)
    OR              reduce using rule 77 (num -> FNUM .)
    EQ              reduce using rule 77 (num -> FNUM .)
    NEQ             reduce using rule 77 (num -> FNUM .)
    GEQ             reduce using rule 77 (num -> FNUM .)
    LEQ             reduce using rule 77 (num -> FNUM .)
    GT              reduce using rule 77 (num -> FNUM .)
    LT              reduce using rule 77 (num -> FNUM .)


state 104

    (71) exp -> num .

    NL              reduce using rule 71 (exp -> num .)
    PLUS            reduce using rule 71 (exp -> num .)
    TIMES           reduce using rule 71 (exp -> num .)
    MINUS           reduce using rule 71 (exp -> num .)
    BY              reduce using rule 71 (exp -> num .)
    COLON           reduce using rule 71 (exp -> num .)
    RPAR            reduce using rule 71 (exp -> num .)
    COMMA           reduce using rule 71 (exp -> num .)
    AND             reduce using rule 71 (exp -> num .)
    OR              reduce using rule 71 (exp -> num .)
    EQ              reduce using rule 71 (exp -> num .)
    NEQ             reduce using rule 71 (exp -> num .)
    GEQ             reduce using rule 71 (exp -> num .)
    LEQ             reduce using rule 71 (exp -> num .)
    GT              reduce using rule 71 (exp -> num .)
    LT              reduce using rule 71 (exp -> num .)


state 105

    (18) decl -> type varname ASGN exp . NL
    (65) exp -> exp . PLUS exp
    (66) exp -> exp . TIMES exp
    (67) exp -> exp . MINUS exp
    (68) exp -> exp . BY exp

    NL              shift and go to state 131
    PLUS            shift and go to state 133
    TIMES           shift and go to state 134
    MINUS           shift and go to state 135
    BY              shift and go to state 132


state 106

    (76) num -> INUM .

    PLUS            reduce using rule 76 (num -> INUM .)
    TIMES           reduce using rule 76 (num -> INUM .)
    MINUS           reduce using rule 76 (num -> INUM .)
    BY              reduce using rule 76 (num -> INUM .)
    RPAR            reduce using rule 76 (num -> INUM .)
    NL              reduce using rule 76 (num -> INUM .)
    COMMA           reduce using rule 76 (num -> INUM .)
    COLON           reduce using rule 76 (num -> INUM .)
    AND             reduce using rule 76 (num -> INUM .)
    OR              reduce using rule 76 (num -> INUM .)
    EQ              reduce using rule 76 (num -> INUM .)
    NEQ             reduce using rule 76 (num -> INUM .)
    GEQ             reduce using rule 76 (num -> INUM .)
    LEQ             reduce using rule 76 (num -> INUM .)
    GT              reduce using rule 76 (num -> INUM .)
    LT              reduce using rule 76 (num -> INUM .)


state 107

    (75) bval -> FALSE .

    NL              reduce using rule 75 (bval -> FALSE .)
    PLUS            reduce using rule 75 (bval -> FALSE .)
    TIMES           reduce using rule 75 (bval -> FALSE .)
    MINUS           reduce using rule 75 (bval -> FALSE .)
    BY              reduce using rule 75 (bval -> FALSE .)
    RPAR            reduce using rule 75 (bval -> FALSE .)
    AND             reduce using rule 75 (bval -> FALSE .)
    OR              reduce using rule 75 (bval -> FALSE .)
    EQ              reduce using rule 75 (bval -> FALSE .)
    NEQ             reduce using rule 75 (bval -> FALSE .)
    GEQ             reduce using rule 75 (bval -> FALSE .)
    LEQ             reduce using rule 75 (bval -> FALSE .)
    GT              reduce using rule 75 (bval -> FALSE .)
    LT              reduce using rule 75 (bval -> FALSE .)
    COMMA           reduce using rule 75 (bval -> FALSE .)
    COLON           reduce using rule 75 (bval -> FALSE .)


state 108

    (74) bval -> TRUE .

    NL              reduce using rule 74 (bval -> TRUE .)
    PLUS            reduce using rule 74 (bval -> TRUE .)
    TIMES           reduce using rule 74 (bval -> TRUE .)
    MINUS           reduce using rule 74 (bval -> TRUE .)
    BY              reduce using rule 74 (bval -> TRUE .)
    RPAR            reduce using rule 74 (bval -> TRUE .)
    AND             reduce using rule 74 (bval -> TRUE .)
    OR              reduce using rule 74 (bval -> TRUE .)
    EQ              reduce using rule 74 (bval -> TRUE .)
    NEQ             reduce using rule 74 (bval -> TRUE .)
    GEQ             reduce using rule 74 (bval -> TRUE .)
    LEQ             reduce using rule 74 (bval -> TRUE .)
    GT              reduce using rule 74 (bval -> TRUE .)
    LT              reduce using rule 74 (bval -> TRUE .)
    COMMA           reduce using rule 74 (bval -> TRUE .)
    COLON           reduce using rule 74 (bval -> TRUE .)


state 109

    (33) varnames -> varname .
    (34) varnames -> varname . COMMA varnames

    NL              reduce using rule 33 (varnames -> varname .)
    COMMA           shift and go to state 78


state 110

    (34) varnames -> varname COMMA varnames .

    NL              reduce using rule 34 (varnames -> varname COMMA varnames .)


state 111

    (20) mapdecl -> MAP LT type COMMA . type GT varname
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN

    INT             shift and go to state 46
    STRING          shift and go to state 42
    FLOAT           shift and go to state 47
    IPOS            shift and go to state 39
    BOOLEAN         shift and go to state 48

    type                           shift and go to state 136

state 112

    (6) actuatordecls -> ACTUATORS COLON NL . INDENT decls DEDENT
    (7) actuatordecls -> ACTUATORS COLON NL . INDENT pass DEDENT

    INDENT          shift and go to state 137


state 113

    (5) module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .

    USING           reduce using rule 5 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    ALLWRITE        reduce using rule 5 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)


state 114

    (8) sensordecls -> SENSORS COLON . NL INDENT decls DEDENT
    (9) sensordecls -> SENSORS COLON . NL INDENT pass DEDENT

    NL              shift and go to state 138


state 115

    (26) owner -> INUM .

    RBRACE          reduce using rule 26 (owner -> INUM .)


state 116

    (23) rvdecl -> type varname LBRACE owner . RBRACE NL
    (24) rvdecl -> type varname LBRACE owner . RBRACE ASGN num NL

    RBRACE          shift and go to state 139


state 117

    (25) owner -> TIMES .

    RBRACE          reduce using rule 25 (owner -> TIMES .)


state 118

    (60) modulefunccall -> CID LPAR . args RPAR
    (28) args -> . neargs
    (29) args -> . noargs
    (31) neargs -> . exp
    (32) neargs -> . exp COMMA neargs
    (30) noargs -> . empty
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (85) empty -> .
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    RPAR            reduce using rule 85 (empty -> .)
    LPAR            shift and go to state 99
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    args                           shift and go to state 143
    num                            shift and go to state 104
    exp                            shift and go to state 144
    noargs                         shift and go to state 140
    neargs                         shift and go to state 141
    bval                           shift and go to state 98
    empty                          shift and go to state 142

state 119

    (58) stmt -> ATOMIC COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 145


state 120

    (40) init -> INIT COLON NL INDENT stmts DEDENT .

    LID             reduce using rule 40 (init -> INIT COLON NL INDENT stmts DEDENT .)
    $end            reduce using rule 40 (init -> INIT COLON NL INDENT stmts DEDENT .)


state 121

    (56) stmt -> funccall NL .

    ATOMIC          reduce using rule 56 (stmt -> funccall NL .)
    IF              reduce using rule 56 (stmt -> funccall NL .)
    PASS            reduce using rule 56 (stmt -> funccall NL .)
    CID             reduce using rule 56 (stmt -> funccall NL .)
    LID             reduce using rule 56 (stmt -> funccall NL .)
    DEDENT          reduce using rule 56 (stmt -> funccall NL .)


state 122

    (57) stmt -> modulefunccall NL .

    ATOMIC          reduce using rule 57 (stmt -> modulefunccall NL .)
    IF              reduce using rule 57 (stmt -> modulefunccall NL .)
    PASS            reduce using rule 57 (stmt -> modulefunccall NL .)
    CID             reduce using rule 57 (stmt -> modulefunccall NL .)
    LID             reduce using rule 57 (stmt -> modulefunccall NL .)
    DEDENT          reduce using rule 57 (stmt -> modulefunccall NL .)


state 123

    (52) stmts -> stmt stmts .

    DEDENT          reduce using rule 52 (stmts -> stmt stmts .)


state 124

    (47) cond -> LPAR . cond AND cond RPAR
    (48) cond -> LPAR . cond OR cond RPAR
    (49) cond -> LPAR . cond op cond RPAR
    (50) cond -> LPAR . NOT cond RPAR
    (73) bracketexp -> LPAR . exp RPAR
    (47) cond -> . LPAR cond AND cond RPAR
    (48) cond -> . LPAR cond OR cond RPAR
    (49) cond -> . LPAR cond op cond RPAR
    (50) cond -> . LPAR NOT cond RPAR
    (51) cond -> . exp
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    NOT             shift and go to state 148
    LPAR            shift and go to state 124
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    cond                           shift and go to state 146
    exp                            shift and go to state 147
    bval                           shift and go to state 98

state 125

    (59) stmt -> IF cond . COLON NL INDENT stmts DEDENT elseblock

    COLON           shift and go to state 149


state 126

    (51) cond -> exp .
    (65) exp -> exp . PLUS exp
    (66) exp -> exp . TIMES exp
    (67) exp -> exp . MINUS exp
    (68) exp -> exp . BY exp

    RPAR            reduce using rule 51 (cond -> exp .)
    NL              reduce using rule 51 (cond -> exp .)
    COLON           reduce using rule 51 (cond -> exp .)
    PLUS            shift and go to state 133
    TIMES           shift and go to state 134
    MINUS           shift and go to state 135
    BY              shift and go to state 132


state 127

    (27) funccall -> varname LPAR . args RPAR
    (28) args -> . neargs
    (29) args -> . noargs
    (31) neargs -> . exp
    (32) neargs -> . exp COMMA neargs
    (30) noargs -> . empty
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (85) empty -> .
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    RPAR            reduce using rule 85 (empty -> .)
    LPAR            shift and go to state 99
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    args                           shift and go to state 150
    num                            shift and go to state 104
    exp                            shift and go to state 144
    noargs                         shift and go to state 140
    neargs                         shift and go to state 141
    bval                           shift and go to state 98
    empty                          shift and go to state 142

state 128

    (63) asgn -> varname ASGN . exp NL
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 99
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    exp                            shift and go to state 151
    bval                           shift and go to state 98

state 129

    (44) event -> LID COLON NL INDENT PRE . COLON cond NL effblock DEDENT

    COLON           shift and go to state 152


state 130

    (73) bracketexp -> LPAR exp . RPAR
    (65) exp -> exp . PLUS exp
    (66) exp -> exp . TIMES exp
    (67) exp -> exp . MINUS exp
    (68) exp -> exp . BY exp

    RPAR            shift and go to state 153
    PLUS            shift and go to state 133
    TIMES           shift and go to state 134
    MINUS           shift and go to state 135
    BY              shift and go to state 132


state 131

    (18) decl -> type varname ASGN exp NL .

    INT             reduce using rule 18 (decl -> type varname ASGN exp NL .)
    STRING          reduce using rule 18 (decl -> type varname ASGN exp NL .)
    FLOAT           reduce using rule 18 (decl -> type varname ASGN exp NL .)
    IPOS            reduce using rule 18 (decl -> type varname ASGN exp NL .)
    BOOLEAN         reduce using rule 18 (decl -> type varname ASGN exp NL .)
    MAP             reduce using rule 18 (decl -> type varname ASGN exp NL .)
    DEDENT          reduce using rule 18 (decl -> type varname ASGN exp NL .)


state 132

    (68) exp -> exp BY . exp
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 99
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    exp                            shift and go to state 154
    bval                           shift and go to state 98

state 133

    (65) exp -> exp PLUS . exp
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 99
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    exp                            shift and go to state 155
    bval                           shift and go to state 98

state 134

    (66) exp -> exp TIMES . exp
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 99
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    exp                            shift and go to state 156
    bval                           shift and go to state 98

state 135

    (67) exp -> exp MINUS . exp
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 99
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    exp                            shift and go to state 157
    bval                           shift and go to state 98

state 136

    (20) mapdecl -> MAP LT type COMMA type . GT varname

    GT              shift and go to state 158


state 137

    (6) actuatordecls -> ACTUATORS COLON NL INDENT . decls DEDENT
    (7) actuatordecls -> ACTUATORS COLON NL INDENT . pass DEDENT
    (15) decls -> . decl decls
    (16) decls -> . type varnames NL
    (17) decls -> . empty
    (62) pass -> . PASS NL
    (18) decl -> . type varname ASGN exp NL
    (19) decl -> . mapdecl NL
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN
    (85) empty -> .
    (20) mapdecl -> . MAP LT type COMMA type GT varname

    PASS            shift and go to state 43
    INT             shift and go to state 46
    STRING          shift and go to state 42
    FLOAT           shift and go to state 47
    IPOS            shift and go to state 39
    BOOLEAN         shift and go to state 48
    DEDENT          reduce using rule 85 (empty -> .)
    MAP             shift and go to state 45

    decl                           shift and go to state 36
    mapdecl                        shift and go to state 37
    pass                           shift and go to state 159
    decls                          shift and go to state 160
    type                           shift and go to state 40
    empty                          shift and go to state 41

state 138

    (8) sensordecls -> SENSORS COLON NL . INDENT decls DEDENT
    (9) sensordecls -> SENSORS COLON NL . INDENT pass DEDENT

    INDENT          shift and go to state 161


state 139

    (23) rvdecl -> type varname LBRACE owner RBRACE . NL
    (24) rvdecl -> type varname LBRACE owner RBRACE . ASGN num NL

    NL              shift and go to state 162
    ASGN            shift and go to state 163


state 140

    (29) args -> noargs .

    RPAR            reduce using rule 29 (args -> noargs .)


state 141

    (28) args -> neargs .

    RPAR            reduce using rule 28 (args -> neargs .)


state 142

    (30) noargs -> empty .

    RPAR            reduce using rule 30 (noargs -> empty .)


state 143

    (60) modulefunccall -> CID LPAR args . RPAR

    RPAR            shift and go to state 164


state 144

    (31) neargs -> exp .
    (32) neargs -> exp . COMMA neargs
    (65) exp -> exp . PLUS exp
    (66) exp -> exp . TIMES exp
    (67) exp -> exp . MINUS exp
    (68) exp -> exp . BY exp

    RPAR            reduce using rule 31 (neargs -> exp .)
    COMMA           shift and go to state 165
    PLUS            shift and go to state 133
    TIMES           shift and go to state 134
    MINUS           shift and go to state 135
    BY              shift and go to state 132


state 145

    (58) stmt -> ATOMIC COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 166


state 146

    (47) cond -> LPAR cond . AND cond RPAR
    (48) cond -> LPAR cond . OR cond RPAR
    (49) cond -> LPAR cond . op cond RPAR
    (79) op -> . EQ
    (80) op -> . NEQ
    (81) op -> . GEQ
    (82) op -> . LEQ
    (83) op -> . GT
    (84) op -> . LT

    AND             shift and go to state 167
    OR              shift and go to state 174
    EQ              shift and go to state 173
    NEQ             shift and go to state 172
    GEQ             shift and go to state 168
    LEQ             shift and go to state 170
    GT              shift and go to state 169
    LT              shift and go to state 171

    op                             shift and go to state 175

state 147

    (73) bracketexp -> LPAR exp . RPAR
    (51) cond -> exp .
    (65) exp -> exp . PLUS exp
    (66) exp -> exp . TIMES exp
    (67) exp -> exp . MINUS exp
    (68) exp -> exp . BY exp

    RPAR            shift and go to state 153
    AND             reduce using rule 51 (cond -> exp .)
    OR              reduce using rule 51 (cond -> exp .)
    EQ              reduce using rule 51 (cond -> exp .)
    NEQ             reduce using rule 51 (cond -> exp .)
    GEQ             reduce using rule 51 (cond -> exp .)
    LEQ             reduce using rule 51 (cond -> exp .)
    GT              reduce using rule 51 (cond -> exp .)
    LT              reduce using rule 51 (cond -> exp .)
    PLUS            shift and go to state 133
    TIMES           shift and go to state 134
    MINUS           shift and go to state 135
    BY              shift and go to state 132


state 148

    (50) cond -> LPAR NOT . cond RPAR
    (47) cond -> . LPAR cond AND cond RPAR
    (48) cond -> . LPAR cond OR cond RPAR
    (49) cond -> . LPAR cond op cond RPAR
    (50) cond -> . LPAR NOT cond RPAR
    (51) cond -> . exp
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 124
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    cond                           shift and go to state 176
    exp                            shift and go to state 126
    bval                           shift and go to state 98

state 149

    (59) stmt -> IF cond COLON . NL INDENT stmts DEDENT elseblock

    NL              shift and go to state 177


state 150

    (27) funccall -> varname LPAR args . RPAR

    RPAR            shift and go to state 178


state 151

    (63) asgn -> varname ASGN exp . NL
    (65) exp -> exp . PLUS exp
    (66) exp -> exp . TIMES exp
    (67) exp -> exp . MINUS exp
    (68) exp -> exp . BY exp

    NL              shift and go to state 179
    PLUS            shift and go to state 133
    TIMES           shift and go to state 134
    MINUS           shift and go to state 135
    BY              shift and go to state 132


state 152

    (44) event -> LID COLON NL INDENT PRE COLON . cond NL effblock DEDENT
    (47) cond -> . LPAR cond AND cond RPAR
    (48) cond -> . LPAR cond OR cond RPAR
    (49) cond -> . LPAR cond op cond RPAR
    (50) cond -> . LPAR NOT cond RPAR
    (51) cond -> . exp
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 124
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    cond                           shift and go to state 180
    exp                            shift and go to state 126
    bval                           shift and go to state 98

state 153

    (73) bracketexp -> LPAR exp RPAR .

    PLUS            reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    TIMES           reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    MINUS           reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    BY              reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    RPAR            reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    NL              reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    COMMA           reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    COLON           reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    AND             reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    OR              reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    EQ              reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    NEQ             reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    GEQ             reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    LEQ             reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    GT              reduce using rule 73 (bracketexp -> LPAR exp RPAR .)
    LT              reduce using rule 73 (bracketexp -> LPAR exp RPAR .)


state 154

    (68) exp -> exp BY exp .
    (65) exp -> exp . PLUS exp
    (66) exp -> exp . TIMES exp
    (67) exp -> exp . MINUS exp
    (68) exp -> exp . BY exp

    NL              reduce using rule 68 (exp -> exp BY exp .)
    PLUS            reduce using rule 68 (exp -> exp BY exp .)
    TIMES           reduce using rule 68 (exp -> exp BY exp .)
    MINUS           reduce using rule 68 (exp -> exp BY exp .)
    BY              reduce using rule 68 (exp -> exp BY exp .)
    COLON           reduce using rule 68 (exp -> exp BY exp .)
    RPAR            reduce using rule 68 (exp -> exp BY exp .)
    COMMA           reduce using rule 68 (exp -> exp BY exp .)
    AND             reduce using rule 68 (exp -> exp BY exp .)
    OR              reduce using rule 68 (exp -> exp BY exp .)
    EQ              reduce using rule 68 (exp -> exp BY exp .)
    NEQ             reduce using rule 68 (exp -> exp BY exp .)
    GEQ             reduce using rule 68 (exp -> exp BY exp .)
    LEQ             reduce using rule 68 (exp -> exp BY exp .)
    GT              reduce using rule 68 (exp -> exp BY exp .)
    LT              reduce using rule 68 (exp -> exp BY exp .)

  ! PLUS            [ shift and go to state 133 ]
  ! TIMES           [ shift and go to state 134 ]
  ! MINUS           [ shift and go to state 135 ]
  ! BY              [ shift and go to state 132 ]


state 155

    (65) exp -> exp PLUS exp .
    (65) exp -> exp . PLUS exp
    (66) exp -> exp . TIMES exp
    (67) exp -> exp . MINUS exp
    (68) exp -> exp . BY exp

    NL              reduce using rule 65 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 65 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 65 (exp -> exp PLUS exp .)
    COLON           reduce using rule 65 (exp -> exp PLUS exp .)
    RPAR            reduce using rule 65 (exp -> exp PLUS exp .)
    COMMA           reduce using rule 65 (exp -> exp PLUS exp .)
    AND             reduce using rule 65 (exp -> exp PLUS exp .)
    OR              reduce using rule 65 (exp -> exp PLUS exp .)
    EQ              reduce using rule 65 (exp -> exp PLUS exp .)
    NEQ             reduce using rule 65 (exp -> exp PLUS exp .)
    GEQ             reduce using rule 65 (exp -> exp PLUS exp .)
    LEQ             reduce using rule 65 (exp -> exp PLUS exp .)
    GT              reduce using rule 65 (exp -> exp PLUS exp .)
    LT              reduce using rule 65 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 134
    BY              shift and go to state 132

  ! TIMES           [ reduce using rule 65 (exp -> exp PLUS exp .) ]
  ! BY              [ reduce using rule 65 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 133 ]
  ! MINUS           [ shift and go to state 135 ]


state 156

    (66) exp -> exp TIMES exp .
    (65) exp -> exp . PLUS exp
    (66) exp -> exp . TIMES exp
    (67) exp -> exp . MINUS exp
    (68) exp -> exp . BY exp

    NL              reduce using rule 66 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 66 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 66 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 66 (exp -> exp TIMES exp .)
    BY              reduce using rule 66 (exp -> exp TIMES exp .)
    COLON           reduce using rule 66 (exp -> exp TIMES exp .)
    RPAR            reduce using rule 66 (exp -> exp TIMES exp .)
    COMMA           reduce using rule 66 (exp -> exp TIMES exp .)
    AND             reduce using rule 66 (exp -> exp TIMES exp .)
    OR              reduce using rule 66 (exp -> exp TIMES exp .)
    EQ              reduce using rule 66 (exp -> exp TIMES exp .)
    NEQ             reduce using rule 66 (exp -> exp TIMES exp .)
    GEQ             reduce using rule 66 (exp -> exp TIMES exp .)
    LEQ             reduce using rule 66 (exp -> exp TIMES exp .)
    GT              reduce using rule 66 (exp -> exp TIMES exp .)
    LT              reduce using rule 66 (exp -> exp TIMES exp .)

  ! PLUS            [ shift and go to state 133 ]
  ! TIMES           [ shift and go to state 134 ]
  ! MINUS           [ shift and go to state 135 ]
  ! BY              [ shift and go to state 132 ]


state 157

    (67) exp -> exp MINUS exp .
    (65) exp -> exp . PLUS exp
    (66) exp -> exp . TIMES exp
    (67) exp -> exp . MINUS exp
    (68) exp -> exp . BY exp

    NL              reduce using rule 67 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 67 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 67 (exp -> exp MINUS exp .)
    COLON           reduce using rule 67 (exp -> exp MINUS exp .)
    RPAR            reduce using rule 67 (exp -> exp MINUS exp .)
    COMMA           reduce using rule 67 (exp -> exp MINUS exp .)
    AND             reduce using rule 67 (exp -> exp MINUS exp .)
    OR              reduce using rule 67 (exp -> exp MINUS exp .)
    EQ              reduce using rule 67 (exp -> exp MINUS exp .)
    NEQ             reduce using rule 67 (exp -> exp MINUS exp .)
    GEQ             reduce using rule 67 (exp -> exp MINUS exp .)
    LEQ             reduce using rule 67 (exp -> exp MINUS exp .)
    GT              reduce using rule 67 (exp -> exp MINUS exp .)
    LT              reduce using rule 67 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 134
    BY              shift and go to state 132

  ! TIMES           [ reduce using rule 67 (exp -> exp MINUS exp .) ]
  ! BY              [ reduce using rule 67 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 133 ]
  ! MINUS           [ shift and go to state 135 ]


state 158

    (20) mapdecl -> MAP LT type COMMA type GT . varname
    (78) varname -> . LID

    LID             shift and go to state 62

    varname                        shift and go to state 181

state 159

    (7) actuatordecls -> ACTUATORS COLON NL INDENT pass . DEDENT

    DEDENT          shift and go to state 182


state 160

    (6) actuatordecls -> ACTUATORS COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 183


state 161

    (8) sensordecls -> SENSORS COLON NL INDENT . decls DEDENT
    (9) sensordecls -> SENSORS COLON NL INDENT . pass DEDENT
    (15) decls -> . decl decls
    (16) decls -> . type varnames NL
    (17) decls -> . empty
    (62) pass -> . PASS NL
    (18) decl -> . type varname ASGN exp NL
    (19) decl -> . mapdecl NL
    (35) type -> . INT
    (36) type -> . STRING
    (37) type -> . FLOAT
    (38) type -> . IPOS
    (39) type -> . BOOLEAN
    (85) empty -> .
    (20) mapdecl -> . MAP LT type COMMA type GT varname

    PASS            shift and go to state 43
    INT             shift and go to state 46
    STRING          shift and go to state 42
    FLOAT           shift and go to state 47
    IPOS            shift and go to state 39
    BOOLEAN         shift and go to state 48
    DEDENT          reduce using rule 85 (empty -> .)
    MAP             shift and go to state 45

    decl                           shift and go to state 36
    mapdecl                        shift and go to state 37
    pass                           shift and go to state 184
    decls                          shift and go to state 185
    type                           shift and go to state 40
    empty                          shift and go to state 41

state 162

    (23) rvdecl -> type varname LBRACE owner RBRACE NL .

    INT             reduce using rule 23 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    STRING          reduce using rule 23 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    FLOAT           reduce using rule 23 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    IPOS            reduce using rule 23 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    BOOLEAN         reduce using rule 23 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    DEDENT          reduce using rule 23 (rvdecl -> type varname LBRACE owner RBRACE NL .)


state 163

    (24) rvdecl -> type varname LBRACE owner RBRACE ASGN . num NL
    (76) num -> . INUM
    (77) num -> . FNUM

    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    num                            shift and go to state 186

state 164

    (60) modulefunccall -> CID LPAR args RPAR .

    NL              reduce using rule 60 (modulefunccall -> CID LPAR args RPAR .)


state 165

    (32) neargs -> exp COMMA . neargs
    (31) neargs -> . exp
    (32) neargs -> . exp COMMA neargs
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 99
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    exp                            shift and go to state 144
    neargs                         shift and go to state 187
    bval                           shift and go to state 98

state 166

    (58) stmt -> ATOMIC COLON NL INDENT . stmts DEDENT
    (52) stmts -> . stmt stmts
    (53) stmts -> . empty
    (54) stmt -> . asgn
    (55) stmt -> . pass
    (56) stmt -> . funccall NL
    (57) stmt -> . modulefunccall NL
    (58) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (59) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (85) empty -> .
    (63) asgn -> . varname ASGN exp NL
    (62) pass -> . PASS NL
    (27) funccall -> . varname LPAR args RPAR
    (60) modulefunccall -> . CID LPAR args RPAR
    (78) varname -> . LID

    ATOMIC          shift and go to state 86
    IF              shift and go to state 94
    DEDENT          reduce using rule 85 (empty -> .)
    PASS            shift and go to state 43
    CID             shift and go to state 85
    LID             shift and go to state 62

    funccall                       shift and go to state 91
    stmts                          shift and go to state 188
    varname                        shift and go to state 95
    stmt                           shift and go to state 93
    asgn                           shift and go to state 89
    modulefunccall                 shift and go to state 92
    pass                           shift and go to state 87
    empty                          shift and go to state 90

state 167

    (47) cond -> LPAR cond AND . cond RPAR
    (47) cond -> . LPAR cond AND cond RPAR
    (48) cond -> . LPAR cond OR cond RPAR
    (49) cond -> . LPAR cond op cond RPAR
    (50) cond -> . LPAR NOT cond RPAR
    (51) cond -> . exp
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 124
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    cond                           shift and go to state 189
    exp                            shift and go to state 126
    bval                           shift and go to state 98

state 168

    (81) op -> GEQ .

    LPAR            reduce using rule 81 (op -> GEQ .)
    LID             reduce using rule 81 (op -> GEQ .)
    TRUE            reduce using rule 81 (op -> GEQ .)
    FALSE           reduce using rule 81 (op -> GEQ .)
    INUM            reduce using rule 81 (op -> GEQ .)
    FNUM            reduce using rule 81 (op -> GEQ .)


state 169

    (83) op -> GT .

    LPAR            reduce using rule 83 (op -> GT .)
    LID             reduce using rule 83 (op -> GT .)
    TRUE            reduce using rule 83 (op -> GT .)
    FALSE           reduce using rule 83 (op -> GT .)
    INUM            reduce using rule 83 (op -> GT .)
    FNUM            reduce using rule 83 (op -> GT .)


state 170

    (82) op -> LEQ .

    LPAR            reduce using rule 82 (op -> LEQ .)
    LID             reduce using rule 82 (op -> LEQ .)
    TRUE            reduce using rule 82 (op -> LEQ .)
    FALSE           reduce using rule 82 (op -> LEQ .)
    INUM            reduce using rule 82 (op -> LEQ .)
    FNUM            reduce using rule 82 (op -> LEQ .)


state 171

    (84) op -> LT .

    LPAR            reduce using rule 84 (op -> LT .)
    LID             reduce using rule 84 (op -> LT .)
    TRUE            reduce using rule 84 (op -> LT .)
    FALSE           reduce using rule 84 (op -> LT .)
    INUM            reduce using rule 84 (op -> LT .)
    FNUM            reduce using rule 84 (op -> LT .)


state 172

    (80) op -> NEQ .

    LPAR            reduce using rule 80 (op -> NEQ .)
    LID             reduce using rule 80 (op -> NEQ .)
    TRUE            reduce using rule 80 (op -> NEQ .)
    FALSE           reduce using rule 80 (op -> NEQ .)
    INUM            reduce using rule 80 (op -> NEQ .)
    FNUM            reduce using rule 80 (op -> NEQ .)


state 173

    (79) op -> EQ .

    LPAR            reduce using rule 79 (op -> EQ .)
    LID             reduce using rule 79 (op -> EQ .)
    TRUE            reduce using rule 79 (op -> EQ .)
    FALSE           reduce using rule 79 (op -> EQ .)
    INUM            reduce using rule 79 (op -> EQ .)
    FNUM            reduce using rule 79 (op -> EQ .)


state 174

    (48) cond -> LPAR cond OR . cond RPAR
    (47) cond -> . LPAR cond AND cond RPAR
    (48) cond -> . LPAR cond OR cond RPAR
    (49) cond -> . LPAR cond op cond RPAR
    (50) cond -> . LPAR NOT cond RPAR
    (51) cond -> . exp
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 124
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    cond                           shift and go to state 190
    exp                            shift and go to state 126
    bval                           shift and go to state 98

state 175

    (49) cond -> LPAR cond op . cond RPAR
    (47) cond -> . LPAR cond AND cond RPAR
    (48) cond -> . LPAR cond OR cond RPAR
    (49) cond -> . LPAR cond op cond RPAR
    (50) cond -> . LPAR NOT cond RPAR
    (51) cond -> . exp
    (64) exp -> . bracketexp
    (65) exp -> . exp PLUS exp
    (66) exp -> . exp TIMES exp
    (67) exp -> . exp MINUS exp
    (68) exp -> . exp BY exp
    (69) exp -> . varname
    (70) exp -> . bval
    (71) exp -> . num
    (72) exp -> . funccall
    (73) bracketexp -> . LPAR exp RPAR
    (78) varname -> . LID
    (74) bval -> . TRUE
    (75) bval -> . FALSE
    (76) num -> . INUM
    (77) num -> . FNUM
    (27) funccall -> . varname LPAR args RPAR

    LPAR            shift and go to state 124
    LID             shift and go to state 62
    TRUE            shift and go to state 108
    FALSE           shift and go to state 107
    INUM            shift and go to state 106
    FNUM            shift and go to state 103

    bracketexp                     shift and go to state 100
    funccall                       shift and go to state 101
    varname                        shift and go to state 102
    num                            shift and go to state 104
    cond                           shift and go to state 191
    exp                            shift and go to state 126
    bval                           shift and go to state 98

state 176

    (50) cond -> LPAR NOT cond . RPAR

    RPAR            shift and go to state 192


state 177

    (59) stmt -> IF cond COLON NL . INDENT stmts DEDENT elseblock

    INDENT          shift and go to state 193


state 178

    (27) funccall -> varname LPAR args RPAR .

    NL              reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    PLUS            reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    TIMES           reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    MINUS           reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    BY              reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    RPAR            reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    COMMA           reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    AND             reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    OR              reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    EQ              reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    NEQ             reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    GEQ             reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    LEQ             reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    GT              reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    LT              reduce using rule 27 (funccall -> varname LPAR args RPAR .)
    COLON           reduce using rule 27 (funccall -> varname LPAR args RPAR .)


state 179

    (63) asgn -> varname ASGN exp NL .

    ATOMIC          reduce using rule 63 (asgn -> varname ASGN exp NL .)
    IF              reduce using rule 63 (asgn -> varname ASGN exp NL .)
    PASS            reduce using rule 63 (asgn -> varname ASGN exp NL .)
    CID             reduce using rule 63 (asgn -> varname ASGN exp NL .)
    LID             reduce using rule 63 (asgn -> varname ASGN exp NL .)
    DEDENT          reduce using rule 63 (asgn -> varname ASGN exp NL .)


state 180

    (44) event -> LID COLON NL INDENT PRE COLON cond . NL effblock DEDENT

    NL              shift and go to state 194


state 181

    (20) mapdecl -> MAP LT type COMMA type GT varname .

    NL              reduce using rule 20 (mapdecl -> MAP LT type COMMA type GT varname .)


state 182

    (7) actuatordecls -> ACTUATORS COLON NL INDENT pass DEDENT .

    SENSORS         reduce using rule 7 (actuatordecls -> ACTUATORS COLON NL INDENT pass DEDENT .)


state 183

    (6) actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT .

    SENSORS         reduce using rule 6 (actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT .)


state 184

    (9) sensordecls -> SENSORS COLON NL INDENT pass . DEDENT

    DEDENT          shift and go to state 195


state 185

    (8) sensordecls -> SENSORS COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 196


state 186

    (24) rvdecl -> type varname LBRACE owner RBRACE ASGN num . NL

    NL              shift and go to state 197


state 187

    (32) neargs -> exp COMMA neargs .

    RPAR            reduce using rule 32 (neargs -> exp COMMA neargs .)


state 188

    (58) stmt -> ATOMIC COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 198


state 189

    (47) cond -> LPAR cond AND cond . RPAR

    RPAR            shift and go to state 199


state 190

    (48) cond -> LPAR cond OR cond . RPAR

    RPAR            shift and go to state 200


state 191

    (49) cond -> LPAR cond op cond . RPAR

    RPAR            shift and go to state 201


state 192

    (50) cond -> LPAR NOT cond RPAR .

    RPAR            reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    AND             reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    OR              reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    EQ              reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    NEQ             reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    GEQ             reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    LEQ             reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    GT              reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    LT              reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    NL              reduce using rule 50 (cond -> LPAR NOT cond RPAR .)
    COLON           reduce using rule 50 (cond -> LPAR NOT cond RPAR .)


state 193

    (59) stmt -> IF cond COLON NL INDENT . stmts DEDENT elseblock
    (52) stmts -> . stmt stmts
    (53) stmts -> . empty
    (54) stmt -> . asgn
    (55) stmt -> . pass
    (56) stmt -> . funccall NL
    (57) stmt -> . modulefunccall NL
    (58) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (59) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (85) empty -> .
    (63) asgn -> . varname ASGN exp NL
    (62) pass -> . PASS NL
    (27) funccall -> . varname LPAR args RPAR
    (60) modulefunccall -> . CID LPAR args RPAR
    (78) varname -> . LID

    ATOMIC          shift and go to state 86
    IF              shift and go to state 94
    DEDENT          reduce using rule 85 (empty -> .)
    PASS            shift and go to state 43
    CID             shift and go to state 85
    LID             shift and go to state 62

    funccall                       shift and go to state 91
    stmts                          shift and go to state 202
    varname                        shift and go to state 95
    stmt                           shift and go to state 93
    asgn                           shift and go to state 89
    modulefunccall                 shift and go to state 92
    pass                           shift and go to state 87
    empty                          shift and go to state 90

state 194

    (44) event -> LID COLON NL INDENT PRE COLON cond NL . effblock DEDENT
    (45) effblock -> . EFF COLON NL INDENT stmts DEDENT
    (46) effblock -> . EFF COLON stmt

    EFF             shift and go to state 204

    effblock                       shift and go to state 203

state 195

    (9) sensordecls -> SENSORS COLON NL INDENT pass DEDENT .

    DEDENT          reduce using rule 9 (sensordecls -> SENSORS COLON NL INDENT pass DEDENT .)


state 196

    (8) sensordecls -> SENSORS COLON NL INDENT decls DEDENT .

    DEDENT          reduce using rule 8 (sensordecls -> SENSORS COLON NL INDENT decls DEDENT .)


state 197

    (24) rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .

    INT             reduce using rule 24 (rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .)
    STRING          reduce using rule 24 (rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .)
    FLOAT           reduce using rule 24 (rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .)
    IPOS            reduce using rule 24 (rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .)
    BOOLEAN         reduce using rule 24 (rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .)
    DEDENT          reduce using rule 24 (rvdecl -> type varname LBRACE owner RBRACE ASGN num NL .)


state 198

    (58) stmt -> ATOMIC COLON NL INDENT stmts DEDENT .

    ATOMIC          reduce using rule 58 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    IF              reduce using rule 58 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    PASS            reduce using rule 58 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    CID             reduce using rule 58 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    LID             reduce using rule 58 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    DEDENT          reduce using rule 58 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)


state 199

    (47) cond -> LPAR cond AND cond RPAR .

    RPAR            reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    AND             reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    OR              reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    EQ              reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    NEQ             reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    GEQ             reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    LEQ             reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    GT              reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    LT              reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    NL              reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)
    COLON           reduce using rule 47 (cond -> LPAR cond AND cond RPAR .)


state 200

    (48) cond -> LPAR cond OR cond RPAR .

    RPAR            reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    AND             reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    OR              reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    EQ              reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    NEQ             reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    GEQ             reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    LEQ             reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    GT              reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    LT              reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    NL              reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)
    COLON           reduce using rule 48 (cond -> LPAR cond OR cond RPAR .)


state 201

    (49) cond -> LPAR cond op cond RPAR .

    RPAR            reduce using rule 49 (cond -> LPAR cond op cond RPAR .)
    AND             reduce using rule 49 (cond -> LPAR cond op cond RPAR .)
    OR              reduce using rule 49 (cond -> LPAR cond op cond RPAR .)
    EQ              reduce using rule 49 (cond -> LPAR cond op cond RPAR .)
    NEQ             reduce using rule 49 (cond -> LPAR cond op cond RPAR .)
    GEQ             reduce using rule 49 (cond -> LPAR cond op cond RPAR .)
    LEQ             reduce using rule 49 (cond -> LPAR cond op cond RPAR .)
    GT              reduce using rule 49 (cond -> LPAR cond op cond RPAR .)
    LT              reduce using rule 49 (cond -> LPAR cond op cond RPAR .)
    NL              reduce using rule 49 (cond -> LPAR cond op cond RPAR .)
    COLON           reduce using rule 49 (cond -> LPAR cond op cond RPAR .)


state 202

    (59) stmt -> IF cond COLON NL INDENT stmts . DEDENT elseblock

    DEDENT          shift and go to state 205


state 203

    (44) event -> LID COLON NL INDENT PRE COLON cond NL effblock . DEDENT

    DEDENT          shift and go to state 206


state 204

    (45) effblock -> EFF . COLON NL INDENT stmts DEDENT
    (46) effblock -> EFF . COLON stmt

    COLON           shift and go to state 207


state 205

    (59) stmt -> IF cond COLON NL INDENT stmts DEDENT . elseblock
    (61) elseblock -> . ELSE COLON NL INDENT stmts DEDENT

    ELSE            shift and go to state 209

    elseblock                      shift and go to state 208

state 206

    (44) event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .

    LID             reduce using rule 44 (event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .)
    $end            reduce using rule 44 (event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .)


state 207

    (45) effblock -> EFF COLON . NL INDENT stmts DEDENT
    (46) effblock -> EFF COLON . stmt
    (54) stmt -> . asgn
    (55) stmt -> . pass
    (56) stmt -> . funccall NL
    (57) stmt -> . modulefunccall NL
    (58) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (59) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (63) asgn -> . varname ASGN exp NL
    (62) pass -> . PASS NL
    (27) funccall -> . varname LPAR args RPAR
    (60) modulefunccall -> . CID LPAR args RPAR
    (78) varname -> . LID

    NL              shift and go to state 210
    ATOMIC          shift and go to state 86
    IF              shift and go to state 94
    PASS            shift and go to state 43
    CID             shift and go to state 85
    LID             shift and go to state 62

    funccall                       shift and go to state 91
    varname                        shift and go to state 95
    stmt                           shift and go to state 211
    asgn                           shift and go to state 89
    modulefunccall                 shift and go to state 92
    pass                           shift and go to state 87

state 208

    (59) stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .

    ATOMIC          reduce using rule 59 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    IF              reduce using rule 59 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    PASS            reduce using rule 59 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    CID             reduce using rule 59 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    LID             reduce using rule 59 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    DEDENT          reduce using rule 59 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)


state 209

    (61) elseblock -> ELSE . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 212


state 210

    (45) effblock -> EFF COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 213


state 211

    (46) effblock -> EFF COLON stmt .

    DEDENT          reduce using rule 46 (effblock -> EFF COLON stmt .)


state 212

    (61) elseblock -> ELSE COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 214


state 213

    (45) effblock -> EFF COLON NL INDENT . stmts DEDENT
    (52) stmts -> . stmt stmts
    (53) stmts -> . empty
    (54) stmt -> . asgn
    (55) stmt -> . pass
    (56) stmt -> . funccall NL
    (57) stmt -> . modulefunccall NL
    (58) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (59) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (85) empty -> .
    (63) asgn -> . varname ASGN exp NL
    (62) pass -> . PASS NL
    (27) funccall -> . varname LPAR args RPAR
    (60) modulefunccall -> . CID LPAR args RPAR
    (78) varname -> . LID

    ATOMIC          shift and go to state 86
    IF              shift and go to state 94
    DEDENT          reduce using rule 85 (empty -> .)
    PASS            shift and go to state 43
    CID             shift and go to state 85
    LID             shift and go to state 62

    funccall                       shift and go to state 91
    stmts                          shift and go to state 215
    varname                        shift and go to state 95
    stmt                           shift and go to state 93
    asgn                           shift and go to state 89
    modulefunccall                 shift and go to state 92
    pass                           shift and go to state 87
    empty                          shift and go to state 90

state 214

    (61) elseblock -> ELSE COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 216


state 215

    (45) effblock -> EFF COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 217


state 216

    (61) elseblock -> ELSE COLON NL INDENT . stmts DEDENT
    (52) stmts -> . stmt stmts
    (53) stmts -> . empty
    (54) stmt -> . asgn
    (55) stmt -> . pass
    (56) stmt -> . funccall NL
    (57) stmt -> . modulefunccall NL
    (58) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (59) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (85) empty -> .
    (63) asgn -> . varname ASGN exp NL
    (62) pass -> . PASS NL
    (27) funccall -> . varname LPAR args RPAR
    (60) modulefunccall -> . CID LPAR args RPAR
    (78) varname -> . LID

    ATOMIC          shift and go to state 86
    IF              shift and go to state 94
    DEDENT          reduce using rule 85 (empty -> .)
    PASS            shift and go to state 43
    CID             shift and go to state 85
    LID             shift and go to state 62

    funccall                       shift and go to state 91
    stmts                          shift and go to state 218
    varname                        shift and go to state 95
    stmt                           shift and go to state 93
    asgn                           shift and go to state 89
    modulefunccall                 shift and go to state 92
    pass                           shift and go to state 87
    empty                          shift and go to state 90

state 217

    (45) effblock -> EFF COLON NL INDENT stmts DEDENT .

    DEDENT          reduce using rule 45 (effblock -> EFF COLON NL INDENT stmts DEDENT .)


state 218

    (61) elseblock -> ELSE COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 219


state 219

    (61) elseblock -> ELSE COLON NL INDENT stmts DEDENT .

    ATOMIC          reduce using rule 61 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    IF              reduce using rule 61 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    PASS            reduce using rule 61 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    CID             reduce using rule 61 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    LID             reduce using rule 61 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    DEDENT          reduce using rule 61 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)

