Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Unused terminals:

    WS
    PASS
    MAP

Grammar

Rule 0     S' -> program
Rule 1     program -> agent modules awdecls ardecls locdecls stagedecl init events Numdecl
Rule 2     Numdecl -> NUM INUM NL
Rule 3     stagedecl -> DEF STAGE LCURLY stagelist RCURLY NL
Rule 4     stagedecl -> empty
Rule 5     stagelist -> LID COMMA stagelist
Rule 6     stagelist -> LID
Rule 7     agent -> AGENT CID NL
Rule 8     modules -> module modules
Rule 9     modules -> empty
Rule 10    module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT
Rule 11    actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT
Rule 12    actuatordecls -> empty
Rule 13    sensordecls -> SENSORS COLON NL INDENT decls DEDENT
Rule 14    sensordecls -> empty
Rule 15    awdecls -> ALLWRITE COLON NL INDENT decls DEDENT
Rule 16    awdecls -> empty
Rule 17    ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT
Rule 18    ardecls -> empty
Rule 19    locdecls -> LOCAL COLON NL INDENT decls DEDENT
Rule 20    locdecls -> empty
Rule 21    decls -> decl decls
Rule 22    decls -> empty
Rule 23    decl -> type varname ASGN exp NL
Rule 24    decl -> type varname NL
Rule 25    rvdecls -> rvdecl rvdecls
Rule 26    rvdecls -> empty
Rule 27    rvdecl -> type varname LBRACE owner RBRACE NL
Rule 28    owner -> TIMES
Rule 29    owner -> INUM
Rule 30    funccall -> varname LPAR args RPAR
Rule 31    args -> neargs
Rule 32    args -> noargs
Rule 33    noargs -> empty
Rule 34    neargs -> exp
Rule 35    neargs -> exp COMMA neargs
Rule 36    type -> INT
Rule 37    type -> STRING
Rule 38    type -> FLOAT
Rule 39    type -> IPOS
Rule 40    type -> BOOLEAN
Rule 41    init -> INIT COLON NL INDENT stmts DEDENT
Rule 42    init -> empty
Rule 43    events -> event events
Rule 44    events -> event
Rule 45    event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT
Rule 46    effblock -> EFF COLON NL INDENT stmts DEDENT
Rule 47    effblock -> EFF COLON stmt
Rule 48    cond -> LPAR cond AND cond RPAR
Rule 49    cond -> LPAR cond OR cond RPAR
Rule 50    cond -> LPAR cond op cond RPAR
Rule 51    cond -> LPAR NOT cond RPAR
Rule 52    cond -> exp
Rule 53    stmts -> stmt stmts
Rule 54    stmts -> stmt
Rule 55    stmt -> asgn
Rule 56    stmt -> wptstmt
Rule 57    stmt -> exit
Rule 58    stmt -> funccall NL
Rule 59    stmt -> modulefunccall NL
Rule 60    stmt -> ATOMIC COLON NL INDENT stmts DEDENT
Rule 61    stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock
Rule 62    exit -> EXIT NL
Rule 63    modulefunccall -> CID LPAR args RPAR
Rule 64    elseblock -> ELSE COLON NL INDENT stmts DEDENT
Rule 65    elseblock -> empty
Rule 66    asgn -> varname ASGN exp NL
Rule 67    asgn -> stagechange
Rule 68    moduleflag -> CID
Rule 69    stagechange -> STAGE ASGN varname NL
Rule 70    wptstmt -> varname ASGN GETINPUT LPAR RPAR NL
Rule 71    exp -> bracketexp
Rule 72    exp -> exp PLUS exp
Rule 73    exp -> exp TIMES exp
Rule 74    exp -> exp MINUS exp
Rule 75    exp -> exp BY exp
Rule 76    exp -> varname
Rule 77    exp -> STAGE
Rule 78    exp -> bval
Rule 79    exp -> pid
Rule 80    exp -> LID LBRACE exp RBRACE
Rule 81    exp -> num
Rule 82    exp -> null
Rule 83    exp -> funccall
Rule 84    exp -> modulefunccall
Rule 85    bracketexp -> LPAR exp RPAR
Rule 86    bval -> TRUE
Rule 87    bval -> FALSE
Rule 88    num -> INUM
Rule 89    num -> FNUM
Rule 90    pid -> PID
Rule 91    varname -> LID
Rule 92    null -> NULL
Rule 93    op -> EQ
Rule 94    op -> NEQ
Rule 95    op -> GEQ
Rule 96    op -> LEQ
Rule 97    op -> GT
Rule 98    op -> LT
Rule 99    empty -> <empty>

Terminals, with rules where they appear

ACTUATORS            : 11
AGENT                : 7
ALLREAD              : 17
ALLWRITE             : 15
AND                  : 48
ASGN                 : 23 66 69 70
ATOMIC               : 60
BOOLEAN              : 40
BY                   : 75
CID                  : 7 10 63 68
COLON                : 10 11 13 15 17 19 41 45 45 46 47 60 61 64
COMMA                : 5 35
DEDENT               : 10 11 13 15 17 19 41 45 46 60 61 64
DEF                  : 3
EFF                  : 46 47
ELSE                 : 64
EQ                   : 93
EXIT                 : 62
FALSE                : 87
FLOAT                : 38
FNUM                 : 89
GEQ                  : 95
GETINPUT             : 70
GT                   : 97
IF                   : 61
INDENT               : 10 11 13 15 17 19 41 45 46 60 61 64
INIT                 : 41
INT                  : 36
INUM                 : 2 29 88
IPOS                 : 39
LBRACE               : 27 80
LCURLY               : 3
LEQ                  : 96
LID                  : 5 6 45 80 91
LOCAL                : 19
LPAR                 : 30 48 49 50 51 63 70 85
LT                   : 98
MAP                  : 
MINUS                : 74
MODULE               : 10
NEQ                  : 94
NL                   : 2 3 7 10 11 13 15 17 19 23 24 27 41 45 45 46 58 59 60 61 62 64 66 69 70
NOT                  : 51
NULL                 : 92
NUM                  : 2
OR                   : 49
PASS                 : 
PID                  : 90
PLUS                 : 72
PRE                  : 45
RBRACE               : 27 80
RCURLY               : 3
RPAR                 : 30 48 49 50 51 63 70 85
SENSORS              : 13
STAGE                : 3 69 77
STRING               : 37
TIMES                : 28 73
TRUE                 : 86
USING                : 10
WS                   : 
error                : 

Nonterminals, with rules where they appear

Numdecl              : 1
actuatordecls        : 10
agent                : 1
ardecls              : 1
args                 : 30 63
asgn                 : 55
awdecls              : 1
bracketexp           : 71
bval                 : 78
cond                 : 45 48 48 49 49 50 50 51 61
decl                 : 21
decls                : 11 13 15 19 21
effblock             : 45
elseblock            : 61
empty                : 4 9 12 14 16 18 20 22 26 33 42 65
event                : 43 44
events               : 1 43
exit                 : 57
exp                  : 23 34 35 52 66 72 72 73 73 74 74 75 75 80 85
funccall             : 58 83
init                 : 1
locdecls             : 1
module               : 8
moduleflag           : 
modulefunccall       : 59 84
modules              : 1 8
neargs               : 31 35
noargs               : 32
null                 : 82
num                  : 81
op                   : 50
owner                : 27
pid                  : 79
program              : 0
rvdecl               : 25
rvdecls              : 17 25
sensordecls          : 10
stagechange          : 67
stagedecl            : 1
stagelist            : 3 5
stmt                 : 47 53 54
stmts                : 41 46 53 60 61 64
type                 : 23 24 27
varname              : 23 24 27 30 66 69 70 76
wptstmt              : 56

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . agent modules awdecls ardecls locdecls stagedecl init events Numdecl
    (7) agent -> . AGENT CID NL

    AGENT           shift and go to state 1

    agent                          shift and go to state 2
    program                        shift and go to state 3

state 1

    (7) agent -> AGENT . CID NL

    CID             shift and go to state 4


state 2

    (1) program -> agent . modules awdecls ardecls locdecls stagedecl init events Numdecl
    (8) modules -> . module modules
    (9) modules -> . empty
    (10) module -> . USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT
    (99) empty -> .

    USING           shift and go to state 7
    ALLWRITE        reduce using rule 99 (empty -> .)
    ALLREAD         reduce using rule 99 (empty -> .)
    LOCAL           reduce using rule 99 (empty -> .)
    DEF             reduce using rule 99 (empty -> .)
    INIT            reduce using rule 99 (empty -> .)
    LID             reduce using rule 99 (empty -> .)

    module                         shift and go to state 5
    modules                        shift and go to state 6
    empty                          shift and go to state 8

state 3

    (0) S' -> program .



state 4

    (7) agent -> AGENT CID . NL

    NL              shift and go to state 9


state 5

    (8) modules -> module . modules
    (8) modules -> . module modules
    (9) modules -> . empty
    (10) module -> . USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT
    (99) empty -> .

    USING           shift and go to state 7
    ALLWRITE        reduce using rule 99 (empty -> .)
    ALLREAD         reduce using rule 99 (empty -> .)
    LOCAL           reduce using rule 99 (empty -> .)
    DEF             reduce using rule 99 (empty -> .)
    INIT            reduce using rule 99 (empty -> .)
    LID             reduce using rule 99 (empty -> .)

    modules                        shift and go to state 10
    empty                          shift and go to state 8
    module                         shift and go to state 5

state 6

    (1) program -> agent modules . awdecls ardecls locdecls stagedecl init events Numdecl
    (15) awdecls -> . ALLWRITE COLON NL INDENT decls DEDENT
    (16) awdecls -> . empty
    (99) empty -> .

    ALLWRITE        shift and go to state 12
    ALLREAD         reduce using rule 99 (empty -> .)
    LOCAL           reduce using rule 99 (empty -> .)
    DEF             reduce using rule 99 (empty -> .)
    INIT            reduce using rule 99 (empty -> .)
    LID             reduce using rule 99 (empty -> .)

    awdecls                        shift and go to state 11
    empty                          shift and go to state 13

state 7

    (10) module -> USING . MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT

    MODULE          shift and go to state 14


state 8

    (9) modules -> empty .

    ALLWRITE        reduce using rule 9 (modules -> empty .)
    ALLREAD         reduce using rule 9 (modules -> empty .)
    LOCAL           reduce using rule 9 (modules -> empty .)
    DEF             reduce using rule 9 (modules -> empty .)
    INIT            reduce using rule 9 (modules -> empty .)
    LID             reduce using rule 9 (modules -> empty .)


state 9

    (7) agent -> AGENT CID NL .

    USING           reduce using rule 7 (agent -> AGENT CID NL .)
    ALLWRITE        reduce using rule 7 (agent -> AGENT CID NL .)
    ALLREAD         reduce using rule 7 (agent -> AGENT CID NL .)
    LOCAL           reduce using rule 7 (agent -> AGENT CID NL .)
    DEF             reduce using rule 7 (agent -> AGENT CID NL .)
    INIT            reduce using rule 7 (agent -> AGENT CID NL .)
    LID             reduce using rule 7 (agent -> AGENT CID NL .)


state 10

    (8) modules -> module modules .

    ALLWRITE        reduce using rule 8 (modules -> module modules .)
    ALLREAD         reduce using rule 8 (modules -> module modules .)
    LOCAL           reduce using rule 8 (modules -> module modules .)
    DEF             reduce using rule 8 (modules -> module modules .)
    INIT            reduce using rule 8 (modules -> module modules .)
    LID             reduce using rule 8 (modules -> module modules .)


state 11

    (1) program -> agent modules awdecls . ardecls locdecls stagedecl init events Numdecl
    (17) ardecls -> . ALLREAD COLON NL INDENT rvdecls DEDENT
    (18) ardecls -> . empty
    (99) empty -> .

    ALLREAD         shift and go to state 15
    LOCAL           reduce using rule 99 (empty -> .)
    DEF             reduce using rule 99 (empty -> .)
    INIT            reduce using rule 99 (empty -> .)
    LID             reduce using rule 99 (empty -> .)

    ardecls                        shift and go to state 16
    empty                          shift and go to state 17

state 12

    (15) awdecls -> ALLWRITE . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 18


state 13

    (16) awdecls -> empty .

    ALLREAD         reduce using rule 16 (awdecls -> empty .)
    LOCAL           reduce using rule 16 (awdecls -> empty .)
    DEF             reduce using rule 16 (awdecls -> empty .)
    INIT            reduce using rule 16 (awdecls -> empty .)
    LID             reduce using rule 16 (awdecls -> empty .)


state 14

    (10) module -> USING MODULE . CID COLON NL INDENT actuatordecls sensordecls DEDENT

    CID             shift and go to state 19


state 15

    (17) ardecls -> ALLREAD . COLON NL INDENT rvdecls DEDENT

    COLON           shift and go to state 20


state 16

    (1) program -> agent modules awdecls ardecls . locdecls stagedecl init events Numdecl
    (19) locdecls -> . LOCAL COLON NL INDENT decls DEDENT
    (20) locdecls -> . empty
    (99) empty -> .

    LOCAL           shift and go to state 22
    DEF             reduce using rule 99 (empty -> .)
    INIT            reduce using rule 99 (empty -> .)
    LID             reduce using rule 99 (empty -> .)

    locdecls                       shift and go to state 21
    empty                          shift and go to state 23

state 17

    (18) ardecls -> empty .

    LOCAL           reduce using rule 18 (ardecls -> empty .)
    DEF             reduce using rule 18 (ardecls -> empty .)
    INIT            reduce using rule 18 (ardecls -> empty .)
    LID             reduce using rule 18 (ardecls -> empty .)


state 18

    (15) awdecls -> ALLWRITE COLON . NL INDENT decls DEDENT

    NL              shift and go to state 24


state 19

    (10) module -> USING MODULE CID . COLON NL INDENT actuatordecls sensordecls DEDENT

    COLON           shift and go to state 25


state 20

    (17) ardecls -> ALLREAD COLON . NL INDENT rvdecls DEDENT

    NL              shift and go to state 26


state 21

    (1) program -> agent modules awdecls ardecls locdecls . stagedecl init events Numdecl
    (3) stagedecl -> . DEF STAGE LCURLY stagelist RCURLY NL
    (4) stagedecl -> . empty
    (99) empty -> .

    DEF             shift and go to state 29
    INIT            reduce using rule 99 (empty -> .)
    LID             reduce using rule 99 (empty -> .)

    stagedecl                      shift and go to state 28
    empty                          shift and go to state 27

state 22

    (19) locdecls -> LOCAL . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 30


state 23

    (20) locdecls -> empty .

    DEF             reduce using rule 20 (locdecls -> empty .)
    INIT            reduce using rule 20 (locdecls -> empty .)
    LID             reduce using rule 20 (locdecls -> empty .)


state 24

    (15) awdecls -> ALLWRITE COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 31


state 25

    (10) module -> USING MODULE CID COLON . NL INDENT actuatordecls sensordecls DEDENT

    NL              shift and go to state 32


state 26

    (17) ardecls -> ALLREAD COLON NL . INDENT rvdecls DEDENT

    INDENT          shift and go to state 33


state 27

    (4) stagedecl -> empty .

    INIT            reduce using rule 4 (stagedecl -> empty .)
    LID             reduce using rule 4 (stagedecl -> empty .)


state 28

    (1) program -> agent modules awdecls ardecls locdecls stagedecl . init events Numdecl
    (41) init -> . INIT COLON NL INDENT stmts DEDENT
    (42) init -> . empty
    (99) empty -> .

    INIT            shift and go to state 34
    LID             reduce using rule 99 (empty -> .)

    init                           shift and go to state 35
    empty                          shift and go to state 36

state 29

    (3) stagedecl -> DEF . STAGE LCURLY stagelist RCURLY NL

    STAGE           shift and go to state 37


state 30

    (19) locdecls -> LOCAL COLON . NL INDENT decls DEDENT

    NL              shift and go to state 38


state 31

    (15) awdecls -> ALLWRITE COLON NL INDENT . decls DEDENT
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (99) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 99 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    decl                           shift and go to state 39
    decls                          shift and go to state 46
    type                           shift and go to state 45
    empty                          shift and go to state 47

state 32

    (10) module -> USING MODULE CID COLON NL . INDENT actuatordecls sensordecls DEDENT

    INDENT          shift and go to state 48


state 33

    (17) ardecls -> ALLREAD COLON NL INDENT . rvdecls DEDENT
    (25) rvdecls -> . rvdecl rvdecls
    (26) rvdecls -> . empty
    (27) rvdecl -> . type varname LBRACE owner RBRACE NL
    (99) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 99 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    rvdecl                         shift and go to state 49
    rvdecls                        shift and go to state 50
    type                           shift and go to state 51
    empty                          shift and go to state 52

state 34

    (41) init -> INIT . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 53


state 35

    (1) program -> agent modules awdecls ardecls locdecls stagedecl init . events Numdecl
    (43) events -> . event events
    (44) events -> . event
    (45) event -> . LID COLON NL INDENT PRE COLON cond NL effblock DEDENT

    LID             shift and go to state 54

    event                          shift and go to state 55
    events                         shift and go to state 56

state 36

    (42) init -> empty .

    LID             reduce using rule 42 (init -> empty .)


state 37

    (3) stagedecl -> DEF STAGE . LCURLY stagelist RCURLY NL

    LCURLY          shift and go to state 57


state 38

    (19) locdecls -> LOCAL COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 58


state 39

    (21) decls -> decl . decls
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (99) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 99 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    decl                           shift and go to state 39
    decls                          shift and go to state 59
    type                           shift and go to state 45
    empty                          shift and go to state 47

state 40

    (37) type -> STRING .

    LID             reduce using rule 37 (type -> STRING .)


state 41

    (36) type -> INT .

    LID             reduce using rule 36 (type -> INT .)


state 42

    (38) type -> FLOAT .

    LID             reduce using rule 38 (type -> FLOAT .)


state 43

    (39) type -> IPOS .

    LID             reduce using rule 39 (type -> IPOS .)


state 44

    (40) type -> BOOLEAN .

    LID             reduce using rule 40 (type -> BOOLEAN .)


state 45

    (23) decl -> type . varname ASGN exp NL
    (24) decl -> type . varname NL
    (91) varname -> . LID

    LID             shift and go to state 60

    varname                        shift and go to state 61

state 46

    (15) awdecls -> ALLWRITE COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 62


state 47

    (22) decls -> empty .

    DEDENT          reduce using rule 22 (decls -> empty .)


state 48

    (10) module -> USING MODULE CID COLON NL INDENT . actuatordecls sensordecls DEDENT
    (11) actuatordecls -> . ACTUATORS COLON NL INDENT decls DEDENT
    (12) actuatordecls -> . empty
    (99) empty -> .

    ACTUATORS       shift and go to state 63
    SENSORS         reduce using rule 99 (empty -> .)
    DEDENT          reduce using rule 99 (empty -> .)

    actuatordecls                  shift and go to state 64
    empty                          shift and go to state 65

state 49

    (25) rvdecls -> rvdecl . rvdecls
    (25) rvdecls -> . rvdecl rvdecls
    (26) rvdecls -> . empty
    (27) rvdecl -> . type varname LBRACE owner RBRACE NL
    (99) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 99 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    rvdecl                         shift and go to state 49
    rvdecls                        shift and go to state 66
    type                           shift and go to state 51
    empty                          shift and go to state 52

state 50

    (17) ardecls -> ALLREAD COLON NL INDENT rvdecls . DEDENT

    DEDENT          shift and go to state 67


state 51

    (27) rvdecl -> type . varname LBRACE owner RBRACE NL
    (91) varname -> . LID

    LID             shift and go to state 60

    varname                        shift and go to state 68

state 52

    (26) rvdecls -> empty .

    DEDENT          reduce using rule 26 (rvdecls -> empty .)


state 53

    (41) init -> INIT COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 69


state 54

    (45) event -> LID . COLON NL INDENT PRE COLON cond NL effblock DEDENT

    COLON           shift and go to state 70


state 55

    (43) events -> event . events
    (44) events -> event .
    (43) events -> . event events
    (44) events -> . event
    (45) event -> . LID COLON NL INDENT PRE COLON cond NL effblock DEDENT

    NUM             reduce using rule 44 (events -> event .)
    LID             shift and go to state 54

    event                          shift and go to state 55
    events                         shift and go to state 71

state 56

    (1) program -> agent modules awdecls ardecls locdecls stagedecl init events . Numdecl
    (2) Numdecl -> . NUM INUM NL

    NUM             shift and go to state 73

    Numdecl                        shift and go to state 72

state 57

    (3) stagedecl -> DEF STAGE LCURLY . stagelist RCURLY NL
    (5) stagelist -> . LID COMMA stagelist
    (6) stagelist -> . LID

    LID             shift and go to state 74

    stagelist                      shift and go to state 75

state 58

    (19) locdecls -> LOCAL COLON NL INDENT . decls DEDENT
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (99) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 99 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    decl                           shift and go to state 39
    decls                          shift and go to state 76
    type                           shift and go to state 45
    empty                          shift and go to state 47

state 59

    (21) decls -> decl decls .

    DEDENT          reduce using rule 21 (decls -> decl decls .)


state 60

    (91) varname -> LID .

    LBRACE          reduce using rule 91 (varname -> LID .)
    ASGN            reduce using rule 91 (varname -> LID .)
    NL              reduce using rule 91 (varname -> LID .)
    LPAR            reduce using rule 91 (varname -> LID .)


state 61

    (23) decl -> type varname . ASGN exp NL
    (24) decl -> type varname . NL

    ASGN            shift and go to state 78
    NL              shift and go to state 77


state 62

    (15) awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .

    ALLREAD         reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)
    LOCAL           reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)
    DEF             reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)
    INIT            reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)
    LID             reduce using rule 15 (awdecls -> ALLWRITE COLON NL INDENT decls DEDENT .)


state 63

    (11) actuatordecls -> ACTUATORS . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 79


state 64

    (10) module -> USING MODULE CID COLON NL INDENT actuatordecls . sensordecls DEDENT
    (13) sensordecls -> . SENSORS COLON NL INDENT decls DEDENT
    (14) sensordecls -> . empty
    (99) empty -> .

    SENSORS         shift and go to state 81
    DEDENT          reduce using rule 99 (empty -> .)

    empty                          shift and go to state 82
    sensordecls                    shift and go to state 80

state 65

    (12) actuatordecls -> empty .

    SENSORS         reduce using rule 12 (actuatordecls -> empty .)
    DEDENT          reduce using rule 12 (actuatordecls -> empty .)


state 66

    (25) rvdecls -> rvdecl rvdecls .

    DEDENT          reduce using rule 25 (rvdecls -> rvdecl rvdecls .)


state 67

    (17) ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .

    LOCAL           reduce using rule 17 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)
    DEF             reduce using rule 17 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)
    INIT            reduce using rule 17 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)
    LID             reduce using rule 17 (ardecls -> ALLREAD COLON NL INDENT rvdecls DEDENT .)


state 68

    (27) rvdecl -> type varname . LBRACE owner RBRACE NL

    LBRACE          shift and go to state 83


state 69

    (41) init -> INIT COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 84


state 70

    (45) event -> LID COLON . NL INDENT PRE COLON cond NL effblock DEDENT

    NL              shift and go to state 85


state 71

    (43) events -> event events .

    NUM             reduce using rule 43 (events -> event events .)


state 72

    (1) program -> agent modules awdecls ardecls locdecls stagedecl init events Numdecl .

    $end            reduce using rule 1 (program -> agent modules awdecls ardecls locdecls stagedecl init events Numdecl .)


state 73

    (2) Numdecl -> NUM . INUM NL

    INUM            shift and go to state 86


state 74

    (5) stagelist -> LID . COMMA stagelist
    (6) stagelist -> LID .

    COMMA           shift and go to state 87
    RCURLY          reduce using rule 6 (stagelist -> LID .)


state 75

    (3) stagedecl -> DEF STAGE LCURLY stagelist . RCURLY NL

    RCURLY          shift and go to state 88


state 76

    (19) locdecls -> LOCAL COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 89


state 77

    (24) decl -> type varname NL .

    INT             reduce using rule 24 (decl -> type varname NL .)
    STRING          reduce using rule 24 (decl -> type varname NL .)
    FLOAT           reduce using rule 24 (decl -> type varname NL .)
    IPOS            reduce using rule 24 (decl -> type varname NL .)
    BOOLEAN         reduce using rule 24 (decl -> type varname NL .)
    DEDENT          reduce using rule 24 (decl -> type varname NL .)


state 78

    (23) decl -> type varname ASGN . exp NL
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 101
    LID             shift and go to state 90
    LPAR            shift and go to state 91
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 107
    bval                           shift and go to state 97

state 79

    (11) actuatordecls -> ACTUATORS COLON . NL INDENT decls DEDENT

    NL              shift and go to state 109


state 80

    (10) module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls . DEDENT

    DEDENT          shift and go to state 110


state 81

    (13) sensordecls -> SENSORS . COLON NL INDENT decls DEDENT

    COLON           shift and go to state 111


state 82

    (14) sensordecls -> empty .

    DEDENT          reduce using rule 14 (sensordecls -> empty .)


state 83

    (27) rvdecl -> type varname LBRACE . owner RBRACE NL
    (28) owner -> . TIMES
    (29) owner -> . INUM

    TIMES           shift and go to state 112
    INUM            shift and go to state 113

    owner                          shift and go to state 114

state 84

    (41) init -> INIT COLON NL INDENT . stmts DEDENT
    (53) stmts -> . stmt stmts
    (54) stmts -> . stmt
    (55) stmt -> . asgn
    (56) stmt -> . wptstmt
    (57) stmt -> . exit
    (58) stmt -> . funccall NL
    (59) stmt -> . modulefunccall NL
    (60) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (61) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (66) asgn -> . varname ASGN exp NL
    (67) asgn -> . stagechange
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (62) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (69) stagechange -> . STAGE ASGN varname NL

    ATOMIC          shift and go to state 115
    IF              shift and go to state 123
    EXIT            shift and go to state 127
    CID             shift and go to state 93
    LID             shift and go to state 60
    STAGE           shift and go to state 119

    stagechange                    shift and go to state 124
    funccall                       shift and go to state 120
    stmts                          shift and go to state 116
    varname                        shift and go to state 125
    stmt                           shift and go to state 122
    asgn                           shift and go to state 117
    modulefunccall                 shift and go to state 121
    wptstmt                        shift and go to state 126
    exit                           shift and go to state 118

state 85

    (45) event -> LID COLON NL . INDENT PRE COLON cond NL effblock DEDENT

    INDENT          shift and go to state 128


state 86

    (2) Numdecl -> NUM INUM . NL

    NL              shift and go to state 129


state 87

    (5) stagelist -> LID COMMA . stagelist
    (5) stagelist -> . LID COMMA stagelist
    (6) stagelist -> . LID

    LID             shift and go to state 74

    stagelist                      shift and go to state 130

state 88

    (3) stagedecl -> DEF STAGE LCURLY stagelist RCURLY . NL

    NL              shift and go to state 131


state 89

    (19) locdecls -> LOCAL COLON NL INDENT decls DEDENT .

    DEF             reduce using rule 19 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)
    INIT            reduce using rule 19 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)
    LID             reduce using rule 19 (locdecls -> LOCAL COLON NL INDENT decls DEDENT .)


state 90

    (80) exp -> LID . LBRACE exp RBRACE
    (91) varname -> LID .

    LBRACE          shift and go to state 132
    LPAR            reduce using rule 91 (varname -> LID .)
    PLUS            reduce using rule 91 (varname -> LID .)
    TIMES           reduce using rule 91 (varname -> LID .)
    MINUS           reduce using rule 91 (varname -> LID .)
    BY              reduce using rule 91 (varname -> LID .)
    NL              reduce using rule 91 (varname -> LID .)
    RPAR            reduce using rule 91 (varname -> LID .)
    COLON           reduce using rule 91 (varname -> LID .)
    RBRACE          reduce using rule 91 (varname -> LID .)
    COMMA           reduce using rule 91 (varname -> LID .)
    AND             reduce using rule 91 (varname -> LID .)
    OR              reduce using rule 91 (varname -> LID .)
    EQ              reduce using rule 91 (varname -> LID .)
    NEQ             reduce using rule 91 (varname -> LID .)
    GEQ             reduce using rule 91 (varname -> LID .)
    LEQ             reduce using rule 91 (varname -> LID .)
    GT              reduce using rule 91 (varname -> LID .)
    LT              reduce using rule 91 (varname -> LID .)


state 91

    (85) bracketexp -> LPAR . exp RPAR
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 101
    LID             shift and go to state 90
    LPAR            shift and go to state 91
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 133
    bval                           shift and go to state 97

state 92

    (71) exp -> bracketexp .

    COMMA           reduce using rule 71 (exp -> bracketexp .)
    PLUS            reduce using rule 71 (exp -> bracketexp .)
    TIMES           reduce using rule 71 (exp -> bracketexp .)
    MINUS           reduce using rule 71 (exp -> bracketexp .)
    BY              reduce using rule 71 (exp -> bracketexp .)
    RPAR            reduce using rule 71 (exp -> bracketexp .)
    NL              reduce using rule 71 (exp -> bracketexp .)
    COLON           reduce using rule 71 (exp -> bracketexp .)
    RBRACE          reduce using rule 71 (exp -> bracketexp .)
    AND             reduce using rule 71 (exp -> bracketexp .)
    OR              reduce using rule 71 (exp -> bracketexp .)
    EQ              reduce using rule 71 (exp -> bracketexp .)
    NEQ             reduce using rule 71 (exp -> bracketexp .)
    GEQ             reduce using rule 71 (exp -> bracketexp .)
    LEQ             reduce using rule 71 (exp -> bracketexp .)
    GT              reduce using rule 71 (exp -> bracketexp .)
    LT              reduce using rule 71 (exp -> bracketexp .)


state 93

    (63) modulefunccall -> CID . LPAR args RPAR

    LPAR            shift and go to state 134


state 94

    (89) num -> FNUM .

    NL              reduce using rule 89 (num -> FNUM .)
    PLUS            reduce using rule 89 (num -> FNUM .)
    TIMES           reduce using rule 89 (num -> FNUM .)
    MINUS           reduce using rule 89 (num -> FNUM .)
    BY              reduce using rule 89 (num -> FNUM .)
    RPAR            reduce using rule 89 (num -> FNUM .)
    AND             reduce using rule 89 (num -> FNUM .)
    OR              reduce using rule 89 (num -> FNUM .)
    EQ              reduce using rule 89 (num -> FNUM .)
    NEQ             reduce using rule 89 (num -> FNUM .)
    GEQ             reduce using rule 89 (num -> FNUM .)
    LEQ             reduce using rule 89 (num -> FNUM .)
    GT              reduce using rule 89 (num -> FNUM .)
    LT              reduce using rule 89 (num -> FNUM .)
    COLON           reduce using rule 89 (num -> FNUM .)
    RBRACE          reduce using rule 89 (num -> FNUM .)
    COMMA           reduce using rule 89 (num -> FNUM .)


state 95

    (79) exp -> pid .

    COMMA           reduce using rule 79 (exp -> pid .)
    PLUS            reduce using rule 79 (exp -> pid .)
    TIMES           reduce using rule 79 (exp -> pid .)
    MINUS           reduce using rule 79 (exp -> pid .)
    BY              reduce using rule 79 (exp -> pid .)
    RPAR            reduce using rule 79 (exp -> pid .)
    NL              reduce using rule 79 (exp -> pid .)
    COLON           reduce using rule 79 (exp -> pid .)
    RBRACE          reduce using rule 79 (exp -> pid .)
    AND             reduce using rule 79 (exp -> pid .)
    OR              reduce using rule 79 (exp -> pid .)
    EQ              reduce using rule 79 (exp -> pid .)
    NEQ             reduce using rule 79 (exp -> pid .)
    GEQ             reduce using rule 79 (exp -> pid .)
    LEQ             reduce using rule 79 (exp -> pid .)
    GT              reduce using rule 79 (exp -> pid .)
    LT              reduce using rule 79 (exp -> pid .)


state 96

    (81) exp -> num .

    COMMA           reduce using rule 81 (exp -> num .)
    PLUS            reduce using rule 81 (exp -> num .)
    TIMES           reduce using rule 81 (exp -> num .)
    MINUS           reduce using rule 81 (exp -> num .)
    BY              reduce using rule 81 (exp -> num .)
    RPAR            reduce using rule 81 (exp -> num .)
    NL              reduce using rule 81 (exp -> num .)
    COLON           reduce using rule 81 (exp -> num .)
    RBRACE          reduce using rule 81 (exp -> num .)
    AND             reduce using rule 81 (exp -> num .)
    OR              reduce using rule 81 (exp -> num .)
    EQ              reduce using rule 81 (exp -> num .)
    NEQ             reduce using rule 81 (exp -> num .)
    GEQ             reduce using rule 81 (exp -> num .)
    LEQ             reduce using rule 81 (exp -> num .)
    GT              reduce using rule 81 (exp -> num .)
    LT              reduce using rule 81 (exp -> num .)


state 97

    (78) exp -> bval .

    COMMA           reduce using rule 78 (exp -> bval .)
    PLUS            reduce using rule 78 (exp -> bval .)
    TIMES           reduce using rule 78 (exp -> bval .)
    MINUS           reduce using rule 78 (exp -> bval .)
    BY              reduce using rule 78 (exp -> bval .)
    RPAR            reduce using rule 78 (exp -> bval .)
    NL              reduce using rule 78 (exp -> bval .)
    COLON           reduce using rule 78 (exp -> bval .)
    RBRACE          reduce using rule 78 (exp -> bval .)
    AND             reduce using rule 78 (exp -> bval .)
    OR              reduce using rule 78 (exp -> bval .)
    EQ              reduce using rule 78 (exp -> bval .)
    NEQ             reduce using rule 78 (exp -> bval .)
    GEQ             reduce using rule 78 (exp -> bval .)
    LEQ             reduce using rule 78 (exp -> bval .)
    GT              reduce using rule 78 (exp -> bval .)
    LT              reduce using rule 78 (exp -> bval .)


state 98

    (82) exp -> null .

    COMMA           reduce using rule 82 (exp -> null .)
    PLUS            reduce using rule 82 (exp -> null .)
    TIMES           reduce using rule 82 (exp -> null .)
    MINUS           reduce using rule 82 (exp -> null .)
    BY              reduce using rule 82 (exp -> null .)
    RPAR            reduce using rule 82 (exp -> null .)
    NL              reduce using rule 82 (exp -> null .)
    COLON           reduce using rule 82 (exp -> null .)
    RBRACE          reduce using rule 82 (exp -> null .)
    AND             reduce using rule 82 (exp -> null .)
    OR              reduce using rule 82 (exp -> null .)
    EQ              reduce using rule 82 (exp -> null .)
    NEQ             reduce using rule 82 (exp -> null .)
    GEQ             reduce using rule 82 (exp -> null .)
    LEQ             reduce using rule 82 (exp -> null .)
    GT              reduce using rule 82 (exp -> null .)
    LT              reduce using rule 82 (exp -> null .)


state 99

    (86) bval -> TRUE .

    PLUS            reduce using rule 86 (bval -> TRUE .)
    TIMES           reduce using rule 86 (bval -> TRUE .)
    MINUS           reduce using rule 86 (bval -> TRUE .)
    BY              reduce using rule 86 (bval -> TRUE .)
    NL              reduce using rule 86 (bval -> TRUE .)
    RPAR            reduce using rule 86 (bval -> TRUE .)
    COLON           reduce using rule 86 (bval -> TRUE .)
    RBRACE          reduce using rule 86 (bval -> TRUE .)
    COMMA           reduce using rule 86 (bval -> TRUE .)
    AND             reduce using rule 86 (bval -> TRUE .)
    OR              reduce using rule 86 (bval -> TRUE .)
    EQ              reduce using rule 86 (bval -> TRUE .)
    NEQ             reduce using rule 86 (bval -> TRUE .)
    GEQ             reduce using rule 86 (bval -> TRUE .)
    LEQ             reduce using rule 86 (bval -> TRUE .)
    GT              reduce using rule 86 (bval -> TRUE .)
    LT              reduce using rule 86 (bval -> TRUE .)


state 100

    (90) pid -> PID .

    COMMA           reduce using rule 90 (pid -> PID .)
    PLUS            reduce using rule 90 (pid -> PID .)
    TIMES           reduce using rule 90 (pid -> PID .)
    MINUS           reduce using rule 90 (pid -> PID .)
    BY              reduce using rule 90 (pid -> PID .)
    RPAR            reduce using rule 90 (pid -> PID .)
    NL              reduce using rule 90 (pid -> PID .)
    COLON           reduce using rule 90 (pid -> PID .)
    RBRACE          reduce using rule 90 (pid -> PID .)
    AND             reduce using rule 90 (pid -> PID .)
    OR              reduce using rule 90 (pid -> PID .)
    EQ              reduce using rule 90 (pid -> PID .)
    NEQ             reduce using rule 90 (pid -> PID .)
    GEQ             reduce using rule 90 (pid -> PID .)
    LEQ             reduce using rule 90 (pid -> PID .)
    GT              reduce using rule 90 (pid -> PID .)
    LT              reduce using rule 90 (pid -> PID .)


state 101

    (77) exp -> STAGE .

    COMMA           reduce using rule 77 (exp -> STAGE .)
    PLUS            reduce using rule 77 (exp -> STAGE .)
    TIMES           reduce using rule 77 (exp -> STAGE .)
    MINUS           reduce using rule 77 (exp -> STAGE .)
    BY              reduce using rule 77 (exp -> STAGE .)
    RPAR            reduce using rule 77 (exp -> STAGE .)
    NL              reduce using rule 77 (exp -> STAGE .)
    COLON           reduce using rule 77 (exp -> STAGE .)
    RBRACE          reduce using rule 77 (exp -> STAGE .)
    AND             reduce using rule 77 (exp -> STAGE .)
    OR              reduce using rule 77 (exp -> STAGE .)
    EQ              reduce using rule 77 (exp -> STAGE .)
    NEQ             reduce using rule 77 (exp -> STAGE .)
    GEQ             reduce using rule 77 (exp -> STAGE .)
    LEQ             reduce using rule 77 (exp -> STAGE .)
    GT              reduce using rule 77 (exp -> STAGE .)
    LT              reduce using rule 77 (exp -> STAGE .)


state 102

    (83) exp -> funccall .

    COMMA           reduce using rule 83 (exp -> funccall .)
    PLUS            reduce using rule 83 (exp -> funccall .)
    TIMES           reduce using rule 83 (exp -> funccall .)
    MINUS           reduce using rule 83 (exp -> funccall .)
    BY              reduce using rule 83 (exp -> funccall .)
    RPAR            reduce using rule 83 (exp -> funccall .)
    NL              reduce using rule 83 (exp -> funccall .)
    COLON           reduce using rule 83 (exp -> funccall .)
    RBRACE          reduce using rule 83 (exp -> funccall .)
    AND             reduce using rule 83 (exp -> funccall .)
    OR              reduce using rule 83 (exp -> funccall .)
    EQ              reduce using rule 83 (exp -> funccall .)
    NEQ             reduce using rule 83 (exp -> funccall .)
    GEQ             reduce using rule 83 (exp -> funccall .)
    LEQ             reduce using rule 83 (exp -> funccall .)
    GT              reduce using rule 83 (exp -> funccall .)
    LT              reduce using rule 83 (exp -> funccall .)


state 103

    (84) exp -> modulefunccall .

    COMMA           reduce using rule 84 (exp -> modulefunccall .)
    PLUS            reduce using rule 84 (exp -> modulefunccall .)
    TIMES           reduce using rule 84 (exp -> modulefunccall .)
    MINUS           reduce using rule 84 (exp -> modulefunccall .)
    BY              reduce using rule 84 (exp -> modulefunccall .)
    RPAR            reduce using rule 84 (exp -> modulefunccall .)
    NL              reduce using rule 84 (exp -> modulefunccall .)
    COLON           reduce using rule 84 (exp -> modulefunccall .)
    RBRACE          reduce using rule 84 (exp -> modulefunccall .)
    AND             reduce using rule 84 (exp -> modulefunccall .)
    OR              reduce using rule 84 (exp -> modulefunccall .)
    EQ              reduce using rule 84 (exp -> modulefunccall .)
    NEQ             reduce using rule 84 (exp -> modulefunccall .)
    GEQ             reduce using rule 84 (exp -> modulefunccall .)
    LEQ             reduce using rule 84 (exp -> modulefunccall .)
    GT              reduce using rule 84 (exp -> modulefunccall .)
    LT              reduce using rule 84 (exp -> modulefunccall .)


state 104

    (92) null -> NULL .

    RPAR            reduce using rule 92 (null -> NULL .)
    PLUS            reduce using rule 92 (null -> NULL .)
    TIMES           reduce using rule 92 (null -> NULL .)
    MINUS           reduce using rule 92 (null -> NULL .)
    BY              reduce using rule 92 (null -> NULL .)
    COLON           reduce using rule 92 (null -> NULL .)
    COMMA           reduce using rule 92 (null -> NULL .)
    NL              reduce using rule 92 (null -> NULL .)
    RBRACE          reduce using rule 92 (null -> NULL .)
    AND             reduce using rule 92 (null -> NULL .)
    OR              reduce using rule 92 (null -> NULL .)
    EQ              reduce using rule 92 (null -> NULL .)
    NEQ             reduce using rule 92 (null -> NULL .)
    GEQ             reduce using rule 92 (null -> NULL .)
    LEQ             reduce using rule 92 (null -> NULL .)
    GT              reduce using rule 92 (null -> NULL .)
    LT              reduce using rule 92 (null -> NULL .)


state 105

    (87) bval -> FALSE .

    PLUS            reduce using rule 87 (bval -> FALSE .)
    TIMES           reduce using rule 87 (bval -> FALSE .)
    MINUS           reduce using rule 87 (bval -> FALSE .)
    BY              reduce using rule 87 (bval -> FALSE .)
    NL              reduce using rule 87 (bval -> FALSE .)
    RPAR            reduce using rule 87 (bval -> FALSE .)
    COLON           reduce using rule 87 (bval -> FALSE .)
    RBRACE          reduce using rule 87 (bval -> FALSE .)
    COMMA           reduce using rule 87 (bval -> FALSE .)
    AND             reduce using rule 87 (bval -> FALSE .)
    OR              reduce using rule 87 (bval -> FALSE .)
    EQ              reduce using rule 87 (bval -> FALSE .)
    NEQ             reduce using rule 87 (bval -> FALSE .)
    GEQ             reduce using rule 87 (bval -> FALSE .)
    LEQ             reduce using rule 87 (bval -> FALSE .)
    GT              reduce using rule 87 (bval -> FALSE .)
    LT              reduce using rule 87 (bval -> FALSE .)


state 106

    (76) exp -> varname .
    (30) funccall -> varname . LPAR args RPAR

    COMMA           reduce using rule 76 (exp -> varname .)
    PLUS            reduce using rule 76 (exp -> varname .)
    TIMES           reduce using rule 76 (exp -> varname .)
    MINUS           reduce using rule 76 (exp -> varname .)
    BY              reduce using rule 76 (exp -> varname .)
    RPAR            reduce using rule 76 (exp -> varname .)
    NL              reduce using rule 76 (exp -> varname .)
    COLON           reduce using rule 76 (exp -> varname .)
    RBRACE          reduce using rule 76 (exp -> varname .)
    AND             reduce using rule 76 (exp -> varname .)
    OR              reduce using rule 76 (exp -> varname .)
    EQ              reduce using rule 76 (exp -> varname .)
    NEQ             reduce using rule 76 (exp -> varname .)
    GEQ             reduce using rule 76 (exp -> varname .)
    LEQ             reduce using rule 76 (exp -> varname .)
    GT              reduce using rule 76 (exp -> varname .)
    LT              reduce using rule 76 (exp -> varname .)
    LPAR            shift and go to state 135


state 107

    (23) decl -> type varname ASGN exp . NL
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    NL              shift and go to state 136
    PLUS            shift and go to state 138
    TIMES           shift and go to state 139
    MINUS           shift and go to state 140
    BY              shift and go to state 137


state 108

    (88) num -> INUM .

    NL              reduce using rule 88 (num -> INUM .)
    PLUS            reduce using rule 88 (num -> INUM .)
    TIMES           reduce using rule 88 (num -> INUM .)
    MINUS           reduce using rule 88 (num -> INUM .)
    BY              reduce using rule 88 (num -> INUM .)
    RPAR            reduce using rule 88 (num -> INUM .)
    AND             reduce using rule 88 (num -> INUM .)
    OR              reduce using rule 88 (num -> INUM .)
    EQ              reduce using rule 88 (num -> INUM .)
    NEQ             reduce using rule 88 (num -> INUM .)
    GEQ             reduce using rule 88 (num -> INUM .)
    LEQ             reduce using rule 88 (num -> INUM .)
    GT              reduce using rule 88 (num -> INUM .)
    LT              reduce using rule 88 (num -> INUM .)
    COLON           reduce using rule 88 (num -> INUM .)
    RBRACE          reduce using rule 88 (num -> INUM .)
    COMMA           reduce using rule 88 (num -> INUM .)


state 109

    (11) actuatordecls -> ACTUATORS COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 141


state 110

    (10) module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .

    USING           reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    ALLWRITE        reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    ALLREAD         reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    LOCAL           reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    DEF             reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    INIT            reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)
    LID             reduce using rule 10 (module -> USING MODULE CID COLON NL INDENT actuatordecls sensordecls DEDENT .)


state 111

    (13) sensordecls -> SENSORS COLON . NL INDENT decls DEDENT

    NL              shift and go to state 142


state 112

    (28) owner -> TIMES .

    RBRACE          reduce using rule 28 (owner -> TIMES .)


state 113

    (29) owner -> INUM .

    RBRACE          reduce using rule 29 (owner -> INUM .)


state 114

    (27) rvdecl -> type varname LBRACE owner . RBRACE NL

    RBRACE          shift and go to state 143


state 115

    (60) stmt -> ATOMIC . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 144


state 116

    (41) init -> INIT COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 145


state 117

    (55) stmt -> asgn .

    DEDENT          reduce using rule 55 (stmt -> asgn .)
    ATOMIC          reduce using rule 55 (stmt -> asgn .)
    IF              reduce using rule 55 (stmt -> asgn .)
    EXIT            reduce using rule 55 (stmt -> asgn .)
    CID             reduce using rule 55 (stmt -> asgn .)
    LID             reduce using rule 55 (stmt -> asgn .)
    STAGE           reduce using rule 55 (stmt -> asgn .)


state 118

    (57) stmt -> exit .

    DEDENT          reduce using rule 57 (stmt -> exit .)
    ATOMIC          reduce using rule 57 (stmt -> exit .)
    IF              reduce using rule 57 (stmt -> exit .)
    EXIT            reduce using rule 57 (stmt -> exit .)
    CID             reduce using rule 57 (stmt -> exit .)
    LID             reduce using rule 57 (stmt -> exit .)
    STAGE           reduce using rule 57 (stmt -> exit .)


state 119

    (69) stagechange -> STAGE . ASGN varname NL

    ASGN            shift and go to state 146


state 120

    (58) stmt -> funccall . NL

    NL              shift and go to state 147


state 121

    (59) stmt -> modulefunccall . NL

    NL              shift and go to state 148


state 122

    (53) stmts -> stmt . stmts
    (54) stmts -> stmt .
    (53) stmts -> . stmt stmts
    (54) stmts -> . stmt
    (55) stmt -> . asgn
    (56) stmt -> . wptstmt
    (57) stmt -> . exit
    (58) stmt -> . funccall NL
    (59) stmt -> . modulefunccall NL
    (60) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (61) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (66) asgn -> . varname ASGN exp NL
    (67) asgn -> . stagechange
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (62) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (69) stagechange -> . STAGE ASGN varname NL

    DEDENT          reduce using rule 54 (stmts -> stmt .)
    ATOMIC          shift and go to state 115
    IF              shift and go to state 123
    EXIT            shift and go to state 127
    CID             shift and go to state 93
    LID             shift and go to state 60
    STAGE           shift and go to state 119

    stagechange                    shift and go to state 124
    funccall                       shift and go to state 120
    stmts                          shift and go to state 149
    varname                        shift and go to state 125
    stmt                           shift and go to state 122
    asgn                           shift and go to state 117
    modulefunccall                 shift and go to state 121
    wptstmt                        shift and go to state 126
    exit                           shift and go to state 118

state 123

    (61) stmt -> IF . cond COLON NL INDENT stmts DEDENT elseblock
    (48) cond -> . LPAR cond AND cond RPAR
    (49) cond -> . LPAR cond OR cond RPAR
    (50) cond -> . LPAR cond op cond RPAR
    (51) cond -> . LPAR NOT cond RPAR
    (52) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 150
    STAGE           shift and go to state 101
    LID             shift and go to state 90
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    modulefunccall                 shift and go to state 103
    null                           shift and go to state 98
    num                            shift and go to state 96
    cond                           shift and go to state 151
    exp                            shift and go to state 152
    bval                           shift and go to state 97

state 124

    (67) asgn -> stagechange .

    DEDENT          reduce using rule 67 (asgn -> stagechange .)
    ATOMIC          reduce using rule 67 (asgn -> stagechange .)
    IF              reduce using rule 67 (asgn -> stagechange .)
    EXIT            reduce using rule 67 (asgn -> stagechange .)
    CID             reduce using rule 67 (asgn -> stagechange .)
    LID             reduce using rule 67 (asgn -> stagechange .)
    STAGE           reduce using rule 67 (asgn -> stagechange .)


state 125

    (66) asgn -> varname . ASGN exp NL
    (70) wptstmt -> varname . ASGN GETINPUT LPAR RPAR NL
    (30) funccall -> varname . LPAR args RPAR

    ASGN            shift and go to state 153
    LPAR            shift and go to state 135


state 126

    (56) stmt -> wptstmt .

    DEDENT          reduce using rule 56 (stmt -> wptstmt .)
    ATOMIC          reduce using rule 56 (stmt -> wptstmt .)
    IF              reduce using rule 56 (stmt -> wptstmt .)
    EXIT            reduce using rule 56 (stmt -> wptstmt .)
    CID             reduce using rule 56 (stmt -> wptstmt .)
    LID             reduce using rule 56 (stmt -> wptstmt .)
    STAGE           reduce using rule 56 (stmt -> wptstmt .)


state 127

    (62) exit -> EXIT . NL

    NL              shift and go to state 154


state 128

    (45) event -> LID COLON NL INDENT . PRE COLON cond NL effblock DEDENT

    PRE             shift and go to state 155


state 129

    (2) Numdecl -> NUM INUM NL .

    $end            reduce using rule 2 (Numdecl -> NUM INUM NL .)


state 130

    (5) stagelist -> LID COMMA stagelist .

    RCURLY          reduce using rule 5 (stagelist -> LID COMMA stagelist .)


state 131

    (3) stagedecl -> DEF STAGE LCURLY stagelist RCURLY NL .

    INIT            reduce using rule 3 (stagedecl -> DEF STAGE LCURLY stagelist RCURLY NL .)
    LID             reduce using rule 3 (stagedecl -> DEF STAGE LCURLY stagelist RCURLY NL .)


state 132

    (80) exp -> LID LBRACE . exp RBRACE
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 101
    LID             shift and go to state 90
    LPAR            shift and go to state 91
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 156
    bval                           shift and go to state 97

state 133

    (85) bracketexp -> LPAR exp . RPAR
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    RPAR            shift and go to state 157
    PLUS            shift and go to state 138
    TIMES           shift and go to state 139
    MINUS           shift and go to state 140
    BY              shift and go to state 137


state 134

    (63) modulefunccall -> CID LPAR . args RPAR
    (31) args -> . neargs
    (32) args -> . noargs
    (34) neargs -> . exp
    (35) neargs -> . exp COMMA neargs
    (33) noargs -> . empty
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (99) empty -> .
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 101
    LID             shift and go to state 90
    RPAR            reduce using rule 99 (empty -> .)
    LPAR            shift and go to state 91
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    args                           shift and go to state 161
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 162
    noargs                         shift and go to state 158
    neargs                         shift and go to state 159
    bval                           shift and go to state 97
    empty                          shift and go to state 160

state 135

    (30) funccall -> varname LPAR . args RPAR
    (31) args -> . neargs
    (32) args -> . noargs
    (34) neargs -> . exp
    (35) neargs -> . exp COMMA neargs
    (33) noargs -> . empty
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (99) empty -> .
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 101
    LID             shift and go to state 90
    RPAR            reduce using rule 99 (empty -> .)
    LPAR            shift and go to state 91
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    args                           shift and go to state 163
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 162
    noargs                         shift and go to state 158
    neargs                         shift and go to state 159
    bval                           shift and go to state 97
    empty                          shift and go to state 160

state 136

    (23) decl -> type varname ASGN exp NL .

    INT             reduce using rule 23 (decl -> type varname ASGN exp NL .)
    STRING          reduce using rule 23 (decl -> type varname ASGN exp NL .)
    FLOAT           reduce using rule 23 (decl -> type varname ASGN exp NL .)
    IPOS            reduce using rule 23 (decl -> type varname ASGN exp NL .)
    BOOLEAN         reduce using rule 23 (decl -> type varname ASGN exp NL .)
    DEDENT          reduce using rule 23 (decl -> type varname ASGN exp NL .)


state 137

    (75) exp -> exp BY . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 101
    LID             shift and go to state 90
    LPAR            shift and go to state 91
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 164
    bval                           shift and go to state 97

state 138

    (72) exp -> exp PLUS . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 101
    LID             shift and go to state 90
    LPAR            shift and go to state 91
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 165
    bval                           shift and go to state 97

state 139

    (73) exp -> exp TIMES . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 101
    LID             shift and go to state 90
    LPAR            shift and go to state 91
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 166
    bval                           shift and go to state 97

state 140

    (74) exp -> exp MINUS . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 101
    LID             shift and go to state 90
    LPAR            shift and go to state 91
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 167
    bval                           shift and go to state 97

state 141

    (11) actuatordecls -> ACTUATORS COLON NL INDENT . decls DEDENT
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (99) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 99 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    decl                           shift and go to state 39
    decls                          shift and go to state 168
    type                           shift and go to state 45
    empty                          shift and go to state 47

state 142

    (13) sensordecls -> SENSORS COLON NL . INDENT decls DEDENT

    INDENT          shift and go to state 169


state 143

    (27) rvdecl -> type varname LBRACE owner RBRACE . NL

    NL              shift and go to state 170


state 144

    (60) stmt -> ATOMIC COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 171


state 145

    (41) init -> INIT COLON NL INDENT stmts DEDENT .

    LID             reduce using rule 41 (init -> INIT COLON NL INDENT stmts DEDENT .)


state 146

    (69) stagechange -> STAGE ASGN . varname NL
    (91) varname -> . LID

    LID             shift and go to state 60

    varname                        shift and go to state 172

state 147

    (58) stmt -> funccall NL .

    DEDENT          reduce using rule 58 (stmt -> funccall NL .)
    ATOMIC          reduce using rule 58 (stmt -> funccall NL .)
    IF              reduce using rule 58 (stmt -> funccall NL .)
    EXIT            reduce using rule 58 (stmt -> funccall NL .)
    CID             reduce using rule 58 (stmt -> funccall NL .)
    LID             reduce using rule 58 (stmt -> funccall NL .)
    STAGE           reduce using rule 58 (stmt -> funccall NL .)


state 148

    (59) stmt -> modulefunccall NL .

    DEDENT          reduce using rule 59 (stmt -> modulefunccall NL .)
    ATOMIC          reduce using rule 59 (stmt -> modulefunccall NL .)
    IF              reduce using rule 59 (stmt -> modulefunccall NL .)
    EXIT            reduce using rule 59 (stmt -> modulefunccall NL .)
    CID             reduce using rule 59 (stmt -> modulefunccall NL .)
    LID             reduce using rule 59 (stmt -> modulefunccall NL .)
    STAGE           reduce using rule 59 (stmt -> modulefunccall NL .)


state 149

    (53) stmts -> stmt stmts .

    DEDENT          reduce using rule 53 (stmts -> stmt stmts .)


state 150

    (48) cond -> LPAR . cond AND cond RPAR
    (49) cond -> LPAR . cond OR cond RPAR
    (50) cond -> LPAR . cond op cond RPAR
    (51) cond -> LPAR . NOT cond RPAR
    (85) bracketexp -> LPAR . exp RPAR
    (48) cond -> . LPAR cond AND cond RPAR
    (49) cond -> . LPAR cond OR cond RPAR
    (50) cond -> . LPAR cond op cond RPAR
    (51) cond -> . LPAR NOT cond RPAR
    (52) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    NOT             shift and go to state 175
    LPAR            shift and go to state 150
    STAGE           shift and go to state 101
    LID             shift and go to state 90
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    cond                           shift and go to state 173
    exp                            shift and go to state 174
    bval                           shift and go to state 97

state 151

    (61) stmt -> IF cond . COLON NL INDENT stmts DEDENT elseblock

    COLON           shift and go to state 176


state 152

    (52) cond -> exp .
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    RPAR            reduce using rule 52 (cond -> exp .)
    COLON           reduce using rule 52 (cond -> exp .)
    NL              reduce using rule 52 (cond -> exp .)
    PLUS            shift and go to state 138
    TIMES           shift and go to state 139
    MINUS           shift and go to state 140
    BY              shift and go to state 137


state 153

    (66) asgn -> varname ASGN . exp NL
    (70) wptstmt -> varname ASGN . GETINPUT LPAR RPAR NL
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    GETINPUT        shift and go to state 178
    STAGE           shift and go to state 101
    LID             shift and go to state 90
    LPAR            shift and go to state 91
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 177
    bval                           shift and go to state 97

state 154

    (62) exit -> EXIT NL .

    ATOMIC          reduce using rule 62 (exit -> EXIT NL .)
    IF              reduce using rule 62 (exit -> EXIT NL .)
    EXIT            reduce using rule 62 (exit -> EXIT NL .)
    CID             reduce using rule 62 (exit -> EXIT NL .)
    LID             reduce using rule 62 (exit -> EXIT NL .)
    STAGE           reduce using rule 62 (exit -> EXIT NL .)
    DEDENT          reduce using rule 62 (exit -> EXIT NL .)


state 155

    (45) event -> LID COLON NL INDENT PRE . COLON cond NL effblock DEDENT

    COLON           shift and go to state 179


state 156

    (80) exp -> LID LBRACE exp . RBRACE
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    RBRACE          shift and go to state 180
    PLUS            shift and go to state 138
    TIMES           shift and go to state 139
    MINUS           shift and go to state 140
    BY              shift and go to state 137


state 157

    (85) bracketexp -> LPAR exp RPAR .

    PLUS            reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    TIMES           reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    MINUS           reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    BY              reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    RPAR            reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    NL              reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    COLON           reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    RBRACE          reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    COMMA           reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    AND             reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    OR              reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    EQ              reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    NEQ             reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    GEQ             reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    LEQ             reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    GT              reduce using rule 85 (bracketexp -> LPAR exp RPAR .)
    LT              reduce using rule 85 (bracketexp -> LPAR exp RPAR .)


state 158

    (32) args -> noargs .

    RPAR            reduce using rule 32 (args -> noargs .)


state 159

    (31) args -> neargs .

    RPAR            reduce using rule 31 (args -> neargs .)


state 160

    (33) noargs -> empty .

    RPAR            reduce using rule 33 (noargs -> empty .)


state 161

    (63) modulefunccall -> CID LPAR args . RPAR

    RPAR            shift and go to state 181


state 162

    (34) neargs -> exp .
    (35) neargs -> exp . COMMA neargs
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    RPAR            reduce using rule 34 (neargs -> exp .)
    COMMA           shift and go to state 182
    PLUS            shift and go to state 138
    TIMES           shift and go to state 139
    MINUS           shift and go to state 140
    BY              shift and go to state 137


state 163

    (30) funccall -> varname LPAR args . RPAR

    RPAR            shift and go to state 183


state 164

    (75) exp -> exp BY exp .
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    COMMA           reduce using rule 75 (exp -> exp BY exp .)
    PLUS            reduce using rule 75 (exp -> exp BY exp .)
    TIMES           reduce using rule 75 (exp -> exp BY exp .)
    MINUS           reduce using rule 75 (exp -> exp BY exp .)
    BY              reduce using rule 75 (exp -> exp BY exp .)
    RPAR            reduce using rule 75 (exp -> exp BY exp .)
    NL              reduce using rule 75 (exp -> exp BY exp .)
    COLON           reduce using rule 75 (exp -> exp BY exp .)
    RBRACE          reduce using rule 75 (exp -> exp BY exp .)
    AND             reduce using rule 75 (exp -> exp BY exp .)
    OR              reduce using rule 75 (exp -> exp BY exp .)
    EQ              reduce using rule 75 (exp -> exp BY exp .)
    NEQ             reduce using rule 75 (exp -> exp BY exp .)
    GEQ             reduce using rule 75 (exp -> exp BY exp .)
    LEQ             reduce using rule 75 (exp -> exp BY exp .)
    GT              reduce using rule 75 (exp -> exp BY exp .)
    LT              reduce using rule 75 (exp -> exp BY exp .)

  ! PLUS            [ shift and go to state 138 ]
  ! TIMES           [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! BY              [ shift and go to state 137 ]


state 165

    (72) exp -> exp PLUS exp .
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    COMMA           reduce using rule 72 (exp -> exp PLUS exp .)
    PLUS            reduce using rule 72 (exp -> exp PLUS exp .)
    MINUS           reduce using rule 72 (exp -> exp PLUS exp .)
    RPAR            reduce using rule 72 (exp -> exp PLUS exp .)
    NL              reduce using rule 72 (exp -> exp PLUS exp .)
    COLON           reduce using rule 72 (exp -> exp PLUS exp .)
    RBRACE          reduce using rule 72 (exp -> exp PLUS exp .)
    AND             reduce using rule 72 (exp -> exp PLUS exp .)
    OR              reduce using rule 72 (exp -> exp PLUS exp .)
    EQ              reduce using rule 72 (exp -> exp PLUS exp .)
    NEQ             reduce using rule 72 (exp -> exp PLUS exp .)
    GEQ             reduce using rule 72 (exp -> exp PLUS exp .)
    LEQ             reduce using rule 72 (exp -> exp PLUS exp .)
    GT              reduce using rule 72 (exp -> exp PLUS exp .)
    LT              reduce using rule 72 (exp -> exp PLUS exp .)
    TIMES           shift and go to state 139
    BY              shift and go to state 137

  ! TIMES           [ reduce using rule 72 (exp -> exp PLUS exp .) ]
  ! BY              [ reduce using rule 72 (exp -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 138 ]
  ! MINUS           [ shift and go to state 140 ]


state 166

    (73) exp -> exp TIMES exp .
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    COMMA           reduce using rule 73 (exp -> exp TIMES exp .)
    PLUS            reduce using rule 73 (exp -> exp TIMES exp .)
    TIMES           reduce using rule 73 (exp -> exp TIMES exp .)
    MINUS           reduce using rule 73 (exp -> exp TIMES exp .)
    BY              reduce using rule 73 (exp -> exp TIMES exp .)
    RPAR            reduce using rule 73 (exp -> exp TIMES exp .)
    NL              reduce using rule 73 (exp -> exp TIMES exp .)
    COLON           reduce using rule 73 (exp -> exp TIMES exp .)
    RBRACE          reduce using rule 73 (exp -> exp TIMES exp .)
    AND             reduce using rule 73 (exp -> exp TIMES exp .)
    OR              reduce using rule 73 (exp -> exp TIMES exp .)
    EQ              reduce using rule 73 (exp -> exp TIMES exp .)
    NEQ             reduce using rule 73 (exp -> exp TIMES exp .)
    GEQ             reduce using rule 73 (exp -> exp TIMES exp .)
    LEQ             reduce using rule 73 (exp -> exp TIMES exp .)
    GT              reduce using rule 73 (exp -> exp TIMES exp .)
    LT              reduce using rule 73 (exp -> exp TIMES exp .)

  ! PLUS            [ shift and go to state 138 ]
  ! TIMES           [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! BY              [ shift and go to state 137 ]


state 167

    (74) exp -> exp MINUS exp .
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    COMMA           reduce using rule 74 (exp -> exp MINUS exp .)
    PLUS            reduce using rule 74 (exp -> exp MINUS exp .)
    MINUS           reduce using rule 74 (exp -> exp MINUS exp .)
    RPAR            reduce using rule 74 (exp -> exp MINUS exp .)
    NL              reduce using rule 74 (exp -> exp MINUS exp .)
    COLON           reduce using rule 74 (exp -> exp MINUS exp .)
    RBRACE          reduce using rule 74 (exp -> exp MINUS exp .)
    AND             reduce using rule 74 (exp -> exp MINUS exp .)
    OR              reduce using rule 74 (exp -> exp MINUS exp .)
    EQ              reduce using rule 74 (exp -> exp MINUS exp .)
    NEQ             reduce using rule 74 (exp -> exp MINUS exp .)
    GEQ             reduce using rule 74 (exp -> exp MINUS exp .)
    LEQ             reduce using rule 74 (exp -> exp MINUS exp .)
    GT              reduce using rule 74 (exp -> exp MINUS exp .)
    LT              reduce using rule 74 (exp -> exp MINUS exp .)
    TIMES           shift and go to state 139
    BY              shift and go to state 137

  ! TIMES           [ reduce using rule 74 (exp -> exp MINUS exp .) ]
  ! BY              [ reduce using rule 74 (exp -> exp MINUS exp .) ]
  ! PLUS            [ shift and go to state 138 ]
  ! MINUS           [ shift and go to state 140 ]


state 168

    (11) actuatordecls -> ACTUATORS COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 184


state 169

    (13) sensordecls -> SENSORS COLON NL INDENT . decls DEDENT
    (21) decls -> . decl decls
    (22) decls -> . empty
    (23) decl -> . type varname ASGN exp NL
    (24) decl -> . type varname NL
    (99) empty -> .
    (36) type -> . INT
    (37) type -> . STRING
    (38) type -> . FLOAT
    (39) type -> . IPOS
    (40) type -> . BOOLEAN

    DEDENT          reduce using rule 99 (empty -> .)
    INT             shift and go to state 41
    STRING          shift and go to state 40
    FLOAT           shift and go to state 42
    IPOS            shift and go to state 43
    BOOLEAN         shift and go to state 44

    decl                           shift and go to state 39
    decls                          shift and go to state 185
    type                           shift and go to state 45
    empty                          shift and go to state 47

state 170

    (27) rvdecl -> type varname LBRACE owner RBRACE NL .

    INT             reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    STRING          reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    FLOAT           reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    IPOS            reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    BOOLEAN         reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)
    DEDENT          reduce using rule 27 (rvdecl -> type varname LBRACE owner RBRACE NL .)


state 171

    (60) stmt -> ATOMIC COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 186


state 172

    (69) stagechange -> STAGE ASGN varname . NL

    NL              shift and go to state 187


state 173

    (48) cond -> LPAR cond . AND cond RPAR
    (49) cond -> LPAR cond . OR cond RPAR
    (50) cond -> LPAR cond . op cond RPAR
    (93) op -> . EQ
    (94) op -> . NEQ
    (95) op -> . GEQ
    (96) op -> . LEQ
    (97) op -> . GT
    (98) op -> . LT

    AND             shift and go to state 188
    OR              shift and go to state 195
    EQ              shift and go to state 194
    NEQ             shift and go to state 193
    GEQ             shift and go to state 189
    LEQ             shift and go to state 191
    GT              shift and go to state 190
    LT              shift and go to state 192

    op                             shift and go to state 196

state 174

    (85) bracketexp -> LPAR exp . RPAR
    (52) cond -> exp .
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    RPAR            shift and go to state 157
    AND             reduce using rule 52 (cond -> exp .)
    OR              reduce using rule 52 (cond -> exp .)
    EQ              reduce using rule 52 (cond -> exp .)
    NEQ             reduce using rule 52 (cond -> exp .)
    GEQ             reduce using rule 52 (cond -> exp .)
    LEQ             reduce using rule 52 (cond -> exp .)
    GT              reduce using rule 52 (cond -> exp .)
    LT              reduce using rule 52 (cond -> exp .)
    PLUS            shift and go to state 138
    TIMES           shift and go to state 139
    MINUS           shift and go to state 140
    BY              shift and go to state 137


state 175

    (51) cond -> LPAR NOT . cond RPAR
    (48) cond -> . LPAR cond AND cond RPAR
    (49) cond -> . LPAR cond OR cond RPAR
    (50) cond -> . LPAR cond op cond RPAR
    (51) cond -> . LPAR NOT cond RPAR
    (52) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 150
    STAGE           shift and go to state 101
    LID             shift and go to state 90
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    cond                           shift and go to state 197
    exp                            shift and go to state 152
    bval                           shift and go to state 97

state 176

    (61) stmt -> IF cond COLON . NL INDENT stmts DEDENT elseblock

    NL              shift and go to state 198


state 177

    (66) asgn -> varname ASGN exp . NL
    (72) exp -> exp . PLUS exp
    (73) exp -> exp . TIMES exp
    (74) exp -> exp . MINUS exp
    (75) exp -> exp . BY exp

    NL              shift and go to state 199
    PLUS            shift and go to state 138
    TIMES           shift and go to state 139
    MINUS           shift and go to state 140
    BY              shift and go to state 137


state 178

    (70) wptstmt -> varname ASGN GETINPUT . LPAR RPAR NL

    LPAR            shift and go to state 200


state 179

    (45) event -> LID COLON NL INDENT PRE COLON . cond NL effblock DEDENT
    (48) cond -> . LPAR cond AND cond RPAR
    (49) cond -> . LPAR cond OR cond RPAR
    (50) cond -> . LPAR cond op cond RPAR
    (51) cond -> . LPAR NOT cond RPAR
    (52) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 150
    STAGE           shift and go to state 101
    LID             shift and go to state 90
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    cond                           shift and go to state 201
    exp                            shift and go to state 152
    bval                           shift and go to state 97

state 180

    (80) exp -> LID LBRACE exp RBRACE .

    COMMA           reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    PLUS            reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    TIMES           reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    MINUS           reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    BY              reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    RPAR            reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    NL              reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    COLON           reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    RBRACE          reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    AND             reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    OR              reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    EQ              reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    NEQ             reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    GEQ             reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    LEQ             reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    GT              reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)
    LT              reduce using rule 80 (exp -> LID LBRACE exp RBRACE .)


state 181

    (63) modulefunccall -> CID LPAR args RPAR .

    PLUS            reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    TIMES           reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    MINUS           reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    BY              reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    RPAR            reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    NL              reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    COLON           reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    RBRACE          reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    COMMA           reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    AND             reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    OR              reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    EQ              reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    NEQ             reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    GEQ             reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    LEQ             reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    GT              reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)
    LT              reduce using rule 63 (modulefunccall -> CID LPAR args RPAR .)


state 182

    (35) neargs -> exp COMMA . neargs
    (34) neargs -> . exp
    (35) neargs -> . exp COMMA neargs
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    STAGE           shift and go to state 101
    LID             shift and go to state 90
    LPAR            shift and go to state 91
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    exp                            shift and go to state 162
    neargs                         shift and go to state 202
    bval                           shift and go to state 97

state 183

    (30) funccall -> varname LPAR args RPAR .

    NL              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    PLUS            reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    TIMES           reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    MINUS           reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    BY              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    RPAR            reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    COLON           reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    RBRACE          reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    COMMA           reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    AND             reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    OR              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    EQ              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    NEQ             reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    GEQ             reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    LEQ             reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    GT              reduce using rule 30 (funccall -> varname LPAR args RPAR .)
    LT              reduce using rule 30 (funccall -> varname LPAR args RPAR .)


state 184

    (11) actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT .

    SENSORS         reduce using rule 11 (actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT .)
    DEDENT          reduce using rule 11 (actuatordecls -> ACTUATORS COLON NL INDENT decls DEDENT .)


state 185

    (13) sensordecls -> SENSORS COLON NL INDENT decls . DEDENT

    DEDENT          shift and go to state 203


state 186

    (60) stmt -> ATOMIC COLON NL INDENT . stmts DEDENT
    (53) stmts -> . stmt stmts
    (54) stmts -> . stmt
    (55) stmt -> . asgn
    (56) stmt -> . wptstmt
    (57) stmt -> . exit
    (58) stmt -> . funccall NL
    (59) stmt -> . modulefunccall NL
    (60) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (61) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (66) asgn -> . varname ASGN exp NL
    (67) asgn -> . stagechange
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (62) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (69) stagechange -> . STAGE ASGN varname NL

    ATOMIC          shift and go to state 115
    IF              shift and go to state 123
    EXIT            shift and go to state 127
    CID             shift and go to state 93
    LID             shift and go to state 60
    STAGE           shift and go to state 119

    stagechange                    shift and go to state 124
    funccall                       shift and go to state 120
    stmts                          shift and go to state 204
    varname                        shift and go to state 125
    stmt                           shift and go to state 122
    asgn                           shift and go to state 117
    modulefunccall                 shift and go to state 121
    wptstmt                        shift and go to state 126
    exit                           shift and go to state 118

state 187

    (69) stagechange -> STAGE ASGN varname NL .

    ATOMIC          reduce using rule 69 (stagechange -> STAGE ASGN varname NL .)
    IF              reduce using rule 69 (stagechange -> STAGE ASGN varname NL .)
    EXIT            reduce using rule 69 (stagechange -> STAGE ASGN varname NL .)
    CID             reduce using rule 69 (stagechange -> STAGE ASGN varname NL .)
    LID             reduce using rule 69 (stagechange -> STAGE ASGN varname NL .)
    STAGE           reduce using rule 69 (stagechange -> STAGE ASGN varname NL .)
    DEDENT          reduce using rule 69 (stagechange -> STAGE ASGN varname NL .)


state 188

    (48) cond -> LPAR cond AND . cond RPAR
    (48) cond -> . LPAR cond AND cond RPAR
    (49) cond -> . LPAR cond OR cond RPAR
    (50) cond -> . LPAR cond op cond RPAR
    (51) cond -> . LPAR NOT cond RPAR
    (52) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 150
    STAGE           shift and go to state 101
    LID             shift and go to state 90
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    cond                           shift and go to state 205
    exp                            shift and go to state 152
    bval                           shift and go to state 97

state 189

    (95) op -> GEQ .

    LPAR            reduce using rule 95 (op -> GEQ .)
    STAGE           reduce using rule 95 (op -> GEQ .)
    LID             reduce using rule 95 (op -> GEQ .)
    TRUE            reduce using rule 95 (op -> GEQ .)
    FALSE           reduce using rule 95 (op -> GEQ .)
    PID             reduce using rule 95 (op -> GEQ .)
    INUM            reduce using rule 95 (op -> GEQ .)
    FNUM            reduce using rule 95 (op -> GEQ .)
    NULL            reduce using rule 95 (op -> GEQ .)
    CID             reduce using rule 95 (op -> GEQ .)


state 190

    (97) op -> GT .

    LPAR            reduce using rule 97 (op -> GT .)
    STAGE           reduce using rule 97 (op -> GT .)
    LID             reduce using rule 97 (op -> GT .)
    TRUE            reduce using rule 97 (op -> GT .)
    FALSE           reduce using rule 97 (op -> GT .)
    PID             reduce using rule 97 (op -> GT .)
    INUM            reduce using rule 97 (op -> GT .)
    FNUM            reduce using rule 97 (op -> GT .)
    NULL            reduce using rule 97 (op -> GT .)
    CID             reduce using rule 97 (op -> GT .)


state 191

    (96) op -> LEQ .

    LPAR            reduce using rule 96 (op -> LEQ .)
    STAGE           reduce using rule 96 (op -> LEQ .)
    LID             reduce using rule 96 (op -> LEQ .)
    TRUE            reduce using rule 96 (op -> LEQ .)
    FALSE           reduce using rule 96 (op -> LEQ .)
    PID             reduce using rule 96 (op -> LEQ .)
    INUM            reduce using rule 96 (op -> LEQ .)
    FNUM            reduce using rule 96 (op -> LEQ .)
    NULL            reduce using rule 96 (op -> LEQ .)
    CID             reduce using rule 96 (op -> LEQ .)


state 192

    (98) op -> LT .

    LPAR            reduce using rule 98 (op -> LT .)
    STAGE           reduce using rule 98 (op -> LT .)
    LID             reduce using rule 98 (op -> LT .)
    TRUE            reduce using rule 98 (op -> LT .)
    FALSE           reduce using rule 98 (op -> LT .)
    PID             reduce using rule 98 (op -> LT .)
    INUM            reduce using rule 98 (op -> LT .)
    FNUM            reduce using rule 98 (op -> LT .)
    NULL            reduce using rule 98 (op -> LT .)
    CID             reduce using rule 98 (op -> LT .)


state 193

    (94) op -> NEQ .

    LPAR            reduce using rule 94 (op -> NEQ .)
    STAGE           reduce using rule 94 (op -> NEQ .)
    LID             reduce using rule 94 (op -> NEQ .)
    TRUE            reduce using rule 94 (op -> NEQ .)
    FALSE           reduce using rule 94 (op -> NEQ .)
    PID             reduce using rule 94 (op -> NEQ .)
    INUM            reduce using rule 94 (op -> NEQ .)
    FNUM            reduce using rule 94 (op -> NEQ .)
    NULL            reduce using rule 94 (op -> NEQ .)
    CID             reduce using rule 94 (op -> NEQ .)


state 194

    (93) op -> EQ .

    LPAR            reduce using rule 93 (op -> EQ .)
    STAGE           reduce using rule 93 (op -> EQ .)
    LID             reduce using rule 93 (op -> EQ .)
    TRUE            reduce using rule 93 (op -> EQ .)
    FALSE           reduce using rule 93 (op -> EQ .)
    PID             reduce using rule 93 (op -> EQ .)
    INUM            reduce using rule 93 (op -> EQ .)
    FNUM            reduce using rule 93 (op -> EQ .)
    NULL            reduce using rule 93 (op -> EQ .)
    CID             reduce using rule 93 (op -> EQ .)


state 195

    (49) cond -> LPAR cond OR . cond RPAR
    (48) cond -> . LPAR cond AND cond RPAR
    (49) cond -> . LPAR cond OR cond RPAR
    (50) cond -> . LPAR cond op cond RPAR
    (51) cond -> . LPAR NOT cond RPAR
    (52) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 150
    STAGE           shift and go to state 101
    LID             shift and go to state 90
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    cond                           shift and go to state 206
    exp                            shift and go to state 152
    bval                           shift and go to state 97

state 196

    (50) cond -> LPAR cond op . cond RPAR
    (48) cond -> . LPAR cond AND cond RPAR
    (49) cond -> . LPAR cond OR cond RPAR
    (50) cond -> . LPAR cond op cond RPAR
    (51) cond -> . LPAR NOT cond RPAR
    (52) cond -> . exp
    (71) exp -> . bracketexp
    (72) exp -> . exp PLUS exp
    (73) exp -> . exp TIMES exp
    (74) exp -> . exp MINUS exp
    (75) exp -> . exp BY exp
    (76) exp -> . varname
    (77) exp -> . STAGE
    (78) exp -> . bval
    (79) exp -> . pid
    (80) exp -> . LID LBRACE exp RBRACE
    (81) exp -> . num
    (82) exp -> . null
    (83) exp -> . funccall
    (84) exp -> . modulefunccall
    (85) bracketexp -> . LPAR exp RPAR
    (91) varname -> . LID
    (86) bval -> . TRUE
    (87) bval -> . FALSE
    (90) pid -> . PID
    (88) num -> . INUM
    (89) num -> . FNUM
    (92) null -> . NULL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR

    LPAR            shift and go to state 150
    STAGE           shift and go to state 101
    LID             shift and go to state 90
    TRUE            shift and go to state 99
    FALSE           shift and go to state 105
    PID             shift and go to state 100
    INUM            shift and go to state 108
    FNUM            shift and go to state 94
    NULL            shift and go to state 104
    CID             shift and go to state 93

    bracketexp                     shift and go to state 92
    funccall                       shift and go to state 102
    modulefunccall                 shift and go to state 103
    varname                        shift and go to state 106
    pid                            shift and go to state 95
    null                           shift and go to state 98
    num                            shift and go to state 96
    cond                           shift and go to state 207
    exp                            shift and go to state 152
    bval                           shift and go to state 97

state 197

    (51) cond -> LPAR NOT cond . RPAR

    RPAR            shift and go to state 208


state 198

    (61) stmt -> IF cond COLON NL . INDENT stmts DEDENT elseblock

    INDENT          shift and go to state 209


state 199

    (66) asgn -> varname ASGN exp NL .

    DEDENT          reduce using rule 66 (asgn -> varname ASGN exp NL .)
    ATOMIC          reduce using rule 66 (asgn -> varname ASGN exp NL .)
    IF              reduce using rule 66 (asgn -> varname ASGN exp NL .)
    EXIT            reduce using rule 66 (asgn -> varname ASGN exp NL .)
    CID             reduce using rule 66 (asgn -> varname ASGN exp NL .)
    LID             reduce using rule 66 (asgn -> varname ASGN exp NL .)
    STAGE           reduce using rule 66 (asgn -> varname ASGN exp NL .)


state 200

    (70) wptstmt -> varname ASGN GETINPUT LPAR . RPAR NL

    RPAR            shift and go to state 210


state 201

    (45) event -> LID COLON NL INDENT PRE COLON cond . NL effblock DEDENT

    NL              shift and go to state 211


state 202

    (35) neargs -> exp COMMA neargs .

    RPAR            reduce using rule 35 (neargs -> exp COMMA neargs .)


state 203

    (13) sensordecls -> SENSORS COLON NL INDENT decls DEDENT .

    DEDENT          reduce using rule 13 (sensordecls -> SENSORS COLON NL INDENT decls DEDENT .)


state 204

    (60) stmt -> ATOMIC COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 212


state 205

    (48) cond -> LPAR cond AND cond . RPAR

    RPAR            shift and go to state 213


state 206

    (49) cond -> LPAR cond OR cond . RPAR

    RPAR            shift and go to state 214


state 207

    (50) cond -> LPAR cond op cond . RPAR

    RPAR            shift and go to state 215


state 208

    (51) cond -> LPAR NOT cond RPAR .

    AND             reduce using rule 51 (cond -> LPAR NOT cond RPAR .)
    OR              reduce using rule 51 (cond -> LPAR NOT cond RPAR .)
    EQ              reduce using rule 51 (cond -> LPAR NOT cond RPAR .)
    NEQ             reduce using rule 51 (cond -> LPAR NOT cond RPAR .)
    GEQ             reduce using rule 51 (cond -> LPAR NOT cond RPAR .)
    LEQ             reduce using rule 51 (cond -> LPAR NOT cond RPAR .)
    GT              reduce using rule 51 (cond -> LPAR NOT cond RPAR .)
    LT              reduce using rule 51 (cond -> LPAR NOT cond RPAR .)
    RPAR            reduce using rule 51 (cond -> LPAR NOT cond RPAR .)
    COLON           reduce using rule 51 (cond -> LPAR NOT cond RPAR .)
    NL              reduce using rule 51 (cond -> LPAR NOT cond RPAR .)


state 209

    (61) stmt -> IF cond COLON NL INDENT . stmts DEDENT elseblock
    (53) stmts -> . stmt stmts
    (54) stmts -> . stmt
    (55) stmt -> . asgn
    (56) stmt -> . wptstmt
    (57) stmt -> . exit
    (58) stmt -> . funccall NL
    (59) stmt -> . modulefunccall NL
    (60) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (61) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (66) asgn -> . varname ASGN exp NL
    (67) asgn -> . stagechange
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (62) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (69) stagechange -> . STAGE ASGN varname NL

    ATOMIC          shift and go to state 115
    IF              shift and go to state 123
    EXIT            shift and go to state 127
    CID             shift and go to state 93
    LID             shift and go to state 60
    STAGE           shift and go to state 119

    stagechange                    shift and go to state 124
    funccall                       shift and go to state 120
    stmts                          shift and go to state 216
    varname                        shift and go to state 125
    stmt                           shift and go to state 122
    asgn                           shift and go to state 117
    modulefunccall                 shift and go to state 121
    wptstmt                        shift and go to state 126
    exit                           shift and go to state 118

state 210

    (70) wptstmt -> varname ASGN GETINPUT LPAR RPAR . NL

    NL              shift and go to state 217


state 211

    (45) event -> LID COLON NL INDENT PRE COLON cond NL . effblock DEDENT
    (46) effblock -> . EFF COLON NL INDENT stmts DEDENT
    (47) effblock -> . EFF COLON stmt

    EFF             shift and go to state 219

    effblock                       shift and go to state 218

state 212

    (60) stmt -> ATOMIC COLON NL INDENT stmts DEDENT .

    DEDENT          reduce using rule 60 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    ATOMIC          reduce using rule 60 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    IF              reduce using rule 60 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    EXIT            reduce using rule 60 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    CID             reduce using rule 60 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    LID             reduce using rule 60 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)
    STAGE           reduce using rule 60 (stmt -> ATOMIC COLON NL INDENT stmts DEDENT .)


state 213

    (48) cond -> LPAR cond AND cond RPAR .

    AND             reduce using rule 48 (cond -> LPAR cond AND cond RPAR .)
    OR              reduce using rule 48 (cond -> LPAR cond AND cond RPAR .)
    EQ              reduce using rule 48 (cond -> LPAR cond AND cond RPAR .)
    NEQ             reduce using rule 48 (cond -> LPAR cond AND cond RPAR .)
    GEQ             reduce using rule 48 (cond -> LPAR cond AND cond RPAR .)
    LEQ             reduce using rule 48 (cond -> LPAR cond AND cond RPAR .)
    GT              reduce using rule 48 (cond -> LPAR cond AND cond RPAR .)
    LT              reduce using rule 48 (cond -> LPAR cond AND cond RPAR .)
    RPAR            reduce using rule 48 (cond -> LPAR cond AND cond RPAR .)
    COLON           reduce using rule 48 (cond -> LPAR cond AND cond RPAR .)
    NL              reduce using rule 48 (cond -> LPAR cond AND cond RPAR .)


state 214

    (49) cond -> LPAR cond OR cond RPAR .

    AND             reduce using rule 49 (cond -> LPAR cond OR cond RPAR .)
    OR              reduce using rule 49 (cond -> LPAR cond OR cond RPAR .)
    EQ              reduce using rule 49 (cond -> LPAR cond OR cond RPAR .)
    NEQ             reduce using rule 49 (cond -> LPAR cond OR cond RPAR .)
    GEQ             reduce using rule 49 (cond -> LPAR cond OR cond RPAR .)
    LEQ             reduce using rule 49 (cond -> LPAR cond OR cond RPAR .)
    GT              reduce using rule 49 (cond -> LPAR cond OR cond RPAR .)
    LT              reduce using rule 49 (cond -> LPAR cond OR cond RPAR .)
    RPAR            reduce using rule 49 (cond -> LPAR cond OR cond RPAR .)
    COLON           reduce using rule 49 (cond -> LPAR cond OR cond RPAR .)
    NL              reduce using rule 49 (cond -> LPAR cond OR cond RPAR .)


state 215

    (50) cond -> LPAR cond op cond RPAR .

    AND             reduce using rule 50 (cond -> LPAR cond op cond RPAR .)
    OR              reduce using rule 50 (cond -> LPAR cond op cond RPAR .)
    EQ              reduce using rule 50 (cond -> LPAR cond op cond RPAR .)
    NEQ             reduce using rule 50 (cond -> LPAR cond op cond RPAR .)
    GEQ             reduce using rule 50 (cond -> LPAR cond op cond RPAR .)
    LEQ             reduce using rule 50 (cond -> LPAR cond op cond RPAR .)
    GT              reduce using rule 50 (cond -> LPAR cond op cond RPAR .)
    LT              reduce using rule 50 (cond -> LPAR cond op cond RPAR .)
    RPAR            reduce using rule 50 (cond -> LPAR cond op cond RPAR .)
    COLON           reduce using rule 50 (cond -> LPAR cond op cond RPAR .)
    NL              reduce using rule 50 (cond -> LPAR cond op cond RPAR .)


state 216

    (61) stmt -> IF cond COLON NL INDENT stmts . DEDENT elseblock

    DEDENT          shift and go to state 220


state 217

    (70) wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .

    ATOMIC          reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    IF              reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    EXIT            reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    CID             reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    LID             reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    STAGE           reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)
    DEDENT          reduce using rule 70 (wptstmt -> varname ASGN GETINPUT LPAR RPAR NL .)


state 218

    (45) event -> LID COLON NL INDENT PRE COLON cond NL effblock . DEDENT

    DEDENT          shift and go to state 221


state 219

    (46) effblock -> EFF . COLON NL INDENT stmts DEDENT
    (47) effblock -> EFF . COLON stmt

    COLON           shift and go to state 222


state 220

    (61) stmt -> IF cond COLON NL INDENT stmts DEDENT . elseblock
    (64) elseblock -> . ELSE COLON NL INDENT stmts DEDENT
    (65) elseblock -> . empty
    (99) empty -> .

    ELSE            shift and go to state 224
    ATOMIC          reduce using rule 99 (empty -> .)
    IF              reduce using rule 99 (empty -> .)
    EXIT            reduce using rule 99 (empty -> .)
    CID             reduce using rule 99 (empty -> .)
    LID             reduce using rule 99 (empty -> .)
    STAGE           reduce using rule 99 (empty -> .)
    DEDENT          reduce using rule 99 (empty -> .)

    elseblock                      shift and go to state 223
    empty                          shift and go to state 225

state 221

    (45) event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .

    LID             reduce using rule 45 (event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .)
    NUM             reduce using rule 45 (event -> LID COLON NL INDENT PRE COLON cond NL effblock DEDENT .)


state 222

    (46) effblock -> EFF COLON . NL INDENT stmts DEDENT
    (47) effblock -> EFF COLON . stmt
    (55) stmt -> . asgn
    (56) stmt -> . wptstmt
    (57) stmt -> . exit
    (58) stmt -> . funccall NL
    (59) stmt -> . modulefunccall NL
    (60) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (61) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (66) asgn -> . varname ASGN exp NL
    (67) asgn -> . stagechange
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (62) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (69) stagechange -> . STAGE ASGN varname NL

    NL              shift and go to state 226
    ATOMIC          shift and go to state 115
    IF              shift and go to state 123
    EXIT            shift and go to state 127
    CID             shift and go to state 93
    LID             shift and go to state 60
    STAGE           shift and go to state 119

    stagechange                    shift and go to state 124
    funccall                       shift and go to state 120
    varname                        shift and go to state 125
    stmt                           shift and go to state 227
    asgn                           shift and go to state 117
    modulefunccall                 shift and go to state 121
    wptstmt                        shift and go to state 126
    exit                           shift and go to state 118

state 223

    (61) stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .

    DEDENT          reduce using rule 61 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    ATOMIC          reduce using rule 61 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    IF              reduce using rule 61 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    EXIT            reduce using rule 61 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    CID             reduce using rule 61 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    LID             reduce using rule 61 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)
    STAGE           reduce using rule 61 (stmt -> IF cond COLON NL INDENT stmts DEDENT elseblock .)


state 224

    (64) elseblock -> ELSE . COLON NL INDENT stmts DEDENT

    COLON           shift and go to state 228


state 225

    (65) elseblock -> empty .

    ATOMIC          reduce using rule 65 (elseblock -> empty .)
    IF              reduce using rule 65 (elseblock -> empty .)
    EXIT            reduce using rule 65 (elseblock -> empty .)
    CID             reduce using rule 65 (elseblock -> empty .)
    LID             reduce using rule 65 (elseblock -> empty .)
    STAGE           reduce using rule 65 (elseblock -> empty .)
    DEDENT          reduce using rule 65 (elseblock -> empty .)


state 226

    (46) effblock -> EFF COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 229


state 227

    (47) effblock -> EFF COLON stmt .

    DEDENT          reduce using rule 47 (effblock -> EFF COLON stmt .)


state 228

    (64) elseblock -> ELSE COLON . NL INDENT stmts DEDENT

    NL              shift and go to state 230


state 229

    (46) effblock -> EFF COLON NL INDENT . stmts DEDENT
    (53) stmts -> . stmt stmts
    (54) stmts -> . stmt
    (55) stmt -> . asgn
    (56) stmt -> . wptstmt
    (57) stmt -> . exit
    (58) stmt -> . funccall NL
    (59) stmt -> . modulefunccall NL
    (60) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (61) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (66) asgn -> . varname ASGN exp NL
    (67) asgn -> . stagechange
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (62) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (69) stagechange -> . STAGE ASGN varname NL

    ATOMIC          shift and go to state 115
    IF              shift and go to state 123
    EXIT            shift and go to state 127
    CID             shift and go to state 93
    LID             shift and go to state 60
    STAGE           shift and go to state 119

    stagechange                    shift and go to state 124
    funccall                       shift and go to state 120
    stmts                          shift and go to state 231
    varname                        shift and go to state 125
    stmt                           shift and go to state 122
    asgn                           shift and go to state 117
    modulefunccall                 shift and go to state 121
    wptstmt                        shift and go to state 126
    exit                           shift and go to state 118

state 230

    (64) elseblock -> ELSE COLON NL . INDENT stmts DEDENT

    INDENT          shift and go to state 232


state 231

    (46) effblock -> EFF COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 233


state 232

    (64) elseblock -> ELSE COLON NL INDENT . stmts DEDENT
    (53) stmts -> . stmt stmts
    (54) stmts -> . stmt
    (55) stmt -> . asgn
    (56) stmt -> . wptstmt
    (57) stmt -> . exit
    (58) stmt -> . funccall NL
    (59) stmt -> . modulefunccall NL
    (60) stmt -> . ATOMIC COLON NL INDENT stmts DEDENT
    (61) stmt -> . IF cond COLON NL INDENT stmts DEDENT elseblock
    (66) asgn -> . varname ASGN exp NL
    (67) asgn -> . stagechange
    (70) wptstmt -> . varname ASGN GETINPUT LPAR RPAR NL
    (62) exit -> . EXIT NL
    (30) funccall -> . varname LPAR args RPAR
    (63) modulefunccall -> . CID LPAR args RPAR
    (91) varname -> . LID
    (69) stagechange -> . STAGE ASGN varname NL

    ATOMIC          shift and go to state 115
    IF              shift and go to state 123
    EXIT            shift and go to state 127
    CID             shift and go to state 93
    LID             shift and go to state 60
    STAGE           shift and go to state 119

    stagechange                    shift and go to state 124
    funccall                       shift and go to state 120
    stmts                          shift and go to state 234
    varname                        shift and go to state 125
    stmt                           shift and go to state 122
    asgn                           shift and go to state 117
    modulefunccall                 shift and go to state 121
    wptstmt                        shift and go to state 126
    exit                           shift and go to state 118

state 233

    (46) effblock -> EFF COLON NL INDENT stmts DEDENT .

    DEDENT          reduce using rule 46 (effblock -> EFF COLON NL INDENT stmts DEDENT .)


state 234

    (64) elseblock -> ELSE COLON NL INDENT stmts . DEDENT

    DEDENT          shift and go to state 235


state 235

    (64) elseblock -> ELSE COLON NL INDENT stmts DEDENT .

    ATOMIC          reduce using rule 64 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    IF              reduce using rule 64 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    EXIT            reduce using rule 64 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    CID             reduce using rule 64 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    LID             reduce using rule 64 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    STAGE           reduce using rule 64 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)
    DEDENT          reduce using rule 64 (elseblock -> ELSE COLON NL INDENT stmts DEDENT .)

